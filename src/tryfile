# vim: ft=perl6
use MONKEY_TYPING;

use STD;
use Stash;
use NAME;
use JSYNC;
use NieczaGrammar;

augment class Match {
    method trim_heredoc () { self } # NYI
}

augment class STD {
method lineof ($p) {
    return 1 unless defined $p;
    my $line = @*LINEMEMOS[$p];
    return $line if $line;
    $line = 1; my $pos = 0;
    my $lm = @*LINEMEMOS;
    self.orig ~~ / :r [ \n { $lm[$pos++] = $line++ } ||
                        .  { $lm[$pos++] = $line } ]* /;
    $lm[$pos++] = $line;
    return $lm[$p] // 0;
}

    our $ALL;
method lookup_dynvar($name) { Any } # NYI
method check_old_cclass($text) { } # NYI
method do_use($module,$args) {
    self.do_need($module);
    self.do_import($module,$args);
    self;
}

method do_need($mo) {
    my $module = $mo.Str;
    my $topsym;
    try { $topsym = self.sys_load_modinfo($module); }
    if !$topsym {
        self.panic("Could not load $module");
    }
    self.add_my_name($module);
    $*DECLARAND<really> = $topsym;
    self;
}

method sys_load_modinfo($module) {
    # TODO: Implement compile-on-demand.  Requires some kind of modtime API.
    from-jsync(slurp($module ~ ".syml"));
}

method load_lex($setting) {
    if $setting eq 'NULL' {
        my $id = "MY:file<NULL.pad>:line(1):pos(0)";
        my $core = Stash.new('!id' => [$id], '!file' => 'NULL.pad',
            '!line' => 1);
        return Stash.new('CORE' => $core, 'MY:file<NULL.pad>' => $core,
            'SETTING' => $core, $id => $core);
    }

    return Stash.new(%( from-jsync(slurp($setting ~ ".syml")) ));
}
}

augment class Cursor {
    our $RED    = "\e[31m";
    our $GREEN  = "\e[32m";
    our $YELLOW = "\e[33m";
    our $CLEAR  = "\e[37m";
}

sub compiler(:$filename, :$text, :$settingname, :$niecza) {
    my $*SETTINGNAME = $settingname;
    my @*MEMOS;
    my @*LINEMEMOS;
    my $*FILE = { name => $filename };
    my @*ACTIVE;
    my $*HIGHWATER = 0;
    my $*HIGHEXPECT = {};
    my $*HIGHMESS = "";
    my $*LASTSTATE = 0;
    my $*IN_PANIC = 0;
    my $*IN_SUPPOSE = 0;
    my $*FATALS = 0;

    $DEBUG::EXPR = False;
    $STD::DEBUG::EXPR = False;
    $STD::DEBUG::symtab = False;

    my $*LAST_NIBBLE = 0;
    my $*LAST_NIBBLE_START = 0;
    my $*LAST_NIBBLE_MULTILINE = 0;
    my $*LAST_NIBBLE_MULTILINE_START = 0;
    my $*GOAL = "(eof)";
    my $*SETTING; my $*CORE; my $*GLOBAL; my $*UNIT; my $*YOU_WERE_HERE;
    my $*CCSTATE; my $*BORG; my %*RX; my $*XACT; my $*VAR; my $*IN_REDUCE;
    ($niecza ?? NieczaGrammar !! STD).parse($text);

    my $all;

    # setting?
    if $*YOU_WERE_HERE {
        $all = $STD::ALL;
        $all<SETTING> = $*YOU_WERE_HERE;
        $all<CORE> = $*YOU_WERE_HERE if $*UNIT<$?LONGNAME> eq 'CORE';
        my %keepname;
        my $ptr = 'SETTING';
        while $all{$ptr}:exists {
            %keepname{$ptr} = True;
            %keepname{$all{$ptr}.id} = True;
            #say "Keeping $ptr";
            $ptr = $all{$ptr}<OUTER::>[0];
            #say "Moving cursor to $ptr";
        }
        for keys %$all -> $key {
            if $key ~~ /^MY/ && $key !~~ /\:\:/ && !%keepname{$key} {
                $all{$key}:delete;
            }
        }
    }
    else {
        $all = {};
        for keys %( $STD::ALL ) -> $key {
            next if (/MY\:file\<\w+:\.setting\>/)(Cursor.new($key)) or $key eq 'CORE' or $key eq 'SETTING';
            $all{$key} = $STD::ALL{$key};
        }
    }

    $all
}

if !@*ARGS {
    note "Usage: tryfile.exe [--symbols]? [--niecza]? [--setting NAME]? [-e TEXT | FILENAME | -]";
    exit 1;
}

my $symbols = False;
my $setting = 'CORE';
my $niecza = False;
if @*ARGS[0] eq '--symbols' {
    $symbols = True;
    shift @*ARGS;
}
if @*ARGS[0] eq '--niecza' {
    $niecza = True;
    shift @*ARGS;
}
if @*ARGS[0] eq '--setting' {
    shift @*ARGS;
    $setting = shift @*ARGS;
}

my $out;
if @*ARGS[0] eq '-' {
    $out = compiler(filename => '(eval)', text => $*IN.slurp, settingname => $setting, niecza => $niecza);
} elsif @*ARGS[0] eq '-e' {
    $out = compiler(filename => '(eval)', text => @*ARGS[1], settingname => $setting, niecza => $niecza);
} else {
    $out = compiler(filename => @*ARGS[0], text => slurp(@*ARGS[0]), settingname => $setting, niecza => $niecza);
}

if $symbols {
    say to-jsync($out);
} else {
    say "OK"
}
