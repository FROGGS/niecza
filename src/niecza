use Metamodel;
use Op;
use RxOp;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaBackendHoopl;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;
use OptRxSimple;
use STD;
use Stash;
use Sig;

augment class STD {
method explain_mystery() {
    my %post_types;
    my %unk_types;
    my %unk_routines;
    my $m = '';
    for keys(%*MYSTERY) {
        my $p = %*MYSTERY{$_}.<lex>;
        if self.is_name($_, $p) {
            # types may not be post-declared
            %post_types{$_} = %*MYSTERY{$_};
            next;
        }

        next if self.is_known($_, $p) or self.is_known('&' ~ $_, $p);

        # just a guess, but good enough to improve error reporting
        if $_ lt 'a' {
            %unk_types{$_} = %*MYSTERY{$_};
        }
        else {
            %unk_routines{$_} = %*MYSTERY{$_};
        }
    }
    if %post_types {
        my @tmp = sort keys(%post_types);
        $m ~= "Illegally post-declared type" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %post_types{$_}.<line> ~ "\n";
        }
    }
    if %unk_types {
        my @tmp = sort keys(%unk_types);
        $m ~= "Undeclared name" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %unk_types{$_}.<line> ~ "\n";
        }
    }
    if %unk_routines {
        my @tmp = sort keys(%unk_routines);
        $m ~= "Undeclared routine" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %unk_routines{$_}.<line> ~ "\n";
        }
    }
    self.sorry($m) if $m;

    for $*unit.stubbed_stashes {
        next if .key.closed;
        .value.sorry("Package was stubbed but not defined");
    }

    self;
}
}

augment class Metamodel::StaticSub { #OK
    method noninlinable() {
        loop (my $c = self; $c && $c.unit === $*unit; $c = $c.outer) {
            $c.strong_used = True;
        }
    }
}

augment class NieczaGrammar::P6 { #OK
    method unitstart() {
        my $top = $*unit.setting_ref;
        my $rtop = $top && $*unit.deref($top);
        $*CURLEX{'!sub'} = ::Metamodel::StaticSub.new(
            unit => $*unit,
            outerx => $top,
            cur_pkg => ['GLOBAL'],
            name => "mainline",
            run_once => !$rtop || $rtop.run_once);
        $*CURLEX{'!sub'}.add_my_name('$_') if !$top;
        $*CURLEX{'!sub'}.add_hint('$?FILE');
        $*CURLEX{'!sub'}.signature = Sig.simple();
        $*unit.mainline = $*CURLEX<!sub>;

        %*LANG<Q> = ::NieczaGrammar::Q ;
        %*LANG<MAIN> = ::NieczaGrammar::P6 ;
        self;
    }
}

augment class NieczaActions {
method thunk_sub($code, :$params = [], :$name, :$class) {
    my $n = ::Metamodel::StaticSub.new(
        outerx => $*CURLEX<!sub>.xref,
        class => $class // 'Block',
        unit => $*unit,
        name => $name // 'ANON',
        transparent => True,
        code => $code,
        in_class => $*CURLEX<!sub>.in_class,
        cur_pkg => $*CURLEX<!sub>.cur_pkg);
    $n.signature = Sig.simple(@$params);
    $n.add_my_name($_, :noinit) for @$params;
    $n.add_my_name('$*/') if $class eq 'Regex';
    $*CURLEX<!sub>.add_child($n);
    $n;
}

method rxembed($/, $op, $) {
    self.inliney_call($/,
        self.thunk_sub($op, params => ['$Â¢']),
        ::Op::MakeCursor.new);
}

method op_for_regex($/, $rxop) {
    my @lift = $rxop.oplift;
    {
        my $*paren = 0;
        my $*dba = 'anonymous rule';
        my $*symtext;
        my $*endsym;
        $rxop.check
    }
    my ($orxop, $mb) = OptRxSimple.run($rxop);
    self.block_expr($/, self.thunk_sub(::Op::RegexBody.new(|node($/),
            canback => $mb, pre => @lift, rxop => $orxop),
        class => 'Regex', params => ['self']));
}

method encapsulate_regex($/, $rxop, :$goal, :$passcut = False,
        :$passcap = False) {
    my @lift = $rxop.oplift;
    my $lad = $rxop.lad;
    my ($nrxop, $mb) = OptRxSimple.run($rxop);
    if defined $goal {
        unshift @lift, ::Op::Bind.new(|node($/), readonly => True,
            lhs => mklex($/, '$*GOAL'),
            rhs => ::Op::StringLiteral.new(text => $goal));
    }
    my $subop = self.thunk_sub(
        ::Op::RegexBody.new(canback => $mb, pre => @lift, :$passcut, :$passcap,
            rxop => $nrxop), ltm => $lad, class => 'Regex', type => 'regex',
        params => ['self']);
    $subop.add_my_name('$*GOAL') if defined($goal);
    $subop = ::Op::CallSub.new(|node($/), invocant => self.block_expr($/, $subop),
        positionals => [ ::Op::MakeCursor.new(|node($/)) ]);
    ::RxOp::Subrule.new(regex => $subop, :$passcap, _passcapzyg => $nrxop,
        _passcapltm => $lad);
}

method package_def ($/) {
    my $sub = $*CURLEX<!sub>;

    my $bodyvar = self.gensym;
    $sub.outer.add_my_sub_child($bodyvar, $sub);
    $sub.code = ($<blockoid> // $<statementlist>).ast;

    if $sub.augmenting {
        my $ah = $sub.augment_hack;
        $sub.augment_hack = Any;

        my $ph = ::Metamodel::StaticSub.new(
            unit       => $*unit,
            outerx     => $sub.xref,
            cur_pkg    => [ 'GLOBAL' ],
            name       => 'ANON',
            is_phaser  => 0,
            augment_hack => $ah,
            class      => 'Code',
            code       => ::Op::StatementList.new(children => []),
            run_once   => $sub.run_once);
        $sub.create_static_pad;
        $sub.add_child($ph);

        make ::Op::CallSub.new(|node($/), invocant => mklex($/, $bodyvar));
    }
    else {
        my $obj = $*unit.deref($sub.body_of);

        if $*DECLARAND<stub> {
            push $*unit.stubbed_stashes, ($obj => $/.CURSOR);

            make mklex($/, $*CURLEX<!sub>.outervar);
        }
        else {
            $obj.close;

            if $obj ~~ ::Metamodel::ParametricRole {
                $sub.parametric_role_hack = $obj.xref;
                $sub.add_my_name('*params', :noinit);
                $sub.create_static_pad;
            }

            make ::Op::StatementList.new(|node($/), children => [
                ::Op::CallSub.new(invocant => mklex($/, $bodyvar)),
                ::Op::Lexical.new(name => $*CURLEX<!sub>.outervar) ]);
        }
    }
}

method open_package_def($, $/ = $*cursor) {
    my %_decl2mclass = (
        package => ::Metamodel::Package,
        class   => ::Metamodel::Class,
        module  => ::Metamodel::Module,
        grammar => ::Metamodel::Grammar,
        role    => ::Metamodel::Role,
    );
    my $sub = $*CURLEX<!sub>;

    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }

    my $scope = $*SCOPE;
    if !$<longname> {
        $scope = 'anon';
    }

    if $scope eq 'supersede' {
        $/.CURSOR.sorry('Supercede is not yet supported');
        $scope = 'our';
    }
    if $scope eq 'has' || $scope eq 'state' {
        $/.CURSOR.sorry("Illogical scope $scope for package block");
        $scope = 'our';
    }

    if $scope eq 'augment' {
        my $r = self.mangle_longname($<longname>[0], True);
        my $name = $r<name>;
        my @augpkg = @( $r<path> // ['MY'] );

        my $pkg = $sub.outer.find_pkg([ @augpkg, $name ]);
        my $so  = $*unit.get_item($pkg);
        my $dso = $*unit.deref($so);

        if $dso.^isa(::Metamodel::Role) {
            $/.CURSOR.panic("Illegal augment of a role");
        }

        my @ah = $so;
        $sub.augment_hack = @ah;
        $sub.body_of = $sub.in_class = $so;
        $sub.augmenting = True;
        $sub.set_name("augment-$dso.name()");
    } else {
        my ($name, $ourpkg);
        my $type = %_decl2mclass{$*PKGDECL};
        if ($*PKGDECL//'role') eq 'role' && $<signature> {
            $sub.signature = $<signature>.ast;
            $type = ::Metamodel::ParametricRole;
        }
        my @ns;
        if $<longname> {
            my $r = self.mangle_longname($<longname>[0], True);
            $name = $r<name>;
            if ($r<path>:exists) && $scope ne 'our' {
                $/.CURSOR.sorry("Block name $<longname> requires our scope");
                $scope = 'our';
            }
            if $scope eq 'our' {
                $ourpkg = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            }
            try @ns = @( $*CURLEX<!sub>.outer.find_pkg(
                [ @( $r<path> // ['MY'] ), $r<name> ]) );
            $*CURLEX<!sub>.outervar = ($scope eq 'anon' || ($r<path>:exists))
                ?? self.gensym !! $name;
        } else {
            $*CURLEX<!sub>.outervar = self.gensym;
            $name = 'ANON';
        }

        my $old = @ns ?? $*unit.get_item([@ns]) !! Any;

        if $old && ($old.[0] ne $*unit.name || $*unit.deref($old).closed) {
            $/.CURSOR.panic("Redefinition of class [@ns]");
        }
        my $obj;
        if $old {
            $obj = $*unit.deref($old);
        } else {
            @ns = $ourpkg ?? (@( $sub.outer.find_pkg($ourpkg) ), $name) !!
                $*unit.anon_stash;

            $*unit.create_stash([@ns]);

            $sub.outer.add_my_stash($*CURLEX<!sub>.outervar, [@ns]);
            $obj = $type.new(:$name);
            $obj.exports = [ [@ns] ];
            $*unit.bind_item([@ns], $obj.xref);
        }

        $sub.body_of = $sub.in_class = $obj.xref;
        $sub.cur_pkg = [@ns];

        self.process_block_traits($/, $<trait>);
        $sub.set_name($*PKGDECL ~ "-" ~ $obj.name);
    }
}


method declarator($/) {
    if $<signature> {
        my @p = @( $<signature>.ast.params );
        # TODO: keep the original signature around somewhere := can find it
        for @p {
            # TODO: fanciness checks
            $_ = mklex($/, .slot, list => .list, hash => .hash);
        }
        make ::Op::SimpleParcel.new(|node($/), items => @p);
        return;
    }
    make $<variable_declarator> ?? $<variable_declarator>.ast !!
         $<routine_declarator>  ?? $<routine_declarator>.ast !!
         $<regex_declarator>    ?? $<regex_declarator>.ast !!
         $<type_declarator>.ast;
}

method package_var($/, $slot, $name, $path, :$list, :$hash) {
    $*CURLEX<!sub>.add_common_name($slot,
        $*CURLEX<!sub>.find_pkg($path), $name);
    ::Op::PackageVar.new(|node($/), :$slot, :$name, :$path, :$list, :$hash);
}

method term:name ($/) {
    my ($id, $path) = self.mangle_longname($<longname>).<name path>;

    $id = '&' ~ $id if $<args>;

    if defined $path {
        make self.package_var($/, self.gensym, $id, $path);
    } else {
        make mklex($/, $id);
    }

    if $<postcircumfix> {
        make mkcall($/, '&_param_role_inst', $/.ast,
            @( $<postcircumfix>[0].ast.args ));
    } elsif $<args> {
        my $sal = $<args>.ast // [];
        # TODO: support zero-D slicels

        if $sal > 1 {
            $/.CURSOR.sorry("Slicel lists are NYI");
            return;
        }

        make ::Op::CallSub.new(|node($/), invocant => $/.ast,
            args => $sal[0] // []);
    }
}

method variable_declarator($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    for @$<trait> -> $t {
        if $t.ast<rw> {
        } else {
            $/.CURSOR.sorry("Trait $t.ast.keys.[0] not available on variables");
        }
    }
    if $<post_constraint> || $<postcircumfix> || $<semilist> {
        $/.CURSOR.sorry("Postconstraints, and shapes on variable declarators NYI");
    }

    my $scope = $*SCOPE // 'my';

    if $scope eq 'augment' || $scope eq 'supersede' {
        $/.CURSOR.sorry("Illogical scope $scope for simple variable");
    }

    my $typeconstraint;
    if $*OFTYPE {
        $typeconstraint = self.simple_longname($*OFTYPE<longname>);
        $/.CURSOR.sorry("Common variables are not unique definitions and may not have types") if $scope eq 'our';
    }

    my $v = $<variable>.ast;
    my $t = $v<twigil>;
    my $list = $v<sigil> eq '@';
    my $hash = $v<sigil> eq '%';
    if ($t && defined "?=~^:".index($t)) {
        $/.CURSOR.sorry("Variables with the $t twigil cannot be declared " ~
            "using $scope; they are created " ~
            ($t eq '?' ?? "using 'constant'." !!
             $t eq '=' ?? "by parsing POD blocks." !!
             $t eq '~' ?? "by 'slang' definitions." !!
             "automatically as parameters to the current block."));
    }

    if $scope ne 'has' && ($t eq '.' || $t eq '!') {
        $/.CURSOR.sorry("Twigil $t is only valid on attribute definitions ('has').");
    }

    if defined $v<rest> {
        $/.CURSOR.sorry(":: syntax is only valid when referencing variables, not when defining them.");
    }

    my $name = $v<sigil> ~ $v<twigil> ~ $v<name>;
    # otherwise identical to my
    my $slot = ($scope eq 'anon') ?? self.gensym !! $name;
    my $res_tc = $typeconstraint ??
        $*unit.get_item($*CURLEX<!sub>.find_pkg($typeconstraint)) !! Any;

    if $scope eq 'has' {
        make self.add_attribute($/, $v<name>, $v<sigil>, $t eq '.', $res_tc);
    } elsif $scope eq 'state' {
        $*CURLEX<!sub>.add_state_name($slot, self.gensym, :$list,
            :$hash, typeconstraint => $res_tc);
        make mklex($/, $slot, :$list, :$hash, :state_decl);
    } elsif $scope eq 'our' {
        make self.package_var($/, $slot, $slot, ['OUR'], :$list, :$hash);
    } else {
        $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash,
            typeconstraint => $res_tc);
        make mklex($/, $slot, :$list, :$hash);
    }
}

method do_variable_reference($M, $v) {
    if $v<term> {
        return $v<term>;
    }

    my $tw = $v<twigil>;
    my $sl = $v<sigil> ~ $tw ~ $v<name>;
    my $list = $v<sigil> eq '@';
    my $hash = $v<sigil> eq '%';

    if defined($v<rest>) && $tw ~~ /<[*=~?^:]>/ {
        $M.CURSOR.sorry("Twigil $tw cannot be used with qualified names");
        return ::Op::StatementList.new;
    }

    if $tw eq '!' {
        my $pclass;
        if $v<rest> {
            $pclass = $*unit.get_item($*CURLEX<!sub>.find_pkg($v<rest>));
        } elsif $*CURLEX<!sub>.in_class -> $c {
            $pclass = $c;
        } else {
            $M.CURSOR.sorry("Cannot resolve class for private method");
        }
        self.docontext($M, $v<sigil>, ::Op::CallMethod.new(|node($M),
            name => $v<name>, private => True, receiver => mklex($M, 'self'),
            :$pclass));
    }
    elsif $tw eq '.' {
        if defined $v<rest> {
            $M.CURSOR.sorry('$.Foo::bar syntax NYI');
            return ::Op::StatementList.new;
        }

        self.docontext($M, $v<sigil>, ::Op::CallMethod.new(|node($M),
            name => $v<name>, receiver => mklex($M, 'self')));
    }
    # no twigil in lex name for these
    elsif $tw eq '^' || $tw eq ':' {
        mklex($M, $v<sigil> ~ $v<name>, :$hash, :$list);
    }
    elsif $tw eq '*' {
        ::Op::ContextVar.new(|node($M), name => $sl);
    }
    elsif $tw eq '' || $tw eq '?' {
        if defined($v<rest>) {
            self.package_var($M, self.gensym, $sl, $v<rest>,
                hash => ($v<sigil> eq '%'), list => ($v<sigil> eq '@'))
        } elsif $tw eq '?' && $sl eq '$?POSITION' {
            mkcall($M, '&infix:<..^>',
                ::Op::Num.new(|node($M), value => [10, ~$M.from]),
                ::Op::Num.new(|node($M), value => [10, ~$M.to]));
        } elsif $tw eq '?' && $sl eq '$?LINE' {
            ::Op::Num.new(|node($M), value => [10, ~$M.cursor.lineof($M.from)]);
        } elsif $tw eq '?' && $sl eq '&?BLOCK' {
            $*CURLEX<!sub>.noninlinable;
            ::Op::GetBlock.new(|node($M))
        } elsif $tw eq '?' && $sl eq '&?ROUTINE' {
            $*CURLEX<!sub>.noninlinable;
            ::Op::GetBlock.new(|node($M), :routine)
        } else {
            mklex($M, $sl, :$hash, :$list);
        }
    }
    else {
        $M.CURSOR.sorry("Unhandled reference twigil $tw");
    }
}

method statement($/) {
    if $<label> {
        $*CURLEX<!sub>.add_label(~$<label><identifier>);
        make ::Op::Labelled.new(|node($/), name => ~$<label><identifier>,
            stmt => $<statement>.ast);
        return;
    }

    make ($<statement_control> ?? $<statement_control>.ast !!
        $<EXPR> ?? $<EXPR>.ast !! ::Op::StatementList.new);

    if $<statement_mod_cond> {
        my ($sym, $exp) = @( $<statement_mod_cond>[0].ast );

        if $sym eq 'if' {
            make ::Op::Conditional.new(|node($/), check => $exp,
                true => $/.ast, false => Any);
        } elsif $sym eq 'unless' {
            make ::Op::Conditional.new(|node($/), check => $exp,
                false => $/.ast, true => Any);
        } elsif $sym eq 'when' {
            make ::Op::Conditional.new(|node($/),
                check => ::Op::CallMethod.new(name => 'ACCEPTS',
                    receiver => $exp, positionals => [ mklex($/, '$_') ]),
                true => $/.ast, false => Any);
        } else {
            $/.CURSOR.sorry("Unhandled statement modifier $sym");
            make ::Op::StatementList.new;
            return Nil;
        }
    }

    if $<statement_mod_loop> {
        my ($sym, $exp) = @( $<statement_mod_loop>[0].ast );

        if $sym eq 'while' {
            make ::Op::WhileLoop.new(|node($/), check => $exp,
                body => $/.ast, until => False, once => False);
        } elsif $sym eq 'until' {
            make ::Op::WhileLoop.new(|node($/), check => $exp,
                body => $/.ast, until => True, once => False);
        } elsif $sym eq 'given' {
            make mktemptopic($/, $exp, $/.ast);
        } elsif $sym eq 'for' {
            # XXX laziness, comprehensions
            my $var = self.gensym;
            make ::Op::ImmedForLoop.new(|node($/), :$var, source => $exp,
                sink => mktemptopic($/, ::Op::LetVar.new(name => $var), $/.ast));
        } else {
            $/.CURSOR.sorry("Unhandled statement modifier $sym");
            make ::Op::StatementList.new;
            return Nil;
        }
    }
}


method infix:sym<...> ($/) {
    # STD parses ...^ in the ... rule
    make Operator.funop('&infix:<' ~ $/ ~ '>', 2);
}

method sibble($/) {
    my $regex = self.op_for_regex($/, $<left>.ast);
    my $repl;
    if $<infixish> {
        if $<infixish> eq '=' {
            $repl = $<right>.ast;
        } elsif $<infixish>.ast ~~ ::Operator::CompoundAssign {
            $repl = $<infixish>.ast.base.with_args($/,
                mkcall($/, '&prefix:<~>', ::Op::ContextVar.new(name => '$*/')),
                $<right>.ast);
        } else {
            $/.CURSOR.sorry("Unhandled operator in substitution");
            $repl = mklex($/, 'Any');
        }
    } else {
        $repl = $<right>.ast;
    }
    $repl = self.block_expr($/, self.thunk_sub($repl));
    make ::Op::CallMethod.new(|node($/), receiver => mklex($/, '$_'),
        name => 'subst',
        args => [ $regex, $repl, self.extract_rx_adverbs(True, True, $/),
            ::Op::SimplePair.new(key => 'inplace', value => mklex($/,'True'))]);
}

method quotepair_term($/) {
    my $v;
    if $<v> ~~ Match {
        $v = $<v>.ast
    } elsif $<v> ~~ Str {
        $v = ::Op::Num.new(value => [10, $<v>]);
    } else {
        $v = mklex($/, $<v> ?? "True" !! "False");
    }
    ::Op::SimplePair.new(|node($/), key => $<k>, value => $v);
}

method extract_rx_adverbs($ismatch, $issubst, $match) {
    my $qps = ($match ~~ List) ?? $match !! $match<babble><quotepair>;
    return () if !$qps;

    my @ok;
    my @nyi;
    my @args;
    my @internal = < sigspace s ratchet r ignorecase i >;

    push @nyi, < ignoreaccent a bytes codes graphs chars Perl5 P5 >;

    if $issubst {
        push @nyi, < sameaccent aa samecase ii th st nd rd nth x >;
        push @ok,  < g global >;
    }

    if $ismatch {
        push @nyi, < overlap ov exhaustive ex continue c pos p global g rw >;
    }

    for @$qps -> $qp {
        if @internal.grep($qp<k>) {
            # handled by rx compiler
        } elsif @ok.grep($qp<k>) {
            push @args, self.quotepair_term($qp);
        } elsif @nyi.grep($qp<k>) {
            $qp.CURSOR.sorry("Regex modifier $qp<k> not yet implemented");
        } else {
            $qp.CURSOR.sorry("Regex modifier $qp<k> not valid on { $issubst ?? "substitution" !! $ismatch ?? "match" !! "regex literal" }");
        }
    }

    @args
}

method INFIX($/) {
    my $fn = $<infix>.ast;
    my ($st,$lhs,$rhs) = self.whatever_precheck($fn, $<left>.ast, $<right>.ast);

    make $fn.with_args($/, $lhs, $rhs);

    if $fn.assignish {
        # Assignments to has and state declarators are rewritten into
        # an appropriate phaser
        if $lhs.^isa(::Op::Lexical) && $lhs.state_decl {
            my $cv = self.gensym;
            make ::Op::StatementList.new(|node($/), children => [
                ::Op::Start.new(condvar => $cv, body => $/.ast),
                ::Op::Lexical.new(name => $lhs.name)]);
        }
        elsif $lhs.^isa(::Op::Attribute) && !defined($lhs.initializer.ivar) {
            my $init = self.thunk_sub($rhs,
                :name($lhs.initializer.name ~ " init"));
            $lhs.initializer.ivar = self.gensym;
            $*CURLEX<!sub>.add_my_sub_child($lhs.initializer.ivar, $init);
            $lhs.initializer.ibody = $init.xref;
            make $lhs;
        }
        elsif $lhs.^isa(::Op::ConstantDecl) && !$lhs.init {
            my $sig = substr($lhs.name, 0, 1);
            if defined '$@&%'.index($sig) {
                self.init_constant($lhs, self.docontext($/, $sig, $rhs));
            } else {
                self.init_constant($lhs, $rhs);
            }
            make $lhs;
        }
    }
    make self.whatever_postcheck($/, $st, $/.ast);
}

method block($/) {
    $*CURLEX<!sub>.code = $<blockoid>.ast;
    make $*CURLEX<!sub>
}
method embeddedblock($/) {
    my $sym = self.gensym;
    $*CURLEX<!sub>.code = $<statementlist>.ast;
    $*CURLEX<!sub>.outer.add_my_sub_child($sym, $*CURLEX<!sub>);
    $*CURLEX<!sub>.signature = Sig.simple();
    make ::Op::CallSub.new(|node($/),
        invocant => ::Op::SubDef.new(body => Any, symbol => $sym, :once),
        positionals => []);
}

# :: Body
method pblock($/) {
    #my $rw = $<lambda> && $<lambda> eq '<->'; TODO
    $*CURLEX<!sub>.code = $<blockoid>.ast;
    make $*CURLEX<!sub>;
}

# returns Body of 0 args
method blast($/) {
    if $<block> {
        make $<block>.ast;
    } else {
        make self.thunk_sub($<statement>.ast);
    }
}

method inliney_call($/, $block, *@parms) {
    my $sym = self.gensym;
    $*CURLEX<!sub>.add_my_sub_child($sym, $block);
    ::Op::CallSub.new(|node($/),
        invocant => ::Op::SubDef.new(body => Any, symbol => $sym, :once),
        positionals => @parms);
}

method if_block($/, $cond, $pb) {
    if defined $pb<lambda> {
        make self.inliney_call($/, $pb.ast, $cond);
    } else {
        make self.inliney_call($/, $pb.ast);
    }
}

method make_constant($/, $scope, $name, $path) {
    $scope := $scope || 'our';

    my $slot = ($scope eq 'my' || $scope eq 'our' && !$path) ?? $name !!
        self.gensym;

    if $scope eq 'our' {
        $*CURLEX<!sub>.add_common_name($slot,
            $*CURLEX<!sub>.find_pkg($path // ['OUR']), $name);
    } else {
        $*CURLEX<!sub>.add_hint($slot);
    }

    ::Op::ConstantDecl.new(|node($/), name => $slot, init => False);
}

method make_constant_into($/, $rpath, $name, $rhs) {
    my $slot = self.gensym;
    $*CURLEX<!sub>.add_common_name($slot, $rpath, $name);
    self.init_constant(::Op::ConstantDecl.new(|node($/), name => $slot,
        init => False), $rhs);
}

method init_constant($con, $rhs) {
    my $body = self.thunk_sub($rhs, name => "$con.name() init");
    $body.is_phaser = 2;
    $body.hint_hack = [ $*CURLEX<!sub>.xref, $con.name ];
    $body.outer.create_static_pad;
    $con.init = True;
    $con;
}

method type_declarator:constant ($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    my $name  = ~($<identifier> // $<variable> // self.gensym);

    make self.make_constant($/, $*SCOPE || 'our', $name, Array);
}

method type_declarator:enum ($/) {
    my $scope = $*SCOPE;
    if $scope && $scope ne 'our' && $scope ne 'my' && $scope ne 'anon' {
        $/.CURSOR.sorry("Invalid enum scope $scope");
        $scope = 'anon';
    }

    my @exports;
    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } else {
            $/.CURSOR.sorry("Unsupported enum trait $t.keys()");
        }
    }

    my @pairs = self.trivial_eval($/, $<term>.ast);
    my $last = -1;
    my ($has_ints, $has_strs);
    for @pairs {
        if $_ !~~ Pair {
            my $key = $_;
            my $value = $last.succ;
            $_ = $key => $value;
        }
        given $last = .value {
            when Int { $has_ints = True; }
            when Str { $has_strs = True; }
            default  { $/.CURSOR.sorry("Enum values must be Int or Str"); }
        }
    }
    if $has_ints && $has_strs {
        $/.CURSOR.sorry("Enum may not contain both Int and Str values");
    }

    my $basetype = $*OFTYPE ?? self.simple_longname($*OFTYPE<longname>) !!
        [ 'MY', $has_strs ?? 'Str' !! 'Int' ];

    if $<name> && $<name>.reduced eq 'longname'&& ($scope ||= 'our') ne 'anon' {
        # Longnamed enum is a kind of type definition

        my $ourpath = Array;
        my $lexvar = self.gensym;
        my $bindlex = False;
        my $r = self.mangle_longname($<longname>[0], True);
        my $name = $r<name>;
        if ($r<path>:exists) && $scope ne 'our' {
            $/.CURSOR.sorry("Enum name $<longname> requires our scope");
            $scope = 'our';
        }

        if $scope eq 'our' {
            $ourpath = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            if !($r<path>:exists) {
                $lexvar  = $name;
                $bindlex = True;
            }
        } elsif $scope eq 'my' {
            $lexvar  = $name;
            $bindlex = True;
        }

        my @ns = $ourpath ?? (@( $*CURLEX<!sub>.find_pkg($ourpath) ), $name) !!
            $*unit.anon_stash;
        $*unit.create_stash([@ns]);
        $*CURLEX<!sub>.add_my_stash($lexvar, [@ns]);
        my $obj  = ::Metamodel::Class.new(:$name);
        $obj.exports = [ [@ns] ];
        $*unit.bind_item([@ns], $obj.xref);

        $obj.add_super($*unit.get_item($*CURLEX<!sub>.find_pkg(
            ['MY', ($has_strs ?? 'Str' !! 'Int') ~ "BasedEnum"])));
        $obj.add_super($*unit.get_item($*CURLEX<!sub>.find_pkg($basetype)));

        my $nb = ::Metamodel::StaticSub.new(
            transparent=> True,
            unit       => $*unit,
            outerx     => $*CURLEX<!sub>.xref,
            name       => $name,
            cur_pkg    => $*CURLEX<!sub>.cur_pkg,
            class      => 'Method',
            signature  => Sig.simple('self'),
            code       => self.init_constant(
                self.make_constant($/, 'anon', Any, Any),
                ::Op::CallMethod.new(name => 'new',
                    receiver => mklex($/, 'EnumMap'), args => [$<term>.ast])));

        $nb.add_my_name('self', noinit => True);
        $*CURLEX<!sub>.create_static_pad;
        $nb.strong_used = True;
        $*CURLEX<!sub>.add_my_sub($lexvar ~ '!enums', $nb);
        $obj.add_method('only', 'normal', 'enums', $lexvar ~ '!enums', $nb.xref);
        $obj.close;

        for @pairs {
            self.make_constant_into($/, @ns, .key, rhs =>
                ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                    args => [ ::Op::StringLiteral.new(text => .key) ]));
        }

        for @pairs {
            self.init_constant(self.make_constant($/, $scope, .key, $r<path>),
                ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                    args => [ ::Op::StringLiteral.new(text => .key) ]));
        }

        make mklex($/, $lexvar);
    } else {
        make self.init_constant(
            self.make_constant($/, $scope, $<name> && ~$<name>, Any),
            ::Op::CallMethod.new(|node($/), name => 'new',
                receiver => mklex($/, 'EnumMap'),
                args => [$<term>.ast])),
    }
}

method circumfix:sym<{ }> ($/) {
    my $var = self.gensym;
    $*CURLEX<!sub>.add_my_sub_child($var, $<pblock>.ast);
    make ::Op::BareBlock.new(|node($/), :$var, :body(Any));

    if self.check_hash($/) {
        make mkcall($/, '&_hash_constructor',
            ::Op::CallSub.new(|node($/),
                invocant => ::Op::SubDef.new(body=>Any, symbol=>$var, :once)))
    }
}

method statement_prefix:do ($/) {
    make self.inliney_call($/, $<blast>.ast);
}
method statement_prefix:gather ($/) {
    $<blast>.ast.gather_hack = True;
    make ::Op::Gather.new(|node($/), body => Any, var =>
        self.block_expr($/, $<blast>.ast).name);
}
method statement_prefix:try ($/) {
    make ::Op::Try.new(|node($/), body => self.inliney_call($/, $<blast>.ast));
}

method statement_prefix:START ($/) {
    my $cv = self.gensym;
    $*CURLEX<!sub>.add_state_name(Str, $cv);
    make ::Op::Start.new(|node($/), condvar => $cv, body =>
        self.inliney_call($/, $<blast>.ast));
}

# TODO: retain and return a value
method statement_prefix:INIT ($/) {
    $<blast>.ast.is_phaser = 0;
    $*CURLEX<!sub>.create_static_pad;
    make ::Op::StatementList.new;
}
# XXX 'As soon as possible' isn't quite soon enough here
method statement_prefix:BEGIN ($/) {
    $<blast>.ast.is_phaser = 2;
    $*CURLEX<!sub>.create_static_pad;
    make ::Op::StatementList.new;
}
method statement_prefix:CHECK ($/) {
    $<blast>.ast.is_phaser = 2;
    $*CURLEX<!sub>.create_static_pad;
    make ::Op::StatementList.new;
}

method statement_prefix:END ($/) {
    $<blast>.ast.is_phaser = 1;
    $*CURLEX<!sub>.create_static_pad;
    make ::Op::StatementList.new;
}


method statement_control:loop ($/) {
    my $body = self.inliney_call($/, $<block>.ast);
    # XXX wrong interpretation
    my $init = $0 && $0[0]<e1>[0] ?? $0[0]<e1>[0].ast !! Any;
    my $cond = $0 && $0[0]<e2>[0] ?? $0[0]<e2>[0].ast !! Any;
    my $step = $0 && $0[0]<e3>[0] ?? $0[0]<e3>[0].ast !! Any;

    make ::Op::GeneralLoop.new(|node($/), :$body, :$init, :$cond, :$step);
}

method INFIX($/) {
    my $fn = $<infix>.ast;
    my ($st,$lhs,$rhs) = self.whatever_precheck($fn, $<left>.ast, $<right>.ast);

    make $fn.with_args($/, $lhs, $rhs);

    if $fn.assignish {
        # Assignments to has and state declarators are rewritten into
        # an appropriate phaser
        if $lhs.^isa(::Op::Lexical) && $lhs.state_decl {
            my $cv = self.gensym;
            $*CURLEX<!sub>.add_state_name($cv);
            make ::Op::StatementList.new(|node($/), children => [
                ::Op::Start.new(condvar => $cv, body => $/.ast),
                ::Op::Lexical.new(name => $lhs.name)]);
        }
        elsif $lhs.^isa(::Op::Attribute) && !$lhs.initializer {
            $lhs.initializer = self.sl_to_block('bare', $rhs,
                subname => $lhs.name ~ " init");
            make $lhs;
        }
        elsif $lhs.^isa(::Op::ConstantDecl) && !$lhs.init {
            my $sig = substr($lhs.name, 0, 1);
            if defined '$@&%'.index($sig) {
                $lhs.init = self.docontext($/, $sig, $rhs)
            } else {
                $lhs.init = $rhs;
            }
            make $lhs;
        }
    }
    make self.whatever_postcheck($/, $st, $/.ast);
}


method block_expr($/, $pb) {
    my $name = self.gensym;
    $*CURLEX<!sub>.add_my_sub_child($name, $pb);
    mklex($/, $name);
}

method term:lambda ($/) {
    make self.block_expr($/, $<pblock>.ast);
}

method statement_control:for ($/) {
    make ::Op::ForLoop.new(|node($/), source => $<xblock>.ast[0],
        sink => ::Op::SubDef.new(:once, symbol =>
            self.block_expr($/, $<xblock>.ast[1]).name));
}

method statement_control:given ($/) {
    make self.inliney_call($/, $<xblock>.ast[1], $<xblock>.ast[0]);
}

method statement_control:default ($/) {
    make ::Op::When.new(|node($/), match => mklex($/, 'True'),
        body => self.inliney_call($/, $<block>.ast));
}

method statement_control:when ($/) {
    make ::Op::When.new(|node($/), match => $<xblock>.ast[0],
        body => self.inliney_call($/, $<xblock>.ast[1]));
}

method check_hash($/) {
    my $do = $<pblock>.ast.code;

    return False unless $do.^isa(::Op::StatementList);
    return True if $do.children == 0;
    return False if $do.children > 1;

    $do = $do.children[0];
    my @bits = $do.^isa(::Op::SimpleParcel) ?? @( $do.items ) !! $do;

    return True if @bits[0].^isa(::Op::SimplePair);

    if @bits[0].^isa(::Op::CallSub) &&
            @bits[0].invocant.^isa(::Op::Lexical) &&
            @bits[0].invocant.name eq '&infix:<=>>' {
        return True;
    }

    if @bits[0].^isa(::Op::Lexical) && substr(@bits[0].name,0,1) eq '%' {
        return True;
    }

    return False;
}

method blockoid($/) {
    # XXX horrible cheat, but my data structures aren't up to the task of
    # $::UNIT being a class body &c.
    if $/ eq '{YOU_ARE_HERE}' {
        $*unit.bottom_ref = $*CURLEX<!sub>.xref;
        $*CURLEX<!sub>.strong_used = True;
        $*CURLEX<!sub>.create_static_pad;
        make ::Op::YouAreHere.new(|node($/), unitname => $*UNITNAME);
    } else {
        make $<statementlist>.ast;
    }
}

method param_var($/) {
    if $<signature> {
        $/.CURSOR.sorry('Sub-signatures NYI');
        make { };
        return Nil;
    }
    my $twigil = $<twigil> ?? ~$<twigil>[0] !! '';
    my $sigil =  ~$<sigil>;
    my $list = $sigil eq '@';
    my $hash = $sigil eq '%';
    my $name =   $<name> ?? ~$<name>[0] !! Any;
    $twigil = '*' if $name && ($name eq '/' || $name eq '!');

    my $slot;
    if $twigil eq '' {
        $slot = defined($name) ?? ($sigil ~ $name) !! Any;
    } elsif $twigil eq '*' {
        $slot = "$sigil*" ~ "$name";
    } else {
        $/.CURSOR.sorry("Unhandled parameter twigil $twigil");
        make { };
        return Nil;
    }

    if ($sigil ne '$' && $sigil ne '@' && $sigil ne '%' && $sigil ne '&') {
        $/.CURSOR.sorry('Non bare scalar targets NYI');
        make { }
        return Nil;
    }

    $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash, :noinit)
        if defined($slot);

    make { :$list, :$hash, :$slot,
        names => defined($name) ?? [ $name ] !! [] }
}

my %_nowhatever = (map { ($_ => True) }, ('&infix:<,>', '&infix:<..>',
    '&infix:<...>', '&infix:<=>', '&infix:<xx>'));
method whatever_precheck($op, *@args) {
    return ([], @args) if ($op.^isa(Operator) ?? !$op.whatever_curry !! %_nowhatever{$op});
    my @vars;
    my @args_ = @args;
    for @args_ -> $a is rw {
        die "invalid undef here" if !$a;
        if $a.^isa(::Op::Whatever) {
            push @vars, $a.slot;
            $a = ::Op::Lexical.new(name => $a.slot);
        } elsif $a.^isa(::Op::WhateverCode) {
            push @vars, @( $a.vars );
            $a = ::Op::CallSub.new(
                invocant => ::Op::Lexical.new(name => $a.slot),
                args => [ map { ::Op::Lexical.new(name => $_) }, @($a.vars) ]);
        }
    }
    $( @vars ), @args_;
}

method whatever_postcheck($/, $st, $term) {
    if @$st {
        my $slot = self.gensym;

        my $body = ::Metamodel::StaticSub.new(
            outerx => $*CURLEX<!sub>.xref,
            class => 'WhateverCode',
            unit => $*unit,
            transparent => True,
            code => $term,
            in_class => $*CURLEX<!sub>.in_class,
            cur_pkg => $*CURLEX<!sub>.cur_pkg);

        $body.signature = ::GLOBAL::Sig.new(params => [
            map { ::Sig::Parameter.new(slot => $_, name => $_) }, @$st ]);
        $body.add_my_name($_, :noinit) for @$st;

        $*CURLEX<!sub>.add_my_sub($slot, $body);

        ::Op::WhateverCode.new(ops => Any, vars => $st, :$slot, |node($/));
    } else {
        $term;
    }
}

}

augment class Op::ForLoop { #OK
    method statement_level() {
        my $body = $*CURLEX<!sub>.find_lex($!sink.symbol).body;
        my $var = [ map { ::GLOBAL::NieczaActions.gensym },
            0 ..^ +$body.signature.params ];
        $!sink.once = True;
        ::Op::ImmedForLoop.new(source => $!source, var => $var,
            sink => ::Op::CallSub.new(invocant => $!sink,
                positionals => [ map { ::Op::LetVar.new(name => $_) }, @$var]));
    }
}

class Op::MakeJunction is Op {
    has Int $.typecode = die "MakeJunction.typecode required";
    has @.zyg;

    method code($body) {
        CgOp.makejunction($!typecode, map *.cgop($body), @!zyg)
    }
}

CgOp._register_ops: < makejunction
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $stages;
if $bcnd eq 'clisp' {
    $stages = [
        NieczaPassSimplifier.new,
    ];
} elsif $bcnd eq 'hoopl' {
    $stages = [
        NieczaPassSimplifier.new,
    ];
} else {
    $stages = [
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ];
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => $stages,
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
}
