use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use JSYNC;
use Metamodel;
use NAMOutput;
use NieczaActions;
use NieczaBackendClisp;
use NieczaBackendDotnet;
use NieczaBackendHoopl;
use NieczaBackendNAM;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

augment grammar STD {
my package DEBUG { our constant symtab = 1 }

method lookup_lex($name, $lex is copy = $*CURLEX) {
    my $deb = $*DEBUG +& DEBUG::symtab;
    self.deb("Lookup $name") if $deb;
    my $sub = $lex.^isa(Hash) ?? $lex<!sub> !! $lex;
    my $sub2 = $sub;
    loop {
        if $sub.lexicals{$name}:exists {
            until $sub2 === $sub || $sub2.lexicals-used{$name} {
                $sub2.lexicals-used{$name} //=
                    ($*FILE<name> => self.lineof(self.pos));
                $sub2 = $sub2.outer;
            }
            $sub2.lexicals-used{$name} //=
                ($*FILE<name> => self.lineof(self.pos)) if $sub2 === $sub;

            self.deb("Found in $sub.name()") if $deb;
            return $sub.lexicals{$name};
        }
        $sub = $sub.outer || last;
    }
    self.deb("Not found") if $deb;
    return Any;
}

method is_name($longname, $curlex = $*CURLEX) {
    my $deb = $*DEBUG +& DEBUG::symtab;
    self.deb("is_name $longname") if $deb;
    if defined($longname.index("::(")) {
        self.deb("computed name gets a free pass") if $deb;
        return True;
    }
    my @parts = $longname.split('::');
    shift @parts if @parts[0] eq '';
    pop @parts if @parts && @parts[*-1] eq ''; # doesn't change ref validity

    @parts[*-1] = $/ ~ @parts[*-1] if @parts && @parts[0] ~~ s/^(\W\W?)//;

    self.deb("reparsed: @parts.perl()") if $deb;
    return True if !@parts;

    my ($pkg, $sub);

    given @parts[0] {
        when 'OUR' {
            $pkg = $*unit.deref($curlex<!sub>.cur_pkg);
            shift @parts;
            goto "packagey";
        }
        when 'PROCESS' | 'GLOBAL' {
            $pkg = $*unit.abs_pkg(shift @parts);
            goto "packagey";
        }
        when 'MY'      { $sub = $curlex<!sub>;                 goto "lexy"; }
        when 'OUTER'   { $sub = $curlex<!sub>.?outer;          goto "lexy"; }
        when 'UNIT'    { $sub = $curlex<!sub>.?to_unit;        goto "lexy"; }
        when 'CORE'    { $sub = $curlex<!sub>.?true_setting;   goto "lexy"; }
        when 'SETTING' { $sub = $curlex<!sub>.?to_unit.?outer; goto "lexy"; }

        when 'COMPILING' | 'DYNAMIC' | 'CALLER' { return True }

        default {
            my $lexical = self.lookup_lex(@parts[0], $curlex);
            if !defined($lexical) || @parts[0] eq 'PARENT' {
                return False if @parts == 1; # $x doesn't mean GLOBAL
                $pkg = (@parts[0] ~~ /^\W/) ??
                    $*unit.deref($curlex<!sub>.cur_pkg) !!
                    $*unit.abs_pkg('GLOBAL');
            } elsif $lexical ~~ ::Metamodel::Lexical::Stash {
                $pkg = $*unit.deref($lexical.pkg);
                shift @parts;
            } else {
                return @parts == 1;
            }
            goto "packagey";
        }
    }

lexy:
    shift @parts;
    return False unless $sub;
    return True unless @parts;
    given @parts[0] {
        when 'OUTER'   { $sub = $sub.?outer;          goto "lexy"; }
        when 'UNIT'    { $sub = $sub.?to_unit;        goto "lexy"; }
        when 'SETTING' { $sub = $sub.?to_unit.?outer; goto "lexy"; }
        when 'CALLER'  { return True; }
    }

    my $lexical = self.lookup_lex(@parts[0], $sub);
    unless defined $lexical {
        self.deb("Lexical @parts[0] not found") if $deb;
        return False;
    }
    if $lexical ~~ ::Metamodel::Lexical::Stash {
        shift @parts;
        $pkg = $*unit.deref($lexical.pkg);
        goto "packagey";
    }
    else {
        return @parts == 1;
    }

packagey:
    for @parts {
        return False if !$pkg || !$*unit.ns.exists($pkg.who, $_);
        $pkg = $*unit.ns.get($pkg.who, $_);
        $pkg = $pkg && $*unit.deref($pkg);
    }

    return True;
}
}

class Op::Temporize is Op {
    has Op $.var;
    has Int $.mode;
    method zyg() { $!var }
    method code($body) { CgOp.temporize($!var.code($body), CgOp.callframe,
        CgOp.int($!mode)) }
}

class Op::IndirectVar is Op {
    has Op $.name;
    has Bool $.bind_ro;
    has Op $.bind;
    method zyg() { $!name }

    method code($body) {
        CgOp.sc_indir(CgOp.sc_root(), CgOp.obj_getstr($!name.cgop($body)),
            CgOp.bool($!bind_ro ?? 1 !! 0),
            $!bind ?? $!bind.cgop($body) !! CgOp.null('var'))
    }

    method to_bind($/, $ro, $rhs) { self.new(name => $!name, bind_ro => $ro,
        bind => $rhs) }
}

augment class Metamodel {
enum Phaser < INIT END UNIT_INIT KEEP UNDO LEAVE ENTER PRE POST CATCH CONTROL >;
}

class Operator::Let is Operator {
    method with_args($/, *@args) {
        $*CURLEX<!sub>.noninlinable;
        return ::Op::Temporize.new(|node($/), mode => 1, var => @args[0]);
    }
}

augment class Operator::Temp {
    method with_args($/, *@args) {
        my $rarg = @args[0];
        if !$rarg.^isa(::Op::ContextVar) || $rarg.uplevel {
            $*CURLEX<!sub>.noninlinable;
            return ::Op::Temporize.new(|node($/), mode => 0, var => $rarg);
        }
        my $hash = substr($rarg.name,0,1) eq '%';
        my $list = substr($rarg.name,0,1) eq '@';
        $*CURLEX<!sub>.add_my_name($rarg.name, :$hash, :$list);
        mkcall($/, '&infix:<=>',
            ::Op::Lexical.new(name => $rarg.name, :$hash, :$list),
            ::Op::ContextVar.new(name => $rarg.name, uplevel => 1));
    }
}

class Op::CatchyWrapper is Op {
    has $.inner;
    method zyg() { $!inner }

    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.xspan("start$id", "end$id", 0, CgOp.prog(
                CgOp.sink($!inner.cgop($body)),
                CgOp.return(CgOp.scopedlex('False')),
                CgOp.label("caught$id"),
                CgOp.scopedlex('True')),
            6, '', "caught$id");
    }
}

augment class NieczaActions {
method quote:m  ($/) {
    make ::Op::CallMethod.new(|node($/), name => 'match',
            receiver => mklex($/, '$_'),
            args => [
                self.op_for_regex($/, $<quibble>.ast),
                self.extract_rx_adverbs(True, False, $<quibble>) ]);
}
method extract_rx_adverbs($ismatch, $issubst, $match) {
    my $qps = ($match ~~ List) ?? $match !! $match<babble><quotepair>;
    return () if !$qps;

    my @ok;
    my @nyi;
    my @args;
    my @internal = < sigspace s ratchet r ignorecase i >;

    push @nyi, < ignoreaccent a bytes codes graphs chars Perl5 P5 >;

    if $issubst {
        push @nyi, < sameaccent aa samecase ii >;
        push @ok,  < g global p pos c continue x nth st nd rd th >;
    }

    if $ismatch {
        push @nyi, < overlap ov exhaustive ex global g rw >;
        push @ok, < continue c pos p nth st nd rd th >;
    }

    for @$qps -> $qp {
        if @internal.grep($qp<k>) {
            # handled by rx compiler
        } elsif @ok.grep($qp<k>) {
            push @args, self.quotepair_term($qp);
        } elsif @nyi.grep($qp<k>) {
            $qp.CURSOR.sorry("Regex modifier $qp<k> not yet implemented");
        } else {
            $qp.CURSOR.sorry("Regex modifier $qp<k> not valid on { $issubst ?? "substitution" !! $ismatch ?? "match" !! "regex literal" }");
        }
    }

    @args
}
method statement_control:TEMP ($/) {
    $*CURLEX<!sub>.noninlinable;
    make ::Op::Temporize.new(|node($/), mode => 2,
        var => self.inliney_call($/, $<block>.ast));
}
method prefix:let ($/) { make ::Operator::Let.new }

sub phaser($/, $ph, :$unique, :$topic, :$csp) {
    my $sub = ($<blast> // $<block>).ast;

    if $unique {
        $/.CURSOR.sorry("Limit one $ph phaser per block, please.")
            if any($sub.outer.children).is_phaser == ::Metamodel::Phaser.($ph);
        $sub.code = ::Op::CatchyWrapper.new(inner => $sub.code);
    }

    $sub.outer.noninlinable;
    $sub.is_phaser = +::Metamodel::Phaser.($ph);

    if $topic {
        $sub.lexicals.<$_> // $sub.add_my_name('$_');
        $sub.lexicals.<$_>.noinit   = True;
        $sub.lexicals.<$_>.defouter = False;
        $sub.signature = Sig.simple('$_');
    }
    $*CURLEX<!sub>.create_static_pad if $csp;
    make ::Op::StatementList.new;
}
method statement_control:CATCH ($/) { phaser($/, 'CATCH', :unique, :topic) }
method statement_control:CONTROL ($/) { phaser($/, 'CONTROL', :unique, :topic) }
method statement_prefix:PRE ($/) { phaser($/, 'PRE') }
method statement_prefix:POST ($/) { phaser($/, 'POST', :topic) }
method statement_prefix:KEEP ($/) { phaser($/, 'KEEP', :topic) }
method statement_prefix:UNDO ($/) { phaser($/, 'UNDO', :topic) }
method statement_prefix:ENTER ($/) { phaser($/, 'ENTER') }
method statement_prefix:LEAVE ($/) { phaser($/, 'LEAVE', :topic) }

method statement_prefix:CHECK ($/) { phaser($/, 'CHECK', :csp) }
method statement_prefix:END ($/) { phaser($/, 'END', :csp) }
method statement_prefix:INIT ($/) { phaser($/, 'INIT', :csp) }

method init_constant($con, $rhs) {
    my $body = self.thunk_sub($rhs, name => "$con.name() init");
    $body.is_phaser = +::Metamodel::Phaser::UNIT_INIT;
    $body.hint_hack = [ $*CURLEX<!sub>.xref, $con.name ];
    $body.outer.create_static_pad;
    $con.init = True;
    $con;
}

method statement_prefix:BEGIN ($/) {
    $<blast>.ast.is_phaser = +::Metamodel::Phaser::UNIT_INIT;
    $*CURLEX<!sub>.create_static_pad;
    make ::Op::StatementList.new;

    # MAJOR HACK - allows test code like BEGIN { @*INC.push: ... } to work
    repeat while False {
        my $c = $<blast>.ast.code;

        last unless $c ~~ Op::StatementList;
        last unless $c.children == 1;
        my $d = $c.children.[0];
        last unless $d ~~ Op::CallMethod;
        last unless $d.receiver ~~ Op::ContextVar;
        last unless $d.receiver.name eq '@*INC';
        last if $d.private || $d.ismeta;
        last unless $d.name eq any <push unshift>;
        last unless +$d.getargs == 1;
        last unless defined my $str = self.trivial_eval($/, $d.getargs.[0]);
        @*INC."$d.name()"($str);
    }
}

method package_def ($/) {
    my $sub = $*CURLEX<!sub>;

    my $bodyvar = self.gensym;
    $sub.outer.add_my_sub($bodyvar, $sub);
    $sub.code = ($<blockoid> // $<statementlist>).ast;

    if $sub.augmenting {
        my $ah = $sub.augment_hack;
        $sub.augment_hack = Any;

        my $ph = ::Metamodel::StaticSub.new(
            unit       => $*unit,
            outerx     => $sub.xref,
            outer_direct => $*CURLEX<!sub>,
            cur_pkg    => $sub.cur_pkg,
            name       => 'ANON',
            is_phaser  => +::Metamodel::Phaser::INIT,
            augment_hack => $ah,
            class      => 'Code',
            code       => ::Op::StatementList.new(children => []),
            run_once   => $sub.run_once);
        $sub.create_static_pad;
        $sub.add_child($ph);

        make ::Op::CallSub.new(|node($/), invocant => mklex($/, $bodyvar));
    }
    else {
        my $obj = $*unit.deref($sub.body_of);

        if $<stub> {
            push $*unit.stubbed_stashes, ($obj => $/.CURSOR);

            make mklex($/, $*CURLEX<!sub>.outervar);
        }
        else {
            $/.CURSOR.trymop({ $obj.close; });

            if $obj ~~ ::Metamodel::ParametricRole {
                $sub.parametric_role_hack = $obj.xref;
                $sub.add_my_name('*params', :noinit);
                $sub.create_static_pad;

                make mklex($/, $*CURLEX<!sub>.outervar);
            } else {
                make ::Op::StatementList.new(|node($/), children => [
                    ::Op::CallSub.new(invocant => mklex($/, $bodyvar)),
                    ::Op::Lexical.new(name => $*CURLEX<!sub>.outervar) ]);
            }
        }
    }
}

method circumfix:sym<( )> ($/) {
    my @kids = @( $<semilist>.ast );
    if @kids == 1 && @kids[0].^isa(::Op::WhateverCode) {
        # XXX in cases like * > (2 + *), we *don't* want the parens to disable
        # syntactic specialization, since they're required for grouping
        make @kids[0];
    } elsif !@kids {
        # an empty StatementList returns Nil, but () needs to be defined...
        make ::Op::Paren.new(|node($/), inside =>
            ::Op::SimpleParcel.new(items => []));
    } else {
        make ::Op::StatementList.new(|node($/), children => @kids);
    }
}

method process_name($/, :$declaring, :$defer, :$clean) {
    return () unless defined $/;

    my @ns = @( $<name>.ast<names> );
    my $ext = '';
    my $trail = @ns && !defined @ns[*-1];
    pop @ns if $trail;

    if !$clean {
        for @( $<colonpair> ) {
            $ext ~= $_.ast<ext> // (
                $_.CURSOR.sorry("Invalid colonpair for name extension");
                "";
            )
        }
    }

    for $defer ?? () !! @ns.grep(Op) {
        $_ = ~self.trivial_eval($/, $_);
        # XXX should this always stringify?
        if $_ ~~ Cool {
            $_ = ~$_;
        } else {
            $_ = "XXX";
            $/.CURSOR.sorry("Name components must evaluate to strings");
        }
    }

    if $declaring {
        # class :: is ... { } is a placeholder for a lack of name
        return () if $trail && !@ns;
        $/.CURSOR.sorry("Illegal explicit declaration of a symbol table")
            if $trail;
        die "Unimplemented" if $defer;
        return () unless @ns;
        my $head = pop(@ns) ~ $ext;
        return Any, $head unless @ns;

        # the remainder is assumed to name an existing or new package
        my $pkg;
        $/.CURSOR.trymop({
            $pkg = $*CURLEX<!sub>.compile_get_pkg(@ns, :auto);
        });
        return $pkg, $head;
    }
    else {
        if $defer {
            # The stuff returned here is processed by the variable rule,
            # and also by method call generation

            goto "dyn" if $trail;
            goto "dyn" if $_.^isa(Op) for @ns;
            my $pkg;
            my @tail = @ns;
            my $head = pop(@tail) ~ $ext;
            unless @tail {
                goto "dyn" if $head eq any < MY OUR CORE DYNAMIC GLOBAL CALLER OUTER UNIT SETTING PROCESS COMPILING PARENT >;
                return { name => $head } unless @tail;
            }
            try { $pkg = $*CURLEX<!sub>.compile_get_pkg(@tail, :auto) };
            goto "dyn" unless $pkg;

            return { name => $head, pkg => $pkg };
dyn:
            my @bits = map { $_, '::' }, @ns;
            pop @bits if @bits;
            push @bits, '::' if $trail;
            return { iname => mkstringycat($/, @bits) };
        }

        $/.CURSOR.sorry("Class required, but symbol table name used instead")
            if $trail;
        return () unless @ns;
        my $head = pop(@ns) ~ $ext;
        my $pkg;
        $/.CURSOR.trymop({
            $pkg = $*CURLEX<!sub>.compile_get_pkg(@ns, $head);
        });
        return $pkg;
    }
}

method term:identifier ($/) {
    my $id  = $<identifier>.ast;
    my $sal = $<args> ?? ($<args>.ast // []) !! [];
    # TODO: support zero-D slicels

    if $sal > 1 {
        $/.CURSOR.sorry("Slicel lists are NYI");
        make ::Op::StatementList.new;
        return;
    }

    if $id eq any < MY OUR CORE DYNAMIC GLOBAL CALLER OUTER UNIT SETTING PROCESS COMPILING PARENT > {
        make Op::IndirectVar.new(|node($/),
            name => Op::StringLiteral.new(text => $id));
        return;
    }
    my $is_name = $/.CURSOR.is_name(~$<identifier>);

    if $is_name && $<args>.chars == 0 {
        make mklex($/, $id);
        return;
    }

    my $args = $sal[0] // [];

    make ::Op::CallSub.new(|node($/),
        invocant => mklex($/, $is_name ?? $id !! '&' ~ $id),
        args => $args);
}

method term:name ($/) {
    my ($name) = self.process_name($<longname>, :defer);

    if $<args> {
        $name<name>  = '&' ~ $name<name> if $name<name>;
        $name<iname> = mkstringycat($/, '&', $name<iname>) if $name<iname>;
    }

    if $name<iname> {
        make ::Op::IndirectVar.new(|node($/), name => $name<iname>);
    }
    elsif $name<pkg> {
        make self.package_var($/, self.gensym, $name<name>, $name<pkg>);
    } else {
        make mklex($/, $name<name>);
    }

    my @pc = @( $<postcircumfix> );
    if @pc && @pc[0].substr(0,1) eq '[' {
        make mkcall($/, '&_param_role_inst', $/.ast, @( @pc[0].ast.args ));
        shift @pc;
    } elsif $<args> {
        my $sal = $<args>.ast // [];
        # TODO: support zero-D slicels

        if $sal > 1 {
            $/.CURSOR.sorry("Slicel lists are NYI");
            return;
        }

        make ::Op::CallSub.new(|node($/), invocant => $/.ast,
            args => $sal[0] // []);
    }

    if @pc {
        make @pc[0].ast.with_args($/, $/.ast);
    }
}


method variable_declarator($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }

    my $scope = $*SCOPE // 'my';

    my $start;
    for @$<trait> -> $t {
        if $t.ast<rw> {
        } elsif $t.ast<dynamic> {
        } elsif $t.ast<start> && $*SCOPE eq 'state' {
            $start = $t.ast<start>;
        } else {
            $/.CURSOR.sorry("Trait $t.ast.keys.[0] not available on variables");
        }
    }
    if $<post_constraint> || $<postcircumfix> || $<semilist> {
        $/.CURSOR.sorry("Postconstraints, and shapes on variable declarators NYI");
    }

    if $scope eq 'augment' || $scope eq 'supersede' {
        $/.CURSOR.sorry("Illogical scope $scope for simple variable");
    }

    my $typeconstraint;
    if $*OFTYPE {
        ($typeconstraint) = self.process_name($*OFTYPE<longname>);
        $typeconstraint &&= $typeconstraint.xref;
        $/.CURSOR.sorry("Common variables are not unique definitions and may not have types") if $scope eq 'our';
    }

    my $v = $<variable>.ast;
    my $t = $v<twigil>;
    my $list = $v<sigil> eq '@';
    my $hash = $v<sigil> eq '%';
    if ($t && defined "?=~^:".index($t)) {
        $/.CURSOR.sorry("Variables with the $t twigil cannot be declared " ~
            "using $scope; they are created " ~
            ($t eq '?' ?? "using 'constant'." !!
             $t eq '=' ?? "by parsing POD blocks." !!
             $t eq '~' ?? "by 'slang' definitions." !!
             "automatically as parameters to the current block."));
    }

    if $scope ne 'has' && ($t eq '.' || $t eq '!') {
        $/.CURSOR.sorry("Twigil $t is only valid on attribute definitions ('has').");
    }

    if !defined($v<name>) && $scope ne any < my anon state > {
        $/.CURSOR.sorry("Scope $scope requires a name");
    }

    if defined($v<pkg>) || defined($v<iname>) {
        $/.CURSOR.sorry(":: syntax is only valid when referencing variables, not when defining them.");
    }

    my $name = $v<sigil> ~ $v<twigil> ~ $v<name>;
    # otherwise identical to my
    my $slot = ($scope eq 'anon' || !defined($v<name>))
        ?? self.gensym !! $name;

    if $scope eq 'has' {
        make self.add_attribute($/, $v<name>, $v<sigil>, $t eq '.',
            $typeconstraint);
    } elsif $scope eq 'state' {
        $/.CURSOR.trymop({
            $/.CURSOR.check_categorical($slot);
            $*CURLEX<!sub>.add_state_name($slot, self.gensym, :$list,
                :$hash, :$typeconstraint, |mnode($/));
        });
        make Op::StateDecl.new(|node($/), inside =>
            Op::Lexical.new(|node($/), name => $slot, :$list, :$hash));
    } elsif $scope eq 'our' {
        make self.package_var($/, $slot, $slot, ['OUR']);
    } else {
        $/.CURSOR.trymop({
            $/.CURSOR.check_categorical($slot);
            $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash,
                :$typeconstraint, |mnode($/));
        });
        make ::Op::Lexical.new(|node($/), name => $slot, :$list, :$hash);
    }

    if $start {
        my $cv = self.gensym;
        $*CURLEX<!sub>.add_state_name(Str, $cv);
        make mklet($/.ast, -> $ll {
            Op::StatementList.new(|node($/), children => [
                Op::Start.new(condvar => $cv, body =>
                    self.inliney_call($/, $start, $ll)), $ll ]) });
    }
}

method variable($/) {
    my $sigil =  $<sigil>  ?? ~$<sigil> !! substr(~$/, 0, 1);
    my $twigil = $<twigil> ?? $<twigil>[0]<sym> !! '';

    my ($name, $pkg);
    my ($dsosl) = $<desigilname> ?? $<desigilname>.ast !!
        $<sublongname> ?? $<sublongname>.ast !!
        $<longname> ?? self.process_name($<longname>, :defer) !!
        Any;
    if defined($dsosl<ind>) {
        make { term => self.docontext($/, $sigil, $dsosl<ind>) };
        return;
    } elsif defined($dsosl<iname>) {
        make { term => ::Op::IndirectVar.new(|node($/),
            name => mkstringycat($/, $sigil ~ $twigil, $dsosl<iname>)) };
        return;
    } elsif defined $dsosl {
        ($name, $pkg) = $dsosl<name pkg>;
    } elsif $<infixish> {
        make { term => $<infixish>.ast.as_function($/) };
        return;
    } elsif $<special_variable> {
        $name = substr(~$<special_variable>, 1);
    } elsif $<index> {
        make { capid => $<index>.ast, term =>
            mkcall($/, '&postcircumfix:<[ ]>',
                ::Op::Lexical.new(name => '$/'),
                ::Op::Num.new(value => $<index>.ast))
        };
        return Nil;
    } elsif $<postcircumfix> {
        if $<postcircumfix>[0].reduced eq 'postcircumfix:sym<< >>' { #XXX fiddly
            make { capid => $<postcircumfix>[0].ast.args[0].text, term =>
                mkcall($/, '&postcircumfix:<{ }>',
                    ::Op::Lexical.new(name => '$/'),
                    @( $<postcircumfix>[0].ast.args))
            };
            return;
        } else {
            make { term => self.docontext($/, $sigil, $<postcircumfix>[0].ast.args[0]) };
            return;
        }
    } else {
        $name = '';
    }

    make {
        sigil => $sigil, twigil => $twigil, name => $name, pkg => $pkg
    };
}

}

CgOp._register_ops: < who sc_root sc_indir temporize
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => [ NieczaPassSimplifier.new ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
