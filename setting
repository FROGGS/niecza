# vim: ft=perl6

# We have to do this directly due to the circularity saw.  Same
# reason forces uncontainerized .NET values.
#
# Class metaobjects come in two flavors - protoclasses, which carry methods
# bound into protopads, and instantiated classes, which carry methods bound
# into real pads.  In standard fashion protoclasses are used as instantiated
# classes from BEGIN code.  Protoclasses are subject to closure and will
# (eventually) often have CLR classes generated for them.
#
# class ClassHOW {
#     # non-null for instantiated classes
#     has ClassHOW $.protoclass;
#     # these will be protopads in the protoclass; may be shorter than the
#     # protoclass' version in some augment cases
#     has Array[Frame] $.outers;
#
#     # 0-arg subs which get bound into scope 0 to fetch the parents
#     has Array[Sub] $.scoped-parents;
#     # the real found subs - set by .bind
#     has Array[ClassHOW] $.parents;
#
#     has Array[Sub] $.scoped-roles;
#     has Array[RoleHOW] $.roles;
#
#     has Dictionary[str,int] $.method-scopes;
#     has Dictionary[str,Sub] $.scoped-methods;
#     has Dictionary[str,Sub] $.methods;
#
#     has DynMetaObject $.metaobject;
#     has DynObject $.proto;
#
#     has DependentSet<ClassHOW> $.dependents;
#
#     # clears valid bit on metaobject of all dependents
#     method invalidate { ... }
#     # called automatically if valid bit clear???
#     method revalidate { ... }
# }
#
# Due to concerns of screwing up composition, adding new superclasses, roles,
# or attributes in an augment is not allowed at this time.  Methods only.
#
# to create a class:
#     BEGIN my ::Foo ::= ClassHOW.new("Foo").protoobject;
#     BEGIN {
#         Foo.^push-scope(callframe);
#         Foo.^add-super(...);
#         Foo.^add-role(...);
#         Foo.^add-scoped-method("bar", 0, sub { ... });
#         Foo.^compose;
#     }
#     ENTER ::Foo ::= Foo.^clone; ENTER Foo.^bind-outer(0, callframe);
#
# to augment:
#     BEGIN my $scopenum = Foo.^push-scope(callframe);
#     BEGIN { Foo.^add-scoped-method("baz", $scopenum, sub { ... }); }
#     Foo.^bind-outer($scopenum, callframe);
my class ClassHOW { ... }

PRE-INIT {
    sub wrap-metaclass { # $metaclass-mo, $mo
        Q:NIL {
            LEXICALS: mci, p: DynObject, mo: DynMetaObject

            new/0:DynObject L!mci
            =[1] @ unwrap:DynMetaObject L!mo
            new/0:DynObject L!p

            L@p L@mo !.klass

            L@mo L@mci !.how

            L@mci @.slots L@mo ![meta-object]
            L@mci @.slots L@p  ![prototype]

            L@mci  =[0] @ unwrap:DynMetaObject  !.klass

            L@p .plaincall/1:Kernel.NewROVar
        }
    }

    sub new-metaclass { Q:NIL {
        LEXICALS: mo: DynMetaObject
        new/0:DynMetaObject L!mo
        L@mo =[1] @ unwrap:String !.name
        L@^&wrap-metaclass @  =[0]
            L@mo new/1:CLRImportObject .plaincall/1:Kernel.NewROVar
            .tailcall/2
    } }

    sub new { Q:NIL {
        L@^&new-metaclass @
            =[0] @ cast:DynObject @.klass new/1:CLRImportObject
                .plaincall/1:Kernel.NewROVar
            =[1] .tailcall/2
    } }

    sub push-scope { Q:NIL {
        =[0] @ cast:DynObject @.slots @[meta-object] cast:DynMetaObject @.outers
          =[1] @ unwrap:Frame .virtcall/1:Add
        null:Variable
    } }

    sub add-scoped-method { Q:NIL {
        =[0] @ cast:DynObject @.slots @[meta-object] cast:DynMetaObject @.local
          =[1] @ unwrap:String
            =[3] @ cast:DynObject @.slots @[code] cast:DynBlockDelegate
              =[3] @ cast:DynObject @.slots @[proto] cast:Frame
                =[1] @ unwrap:Int32 new/3:DynMetaObject.Method
              ![]
        null:Variable
    } }

    Q:NIL {
        LEXICALS: $p: Variable
        L@&new-metaclass @  null:DynMetaObject new/1:CLRImportObject
            .plaincall/1:Kernel.NewROVar ="ClassHOW" .call/2 L!$p

        L@$p @ how cast:DynObject  L@$p @ cast:DynObject @.klass  !.klass

        L@$p L!^ClassHOW
        null:Variable
    }
}

sub infix:<~> { Q:NIL {
    =[0] @ unwrap:String  =[1] @ unwrap:String  .plaincall/2:String.Concat
        new/1:CLRImportObject .plaincall/1:Kernel.NewROVar
} }

sub say { Q:NIL {
    =[0] @ unwrap:String .plaincall/1:Console.WriteLine null:Variable
} }

say("Hello, " ~ "World");
