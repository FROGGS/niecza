# vim: ft=perl6
use MONKEY_TYPING;

use STD;
use Stash;
use NAME;
use JSYNC;

augment class List {
}

augment class Mu {
}

augment class Cool {
}

augment class Any {
}

augment class Stash {
    method iterator () { self.list.iterator }
}

augment class NAME {
}

augment class Regex {
}

augment class Match {
    method trim_heredoc () { self } # NYI
}

augment class Hash {
}

augment class STD {
}

augment class STD::P6 {
my %term            = (:dba('term')            , :prec<z=>);
my %methodcall      = (:dba('methodcall')      , :prec<y=>, :assoc<unary>, :uassoc<left>, :fiddly, :!pure);
    token dotty:sym<.*> {
        ('.' [ <[+*?=]> | '^' '!'? ]) :: <.unspacey> <dottyop>
        $<sym> = {$0.Str}
        <O(|%methodcall)>
    }

    token dotty:sym<.> {
        <sym> <.unspacey> <dottyop>
        <O(|%methodcall)>
    }

    token privop {
        '!' <methodop>
        <O(|%methodcall)>
    }
    token term:name
    {
        :my $name;
        :my $pos;
        <longname>
        {
            $name = $<longname>.Str;
            $pos = $¢.pos;
        }
        [
        ||  <?{
                $¢.is_name($name) or substr($name,0,2) eq '::'
            }>
            { $¢.check_nodecl($name); }

            # parametric type?
            :dba('type parameter')
            <.unsp>? [ <?before '['> <postcircumfix> ]?

            :dba('namespace variable lookup')
            [
                <?after '::'>
                <?before [ '«' | '<' | '{' | '<<' ] > <postcircumfix>
                { $*VAR = Match.synthetic(:cursor($¢), :from(self.pos), :to($¢.pos), :captures(), :method<Str>) }
            ]?

        # unrecognized names are assumed to be post-declared listops.
        || <args> { self.add_mystery($<longname>,$pos,'termish') unless $<args><invocant>; }
            {{
                if $*BORG and $*BORG.<block> {
                    if not $*BORG.<name> {
                        $*BORG.<culprit> = $<longname>.cursor($pos);
                        $*BORG.<name> = $*BORG<name> // $name;
                    }
                }
            }}
        ]
        <O(|%term)>
    }
}

augment class Cursor {
    our $RED    = "\e[31m";
    our $GREEN  = "\e[32m";
    our $YELLOW = "\e[33m";
    our $CLEAR  = "\e[37m";
}

sub compiler(:$filename, :$text, :$settingname) {
    my $*SETTINGNAME = $settingname;
    my @*MEMOS;
    my $*FILE = { name => $filename };
    my @*ACTIVE;
    my $*HIGHWATER = 0;
    my $*HIGHEXPECT = {};
    my $*HIGHMESS = "";
    my $*LASTSTATE = 0;
    my $*IN_PANIC = 0;
    my $*IN_SUPPOSE = 0;
    my $*FATALS = 0;

    $STD::DEBUG::EXPR = False;
    $STD::DEBUG::symtab = False;

    my $*LAST_NIBBLE = 0;
    my $*LAST_NIBBLE_START = 0;
    my $*LAST_NIBBLE_MULTILINE = 0;
    my $*LAST_NIBBLE_MULTILINE_START = 0;
    my $*GOAL = "(eof)";
    my $*SETTING; my $*CORE; my $*GLOBAL; my $*UNIT; my $*YOU_WERE_HERE;
    my $*CCSTATE; my $*BORG; my %*RX; my $*XACT; my $*VAR; my $*IN_REDUCE;
    STD.parse($text);

    my $all;

    # setting?
    if $*YOU_WERE_HERE {
        $all = $STD::ALL;
        $all<SETTING> = $*YOU_WERE_HERE;
        $all<CORE> = $*YOU_WERE_HERE if $*UNIT<$?LONGNAME> eq 'CORE';
    }
    else {
        $all = {};
        for keys %( $STD::ALL ) -> $key {
            next if $key ~~ /^MY\:file\<\w+\.setting\>/ or $key eq 'CORE' or $key eq 'SETTING';
            $all{$key} = $STD::ALL{$key};
        }
    }

    $all
}

if !@*ARGS {
    note "Usage: tryfile.exe [--symbols]? [--setting NAME]? [-e TEXT | FILENAME | -]";
    exit 1;
}

my $symbols = False;
my $setting = 'CORE';
if @*ARGS[0] eq '--symbols' {
    $symbols = True;
    shift @*ARGS;
}
if @*ARGS[0] eq '--setting' {
    shift @*ARGS;
    $setting = shift @*ARGS;
}

my $out;
if @*ARGS[0] eq '-' {
    $out = compiler(filename => '(eval)', text => $*IN.slurp, settingname => $setting);
} elsif @*ARGS[0] eq '-e' {
    $out = compiler(filename => '(eval)', text => @*ARGS[1], settingname => $setting);
} else {
    $out = compiler(filename => @*ARGS[0], text => slurp(@*ARGS[0]), settingname => $setting);
}

if $symbols {
    say to-jsync($out);
} else {
    say "OK"
}
