# vim: ft=perl6
use MONKEY_TYPING;

use STD;
use STDStash;

augment class List {
    method shift() { self!fill(1) ?? self!shift-item !! Any }
}

augment class STD {
    method panic($str) { die "$str at {self.pos}" }
}

augment class STD::P6 {
    token statement {
        :my $*endargs = -1;
        :my $*QSIGIL ::= 0;
        <!before <[\)\]\}]> >
        <!stopper>

        # this could either be a statement that follows a declaration
        # or a statement that is within the block of a code declaration
        :lang( %*LANG<MAIN> )
        <!!{ $*LASTSTATE = $¢.pos; True  }>

        <!before $ >

        [
        | <label> <statement>
        | <statement_control>
        | <EXPR>
            :dba('statement end')
            [
            || <?{ (@*MEMOS[$¢.pos]<endstmt> // 0) == 2 }>   # no mod after end-line curly
            ||
                :dba('statement modifier')
                <.ws>
                [
                | <statement_mod_loop>
                    {{
                        my $sp = $<EXPR><statement_prefix>;
                        if $sp and $sp<sym> eq 'do' {
                           my $s = $<statement_mod_loop>[0]<sym>;
                           $¢.obs("do...$s" ,"repeat...$s");
                        }
                    }}
                | <statement_mod_cond>
                    :dba('statement modifier loop')
                    [
                    || <?{ (@*MEMOS[$¢.pos]<endstmt> // 0) == 2 }>
                    || <.ws> <statement_mod_loop>?
                    ]
                ]?
            ]
        | <?before ';'>
        | <?before <stopper> >
        | {} <.panic: "Bogus statement">
        ]

        # Is there more on same line after a block?
        [ <?{ (@*MEMOS[@*MEMOS[$¢.pos]<ws>//$¢.pos]<endargs>//0) == 1 }>
            \h*
            <!before ';' | ')' | ']' | '}' >
            <!infixstopper>
            { $*HIGHWATER = $¢.pos = @*MEMOS[$¢.pos]<ws>//$¢.pos; }
            <.panic: "Strange text after block (missing comma, semicolon, comment marker?)">
        ]?
    }
}

sub infix:<min>($a,$b) { $a > $b ?? $b !! $a }

augment class Cursor {
    our $RED    = "\e[31m";
    our $GREEN  = "\e[32m";
    our $YELLOW = "\e[33m";
    our $CLEAR  = "\e[37m";

    method locmess () {
        my $pos = self.pos;
        my $line = self.lineof($pos);

        if $pos >= chars(self.orig) {
            $line = $line ~ " (EOF)";
        }

        my $pre = substr(self.orig, 0, $pos);
        my $prel = chars($pre) min 40;
        $pre = substr($pre, chars($pre)-$prel, $prel);
        if my $M = ($pre ~~ /^.*\n/) {
            $pre = substr($pre, $M.to);
        }
        $pre = '<BOL>' if $pre eq '';
        my $post = substr(self.orig, $pos, (chars(self.orig)-$pos) min 40);
        if $M = ($post ~~ /\n/) {
            $post = substr($post,0,$M.from);
        }
        $post = '<EOL>' if $post eq '';
        " at " ~ $*FILE<name> ~ " line $line:\n------> " ~ $Cursor::GREEN ~
            $pre ~ $Cursor::YELLOW ~ "\x23CF" ~ $Cursor::RED ~ $post ~
            $Cursor::CLEAR;
    }

    method line {
        self.lineof(self.pos);
    }

    method lineof ($p) {
        return 1 unless defined $p;
        my $line = @*MEMOS[$p]<L>;
        return $line if $line;
        $line = 1; my $pos = 0;
        self.orig ~~ / [ \n { @*MEMOS[$pos++]<L> = $line++ } ||
                         .  { @*MEMOS[$pos++]<L> = $line } ]* /;
        @*MEMOS[$pos++]<L> = $line;
        return @*MEMOS[$p]<L> // 0;
    }

    method SETGOAL { }
    method FAILGOAL ($stop, $name, $startpos) {
        my $s = "'$stop'";
        $s = '"\'"' if $s eq "'''";
        self.panic("Unable to parse $name" ~ $startpos.locmess ~ "\nCouldn't find final $s; gave up");
    }

    method deb($str) { note $str }

    method cursor_fresh($k = self) { Q:CgOp {
        (ns (cursor_fresh (cast cursor (@ {self})) (@ {$k})))
    } }

    method mixin($role) { self.cursor_fresh(self.WHAT but $role) }

    method load_lex($) {
        # NYI
        my $id = "MY:file<NULL.pad>:line(1):pos(0)";
        my $core = STDStash.new('!id' => [$id], '!file' => 'NULL.pad',
            '!line' => 1);
        STDStash.new('CORE' => $core, 'MY:file<NULL.pad>' => $core,
            'SETTING' => $core, $id => $core);
    }

    method mark_sinks(@sl) {
        #NYI
        self
    }
}

{
    my $*SETTINGNAME = 'NULL';
    my @*MEMOS;
    my $*FILE = { name => '(eval)' };
    my @*ACTIVE;
    my $*HIGHWATER = 0;
    my $*HIGHEXPECT = {};
    my $*HIGHMESS = "";
    my $*LASTSTATE = 0;
    my $*IN_PANIC = 0;
    my $*IN_SUPPOSE = 0;
    my $*FATALS = 0;

    my $*LAST_NIBBLE = Match.synthetic(:cursor(Cursor.new("")), :from(0), :to(0), :method(""), :captures());
    my $*LAST_NIBBLE_MULTILINE = $*LAST_NIBBLE;
    my $*GOAL = "(eof)";
    my $*SETTING; my $*CORE; my $*GLOBAL; my $*UNIT; my $*YOU_WERE_HERE;
    my $*CCSTATE; my $*BORG; my %*RX; my $*XACT; my $*VAR; my $*IN_REDUCE;
    STD.parse($*IN.slurp);
}
say "OK";
