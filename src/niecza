use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

$GLOBAL::DEBUG_STD = (%*ENV<NIECZA_STD_DEBUG> ?? -1 !! 0);

augment class Any {
    submethod new(|$) { die "Attempted to instantiate undefined class." }
}

# augment class RxOp {
# method oplift() {
#     say "oplift: {self.typename}";
#     my $i = 0;
#     map { say $i++; .oplift }, @$!zyg
# }
# }

our ($Sig, $SigParameter, $OpGeneralConst, $OpStateDecl, $OpLexical, $OpStatementList, $OpStart, $OpAttribute);

our $Actions; $Actions = $Actions but role {
method parameter($/) {
    my $sorry;
    my $p = $<param_var> // $<named_param>;
    my $p_ast = $p ?? $p.ast !! { names => [], flags => $Sig::POSITIONAL };
    my $flags = $p_ast<flags>;

    $flags +|= $Sig::READWRITE if $*SIGNUM && $*CURLEX<!rw_lambda>;

    for @( $<trait> ) -> $trait {
        if $trait.ast<rw> { $flags +|= $Sig::READWRITE }
        elsif $trait.ast<copy> { $flags +|= $Sig::IS_COPY }
        elsif $trait.ast<parcel> { $flags +|= $Sig::RWTRANS }
        elsif $trait.ast<readonly> { $flags +&= +^$Sig::READWRITE }
        else {
            $trait.CURSOR.sorry('Unhandled trait ' ~ $trait.ast.keys.[0]);
        }
    }

    my $default = $<default_value> ?? $<default_value>.ast !! Any;
    $default.set_name("$/ init") if $default;

    my $tag = $<quant> ~ ':' ~ $<kind>;
    if    $tag eq '**:*' { $sorry = "Slice parameters NYI" }
    elsif $tag eq '*:*'  { $flags +|= ($flags +& $Sig::IS_HASH) ?? $Sig::SLURPY_NAM !! $Sig::SLURPY_POS }
    elsif $tag eq '|:*'  { $flags +|= $Sig::SLURPY_CAP }
    elsif $tag eq '\\:!' { $flags +|= $Sig::RWTRANS }
    elsif $tag eq '\\:?' { $flags +|= ($Sig::RWTRANS + $Sig::OPTIONAL) }
    elsif $tag eq ':!'   { }
    elsif $tag eq ':*'   { $flags +|= $Sig::OPTIONAL }
    elsif $tag eq '?:*'  { $flags +|= $Sig::OPTIONAL }
    elsif $tag eq ':?'   { $flags +|= $Sig::OPTIONAL }
    elsif $tag eq '?:?'  { $flags +|= $Sig::OPTIONAL }
    elsif $tag eq '!:!'  { }
    elsif $tag eq '!:?'  { $flags +|= $Sig::OPTIONAL }
    elsif $tag eq '!:*'  { }
    else                 { $sorry = "Confusing parameters ($tag)" }
    if $sorry { $/.CURSOR.sorry($sorry); }

    if defined $p_ast<slot> {
        # TODO: type constraint here
    }

    make $SigParameter.new(name => ~$/, mdefault => $default,
        |$p_ast, :$flags);

    for @<type_constraint> -> $tc {
        if $tc.ast<where> {
            push ($/.ast.where //= []), self.thunk_sub($tc.ast<where>.ast);
        } elsif $tc.ast<value> {
            $/.ast.tclass = $tc.ast<value>.get_type;
            push ($/.ast.where //= []), self.thunk_sub(
                $OpGeneralConst.new(value => $tc.ast<value>));
        } else {
            $/.CURSOR.sorry("Parameter coercion NYI") if $tc.ast<as>;
            my $type = $tc.ast<type>;
            if $type.kind eq 'subset' {
                push ($/.ast.where //= []), self.thunk_sub(
                    $OpGeneralConst.new(value => $type.get_type_var));
                $type = $type.get_basetype while $type.kind eq 'subset';
            }
            $/.ast.tclass = $type;
            $/.ast.flags +|= $tc.ast<tmode>;
        }
    }

    for @<post_constraint> -> $pc {
        # XXX this doesn't seem to be specced anywhere, but it's
        # Rakudo-compatible and shouldn't hurt
        if $pc<bracket> {
            $/.ast.flags +&= +^$Sig::IS_HASH;
            $/.ast.flags +|= $Sig::IS_LIST;
        }

        if $pc<signature> -> $ssig {
            $ssig.CURSOR.sorry('Cannot have more than one sub-signature for a pparameter') if $/.ast.subsig;
            $/.ast.subsig = $pc<signature>.ast;
        } else {
            push ($/.ast.where //= []), self.thunk_sub($pc<EXPR>.ast);
        }
    }
}
method param_var($/) {
    if $<signature> {
        make { slot => Any, names => [], subsig => $<signature>.ast,
            flags => $Sig::POSITIONAL +
                (substr($/,0,1) eq '[' ?? $Sig::IS_LIST !! 0) };
        return;
    }
    my $twigil = $<twigil> ?? ~$<twigil> !! '';
    my $sigil = ~$<sigil>;
    my $list = $sigil eq '@';
    my $hash = $sigil eq '%';
    my $name = $<name> ?? ~$<name> !! Any;

    my $flags = ($list ?? $Sig::IS_LIST !! 0) + ($hash ?? $Sig::IS_HASH !! 0) +
        ($sigil eq '&' ?? $Sig::CALLABLE !! 0) + $Sig::POSITIONAL;
    my $slot;
    if $twigil eq '' {
        $slot = defined($name) ?? ($sigil ~ $name) !! Any;
    } elsif $twigil eq '*' {
        $slot = "$sigil*" ~ "$name";
    } elsif $twigil eq ('!' | '.') {
        make { :$flags, :$slot, attribute => "$sigil$twigil$name",
            names => [ $name ], attribute_type => $*CURLEX<!sub>.cur_pkg };
        return;
    } else {
        $/.CURSOR.sorry("Unhandled parameter twigil $twigil");
        make { };
        return Nil;
    }

    if ($sigil ne '$' && $sigil ne '@' && $sigil ne '%' && $sigil ne '&') {
        $/.CURSOR.sorry('Non bare scalar targets NYI');
        make { }
        return Nil;
    }

    $/.CURSOR.trymop({
        $/.CURSOR.check_categorical($slot);
        $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash, |mnode($/),
            noinit => ?($*SIGNUM)) if defined($slot);
    });

    make { :$slot, names => defined($name) ?? [ $name ] !! [], :$flags };
}
method variable_declarator($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }

    my $scope = $*SCOPE // 'my';

    my $start;
    for @$<trait> -> $t {
        if $t.ast<rw> {
        } elsif $t.ast<dynamic> {
        } elsif $t.ast<start> && $*SCOPE eq 'state' {
            $start = $t.ast<start>;
        } else {
            $/.CURSOR.sorry("Trait $t.ast.keys.[0] not available on variables");
        }
    }
    if $<post_constraint> || $<postcircumfix> || $<semilist> {
        $/.CURSOR.sorry("Postconstraints, and shapes on variable declarators NYI");
    }

    if $scope eq 'augment' || $scope eq 'supersede' {
        $/.CURSOR.sorry("Illogical scope $scope for simple variable");
    }

    my $typeconstraint;
    if $*OFTYPE {
        my $of = $*OFTYPE.ast;
        $*OFTYPE.CURSOR.sorry("Only simple types may be attached to variables")
            if !$of<type> || $of<tmode> || $of<as>;
        $typeconstraint = $of<type> // self.get_Any;
        $/.CURSOR.sorry("Common variables are not unique definitions and may not have types") if $scope eq 'our';
    }

    my $v = $<variable>.ast;
    my $t = $v<twigil>;
    my $list = $v<sigil> && $v<sigil> eq '@';
    my $hash = $v<sigil> && $v<sigil> eq '%';
    if ($t && defined "?=~^:".index($t)) {
        $/.CURSOR.sorry("Variables with the $t twigil cannot be declared " ~
            "using $scope; they are created " ~
            ($t eq '?' ?? "using 'constant'." !!
             $t eq '=' ?? "by parsing POD blocks." !!
             $t eq '~' ?? "by 'slang' definitions." !!
             "automatically as parameters to the current block."));
    }

    if ($scope ne any <has our my>) && ($t eq '.' || $t eq '!') {
        $/.CURSOR.sorry("Twigil $t is only valid with scopes has, our, or my.");
        $scope = 'has';
    }

    if !defined($v<name>) && ($scope ne any < my anon state >) {
        $/.CURSOR.sorry("Scope $scope requires a name");
        $v<name> = "anon";
    }

    if defined($v<pkg>) || defined($v<iname>) {
        $/.CURSOR.sorry(":: syntax is only valid when referencing variables, not when defining them.");
    }

    my $name = defined($v<name>) ?? $v<sigil> ~ $v<twigil> ~ $v<name> !! "";
    # otherwise identical to my
    my $slot = ($scope eq 'anon' || !defined($v<name>))
        ?? self.gensym !! $name;

    if ($scope eq any <our my>) && $t eq any < . ! > {
        $slot = $name = $v<sigil> ~ '!' ~ $v<name>;
        self.add_accessor($/, $v<name>, $slot, True, $t eq '.');
    }

    if $scope eq 'has' {
        make self.add_attribute($/, $v<name>, $v<sigil>, $t eq '.',
            $typeconstraint, $t eq '');
    } elsif $scope eq 'state' {
        $/.CURSOR.trymop({
            $/.CURSOR.check_categorical($slot);
            $*CURLEX<!sub>.add_state_name($slot, self.gensym, :$list,
                :$hash, :$typeconstraint, |mnode($/));
        });
        make $OpStateDecl.new(pos=>$/, inside =>
            $OpLexical.new(pos=>$/, name => $slot, :$list, :$hash));
    } elsif $scope eq 'our' {
        make self.package_var($/, $slot, $slot, ['OUR']);
    } else {
        $/.CURSOR.trymop({
            $/.CURSOR.check_categorical($slot);
            $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash,
                :$typeconstraint, |mnode($/));
        });
        make $OpLexical.new(pos=>$/, name => $slot, :$list, :$hash);
    }

    if $start {
        my $cv = self.gensym;
        $*CURLEX<!sub>.add_state_name(Str, $cv);
        make mklet($/.ast, -> $ll {
            $OpStatementList.new(pos=>$/, children => [
                $OpStart.new(condvar => $cv, body =>
                    self.inliney_call($/, $start, $ll)), $ll ]) });
    }
}
method add_attribute($/, $barename, $sigil, $accessor, $type, $bare) {
    my $ns = $*CURLEX<!sub>.body_of;
    my $name = $sigil ~ '!' ~ $barename;
    $/.CURSOR.sorry("Attribute $name declared outside of any class"),
        return $OpStatementList.new unless $ns;
    $/.CURSOR.sorry("Attribute $name declared in an augment"),
        return $OpStatementList.new if defined $*AUGMENT_BUFFER;

    if !$ns.CAN('add_attribute') {
        $/.CURSOR.sorry("A $ns.WHAT() cannot have attributes");
        return $OpStatementList.new
    }

    self.add_accessor($/, $barename, $name, False, $accessor);
    $/.CURSOR.trymop({
        $ns.add_attribute($name, $sigil, +$accessor, $type, |mnode($/));
        $*CURLEX<!sub>.add_attr_alias($sigil ~ $barename, $ns, $name)
            if $bare;
    });

    $OpAttribute.new(name => $name, initializer => $ns);
}
}

# remove run_dispatch
CgOp._register_ops: < who sc_root sc_indir temporize _addmethod _invalidate
    rxlprim
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (dotnet)
   -L --language=NAME        # select your setting
   -I --include=DIR          # add a directory to search for modules
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $version = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose" => sub { $verb++ },
    "version|v" => sub { $version = True },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    backend => $backend,
    verbose => $verb,
);

if $version {
    $c.compile_string('say "This is Niecza Perl 6 {$?PERL<version>}"', True);
    exit 0;
}

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp);
}
else {
    my $*repl_outer;
    my $*repl_outer_frame;
    $c.compile_string('$PROCESS::OUTPUT_USED ::= True', !$comp, :repl,
        :evalmode);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, :repl, :evalmode,
                :outer($*repl_outer), :outer_frame($*repl_outer_frame));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
