use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

# augment class RxOp {
# method oplift() {
#     say "oplift: {self.typename}";
#     my $i = 0;
#     map { say $i++; .oplift }, @$!zyg
# }
# }

augment class RxOp::ProtoRedis {
    # name, cutltm not used
    method code($) {
        my $bt = self.label;

        my @code;
        push @code, CgOp.rxcall("InitCursorList",
            CgOp.rxlprim('proto_dispatch', CgOp.scopedlex('Any')));
        push @code, CgOp.label($bt);
        push @code, CgOp.rxincorpshift(['dispatch'], $bt);
        @code;
    }
}

class RxOp::Endpoint is RxOp {
    has Str $.type = die "Endpoint.type required";

    method code($) { CgOp.rxcall('SetEndpoint', CgOp.str($!type)); }
    method lad() { [ 'Null' ] }
}

augment class NieczaActions {
sub qpvalue($ast) {
    if $ast.^isa(::Op::SimpleParcel) {
        join " ", map &qpvalue, @( $ast.items )
    } elsif $ast.^isa(::Op::StringLiteral) {
        $ast.text;
    } elsif $ast.^isa(::Op::Paren) {
        qpvalue($ast.inside);
    } else {
        "XXX"
    }
}
method assertion:name ($/) {
    my ($pname) = self.process_name($<longname>, :defer);
    my $name = ~$<longname>;

    if !$pname {
        $pname = { name => 'alpha' };
        $/.CURSOR.sorry('Method call requires a method name');
    }

    my @lex = $*CURLEX<!sub>.lookup_lex("&$name");
    my $is_lexical = substr($/.orig, $/.from-1, 1) ne '.' &&
        @lex && @lex[0] eq 'sub' && @lex[4].is_regex;

    if $<assertion> {
        make $<assertion>.ast;
    } elsif $name eq 'sym' {
        $/.CURSOR.sorry("<sym> is only valid in multiregexes")
            unless defined %*RX<sym>;
        make ::RxOp::Sym.new(igcase => %*RX<i>, igmark => %*RX<a>,
            text => %*RX<sym> // '', endsym => %*RX<endsym>);
    } elsif $name eq 'before' {
        make ::RxOp::Before.new(zyg => [$<nibbler>.ast]);
        return Nil;
    } elsif $name eq 'after' {
        my @l = $<nibbler>.ast.tocclist;
        if grep { !defined $_ }, @l {
            $/.CURSOR.sorry("Unsuppored elements in after list");
            make ::RxOp::Sequence.new;
            return Nil;
        }
        make ::RxOp::ZeroWidthCCs.new(neg => False, after => True, ccs => @l);
        return;
    } elsif !$<nibbler> && !$<arglist> && !$pname<pkg> && !$pname<iname> &&
            !$is_lexical {
        make ::RxOp::Subrule.new(method => $pname<name>);
    } else {
        my $args = $<nibbler> ??
            [ self.op_for_regex($/, $<nibbler>.ast) ] !!
            $<arglist> ?? $<arglist>.ast !! [];

        if $pname<iname> {
            $/.CURSOR.sorry('Indirect method calls NYI');
            $pname = {name => 'alpha'};
        }

        my $callop;
        if $is_lexical {
            $callop = ::Op::CallSub.new(invocant => mklex($/, "&$name"),
                positionals => [ mklex($/, '$¢'), @$args ]);
        } else {
            $callop = ::Operator::Method.new(name => $pname<name>, :$args,
                package => $pname<pkg> && $pname<pkg>.xref)\
                    .with_args($/, mklex($/, '$¢'));
        }

        my $regex = self.rxembed($/, $callop, True);

        make ::RxOp::Subrule.new(regex => $regex);
    }
    make self.rxcapturize($/, ~$<longname>, $/.ast);
}
method infix_prefix_meta_operator:sym<Z> ($/) {
    make $<infixish> ?? $<infixish>.ast.meta_fun($/, '&zipop', 2) !!
        Operator.funop($/, '&infix:<Z>', 2);
}
method infix_prefix_meta_operator:sym<X> ($/) {
    make $<infixish> ?? $<infixish>.ast.meta_fun($/, '&crossop', 2) !!
        Operator.funop($/, '&infix:<X>', 2);
}
method capterm($/) {
    my @args;
    if $<capture> {
        my $x = $<capture><EXPR>.ast;
        if $x.^isa(::Op::SimpleParcel) {
            @args = @($x.items);
        } else {
            @args = $x;
        }
    } elsif $<termish> {
        @args = ::Op::Paren.new(|node($/), inside => $<termish>.ast);
    }
    make ::Op::CallSub.new(|node($/), invocant => mklex($/, '&_make_capture'),
        args => @args);
}
method args($/) {
    if $<moreargs> || $<semiarglist> && $<arglist> {
        $/.CURSOR.sorry("Interaction between semiargs and args is not understood");
        make [];
        return Nil;
    }

    make $<semiarglist> ?? $<semiarglist>.ast !!
        $<arglist> ?? [ $<arglist>.ast ] !! Any;
}
method statement($/) {
    if $<label> {
        make ::Op::Labelled.new(|node($/), name => $<label>.ast,
            stmt => $<statement>.ast);
        return;
    }

    make ($<statement_control> ?? $<statement_control>.ast !!
        $<EXPR> ?? $<EXPR>.ast !! ::Op::StatementList.new);

    if $<statement_mod_cond> {
        my ($sym, $exp) = @( $<statement_mod_cond>.ast );

        if $sym eq 'if' {
            make ::Op::Conditional.new(|node($/), check => $exp,
                true => $/.ast, false => Any);
        } elsif $sym eq 'unless' {
            make ::Op::Conditional.new(|node($/), check => $exp,
                false => $/.ast, true => Any);
        } elsif $sym eq 'when' {
            make ::Op::Conditional.new(|node($/),
                check => ::Op::CallMethod.new(name => 'ACCEPTS',
                    receiver => $exp, positionals => [ mklex($/, '$_') ]),
                true => $/.ast, false => Any);
        } else {
            $/.CURSOR.sorry("Unhandled statement modifier $sym");
            make ::Op::StatementList.new;
            return Nil;
        }
    }

    if $<statement_mod_loop> {
        my ($sym, $exp) = @( $<statement_mod_loop>.ast );

        if $sym eq 'while' {
            make ::Op::WhileLoop.new(|node($/), check => $exp,
                body => $/.ast, until => False, once => False);
        } elsif $sym eq 'until' {
            make ::Op::WhileLoop.new(|node($/), check => $exp,
                body => $/.ast, until => True, once => False);
        } elsif $sym eq 'given' {
            make mktemptopic($/, $exp, $/.ast);
        } elsif $sym eq 'for' {
            # XXX laziness, comprehensions
            my $var = self.gensym;
            make ::Op::ImmedForLoop.new(|node($/), :$var, source => $exp,
                sink => mktemptopic($/, ::Op::LetVar.new(name => $var), $/.ast));
        } else {
            $/.CURSOR.sorry("Unhandled statement modifier $sym");
            make ::Op::StatementList.new;
            return Nil;
        }
    }
}
method methodop($/) {
    if $<longname> {
        my ($c) = self.process_name($<longname>, :defer);
        make ::Operator::Method.new(name => 'die');
        unless $c {
            $/.CURSOR.sorry("Method call requires a name");
            return;
        }
        if $c<iname> {
            $/.CURSOR.sorry("Indirectly named method calls NYI");
            return;
        }
        make ::Operator::Method.new(name => $c<name>, package => $c<pkg>);
    } elsif $<quote> {
        make ::Operator::Method.new(name => $<quote>.ast);
    } elsif $<variable> {
        make ::Operator::Function.new(function =>
            self.do_variable_reference($/, $<variable>.ast));
    }

    $/.ast.args = $<args>.ast[0] if $<args>;
    $/.ast.args = $<arglist>.ast if $<arglist>;
}
method module_name:normal ($/) {
    # name-extension stuff is just ignored on module names for now
    make {
        name => ~$<longname><name>,
        args => $<arglist> ?? $<arglist>.ast !! Any };
}
method if_branches($/, *@branches) {
    my $branch = shift @branches;
    mklet($branch.ast[0], -> $cond {
        ::Op::Conditional.new(|node($/), check => $cond,
            true  => self.if_block($/, $cond, $branch<pblock>),
            false => @branches ?? self.if_branches($/, @branches) !!
                $<else> ?? self.if_block($/, $cond, $<else>) !!
                Any);
    });
}
method statement_control:loop ($/) {
    my $body = self.inliney_call($/, $<block>.ast);
    # XXX wrong interpretation
    my $init = $0 && $0<e1> ?? $0<e1>.ast !! Any;
    my $cond = $0 && $0<e2> ?? $0<e2>.ast !! Any;
    my $step = $0 && $0<e3> ?? $0<e3>.ast !! Any;

    make ::Op::GeneralLoop.new(|node($/), :$body, :$init, :$cond, :$step);
}
method trait_mod:is ($/) {
    my $trait = ~$<longname>;
    my $noparm;

    if $/.CURSOR.is_name($trait) {
        my ($name) = self.process_name($<longname>);
        make { name => $name };
        $noparm = 'Superclasses cannot have parameters';
    } elsif $trait eq 'export' {
        make { export => [ 'DEFAULT', 'ALL' ] };
        $noparm = 'Export tags NYI';
    } elsif $trait eq 'endsym' {
        my $text;
        if !$<circumfix> || !$<circumfix>.ast.^isa(::Op::StringLiteral) {
            $/.CURSOR.sorry("Argument to endsym must be a literal string");
        } else {
            $text = $<circumfix>.ast.text;
        }
        make { endsym => $text };
    } elsif $trait eq 'rawcall' {
        make { nobinder => True };
    } elsif $trait eq 'return-pass' { # &return special
        make { return_pass => 1 };
    } elsif $trait eq 'parcel' {
        make { rwt => 1 };
    } elsif $<circumfix> {
        make { $trait => $<circumfix>.ast };
    } else {
        make { $trait => True };
    }

    if $noparm && $<circumfix> {
        $/.CURSOR.sorry($noparm);
    }
}
method variable($/) {
    my $sigil =  $<sigil>  ?? ~$<sigil> !! substr(~$/, 0, 1);
    my $twigil = $<twigil> ?? $<twigil><sym> !! '';

    my ($name, $pkg);
    my ($dsosl) = $<desigilname> ?? $<desigilname>.ast !!
        $<sublongname> ?? $<sublongname>.ast !!
        $<longname> ?? self.process_name($<longname>, :defer) !!
        Any;
    if defined($dsosl<ind>) {
        make { term => self.docontext($/, $sigil, $dsosl<ind>) };
        return;
    } elsif defined($dsosl<iname>) {
        make { term => ::Op::IndirectVar.new(|node($/),
            name => mkstringycat($/, $sigil ~ $twigil, $dsosl<iname>)) };
        return;
    } elsif defined $dsosl {
        ($name, $pkg) = $dsosl<name pkg>;
    } elsif $<infixish> {
        make { term => $<infixish>.ast.as_function($/) };
        return;
    } elsif $<special_variable> {
        $name = substr(~$<special_variable>, 1);
    } elsif $<index> {
        make { capid => $<index>.ast, term =>
            self.docontextif($/, $sigil,
                mkcall($/, '&postcircumfix:<[ ]>',
                    ::Op::Lexical.new(name => '$/'),
                    ::Op::Num.new(value => $<index>.ast)))
        };
        return Nil;
    } elsif $<postcircumfix>[0] {
        if $<postcircumfix>[0].reduced eq 'postcircumfix:sym<< >>' { #XXX fiddly
            make { capid => $<postcircumfix>[0].ast.args[0].text, term =>
                self.docontextif($/, $sigil,
                    mkcall($/, '&postcircumfix:<{ }>',
                        ::Op::Lexical.new(name => '$/'),
                        @( $<postcircumfix>[0].ast.args)))
            };
            return;
        } else {
            if $<postcircumfix>[0].ast.args[0] -> $arg {
                make { term => self.docontext($/, $sigil, $arg) };
            } elsif $sigil eq '$' {
                make { term => ::Op::ShortCircuit.new(|node($/), kind => '//',
                    args => [ ::Op::CallMethod.new(name => 'ast',
                                receiver => mklex($/, '$/')),
                              ::Op::CallMethod.new(name => 'Str',
                                receiver => mklex($/, '$/')) ] ) };
            } elsif $sigil eq any < @ % > {
                make { term => self.docontext($/, $sigil, mklex($/, '$/')) };
            } else {
                make { term => mklex($/, 'Mu') };
                $/.CURSOR.sorry("Missing argument for contextualizer");
            }
            return;
        }
    } else {
        $name = '';
    }

    make {
        sigil => $sigil, twigil => $twigil, name => $name, pkg => $pkg
    };
}
method param_var($/) {
    if $<signature> {
        $/.CURSOR.sorry('Sub-signatures NYI');
        make { };
        return Nil;
    }
    my $twigil = $<twigil> ?? ~$<twigil> !! '';
    my $sigil = ~$<sigil>;
    my $list = $sigil eq '@';
    my $hash = $sigil eq '%';
    my $name = $<name> ?? ~$<name> !! Any;

    my $slot;
    if $twigil eq '' {
        $slot = defined($name) ?? ($sigil ~ $name) !! Any;
    } elsif $twigil eq '*' {
        $slot = "$sigil*" ~ "$name";
    } else {
        $/.CURSOR.sorry("Unhandled parameter twigil $twigil");
        make { };
        return Nil;
    }

    if ($sigil ne '$' && $sigil ne '@' && $sigil ne '%' && $sigil ne '&') {
        $/.CURSOR.sorry('Non bare scalar targets NYI');
        make { }
        return Nil;
    }

    $/.CURSOR.trymop({
        $/.CURSOR.check_categorical($slot);
        $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash, |mnode($/),
            noinit => ?($*SIGNUM)) if defined($slot);
    });

    make { :$list, :$hash, :$slot,
        names => defined($name) ?? [ $name ] !! [] }
}
method parameter($/) {
    my $rw = ?( $*SIGNUM && $*CURLEX<!rw_lambda> );
    my $copy = False;
    my $sorry;
    my $slurpy = False;
    my $slurpycap = False;
    my $optional = False;
    my $rwt = False;
    my $type;

    if $<type_constraint> {
        ($type) = self.process_name($<type_constraint>[0]<typename><longname>);
    }

    for @( $<trait> ) -> $trait {
        if $trait.ast<rw> { $rw = True }
        elsif $trait.ast<copy> { $copy = True }
        elsif $trait.ast<parcel> { $rwt = True }
        elsif $trait.ast<readonly> { $rw = False }
        else {
            $trait.CURSOR.sorry('Unhandled trait ' ~ $trait.ast.keys.[0]);
        }
    }

    if $<post_constraint> > 0 {
        $/.sorry('Parameter post constraints NYI');
        make ::Sig::Parameter.new;
        return Nil;
    }

    my $default = $<default_value> ?? $<default_value>.ast !! Any;
    $default.set_name("$/ init") if $default;

    my $tag = $<quant> ~ ':' ~ $<kind>;
    if    $tag eq '**:*' { $sorry = "Slice parameters NYI" }
    elsif $tag eq '*:*'  { $slurpy = True }
    elsif $tag eq '|:*'  { $slurpycap = True }
    elsif $tag eq '\\:!' { $rwt = True }
    elsif $tag eq '\\:?' { $rwt = True; $optional = True }
    elsif $tag eq ':!'   { }
    elsif $tag eq ':*'   { $optional = True }
    elsif $tag eq ':?'   { $optional = True }
    elsif $tag eq '?:?'  { $optional = True }
    elsif $tag eq '!:!'  { }
    elsif $tag eq '!:?'  { $optional = True }
    elsif $tag eq '!:*'  { }
    else                 { $sorry = "Confusing parameters ($tag)" }
    if $sorry { $/.CURSOR.sorry($sorry); }
    my $p = $<param_var> // $<named_param>;

    if defined $p.ast<slot> {
        # TODO: type constraint here
    }

    make ::Sig::Parameter.new(name => ~$/, mdefault => $default,
        :$optional, :$slurpy, :$rw, tclass => $type,
        :$slurpycap, rwtrans => $rwt, is_copy => $copy, |$p.ast);
}
method colonpair($/) {
    my $n;
    if !$<v>.^isa(Match) {
        $n = ":" ~ ($<v> ?? '' !! '!') ~ $<k>;
    } else {
        $n = ":" ~ $<k> ~ "<" ~ qpvalue($<v>.ast) ~ ">";
    }
    my $tv = $<v>.^isa(Match) ?? $<v>.ast !!
        ::Op::Lexical.new(name => $<v> ?? 'True' !! 'False');

    if $tv ~~ Str {
        if substr($<v>,1,1) eq '<' {
            $tv = mkcall($/, '&postcircumfix:<{ }>',
                ::Op::Lexical.new(name => '$/'),
                ::Op::StringLiteral.new(text => ~$<k>));
        } else {
            $tv = self.do_variable_reference($/,
                { sigil => ~$<v><sigil>,
                    twigil => ($<v><twigil> ?? ~$<v><twigil> !! ''),
                    name => $<k> });
        }
    }

    make { ext => $n, term => ::Op::SimplePair.new(key => $<k>, value => $tv) };
}
# can remove XXX comment on from_base
sub from_base($str, $base) {
    my $acc = 0;
    my $punto = -1;
    for $str.lc.comb -> $ch {
        next if $ch eq '_';
        if $ch eq '.' { $punto = 0; next; }
        $punto++ if $punto >= 0;
        $acc = $acc * $base + ($ch ge 'a' ?? ord($ch) - 87 !! ord($ch) - 48);
    }
    $punto >= 0 ?? $acc / ($base ** $punto) !! $acc
}
method integer($/) {
    $<decint> andthen make $<decint>.ast;
    $<octint> andthen make $<octint>.ast;
    $<hexint> andthen make $<hexint>.ast;
    $<binint> andthen make $<binint>.ast;
}
method dec_number ($/) {
    if $<escale> { make +((~$/).comb(/<-[_]>/).join("")) }
    else { make from_base($/, 10) }
}
method rad_number ($/) {
    if $<circumfix> {
        $/.CURSOR.sorry("Runtime base conversions NYI");
        make 0;
        return;
    }
    my $radix = +$<radix>;
    my $value = $<int> ?? from_base($<int>, $radix) !! 0;
    if $<frac> -> $fr {
        my $shift = $fr.chars - $fr.comb('_');
        $value += (from_base($fr, $radix) / ($radix ** $shift));
    }
    if $<base> {
        $value = $value * $<base>.ast ** ($<exp> ?? $<exp>.ast !! 0);
        $value = $value.Num; # exponential notation is always imprecise here
    }
    make $value;
}
method radint($/) {
    $<rad_number> && make $<rad_number>.ast;
    $<integer> && make $<integer>.ast;
}
method charname($/) {
    if $<radint> {
        if $<radint>.ast !~~ (Int & 0 .. 0x10FFFF) {
            $/.CURSOR.sorry("Numeric character identifiers must be integers between 0 and 0x10FFFF");
            make ' ';
        } else {
            make chr($<radint>.ast);
        }
    } else {
        my $chr = ' ';
        $/.CURSOR.trymop({ $chr = $*backend.get_codepoint(~$/) });
        make $chr;
    }
}
method charnames($/) { make join "", map *.ast, @$<charname> }
method charspec($/) {
    if $<charnames> { make $<charnames>.ast }
    else {
        my $str = ~$/;
        if $str ~~ /^\d/ {
            make chr(+$str);
        } else {
            make chr(ord($str) +& 31);
        }
    }
}

method backslash:c ($/) { make $<charspec>.ast; self.post_backslash($/); }

method number($/) {
    my $child = $<integer> // $<dec_number> // $<rad_number>;
    if !defined $child {
        make $/ eq 'NaN' ?? (0e0/0e0) !! Inf;
    } else {
        given $child.ast {
            when Num { make $_ }
            when Int { make [ 10, ~$_ ] }
            when Rat { make [ 10, "{.numerator}/{.denominator}" ] }
        }
    }
}
method cclass_elem:property ($/) {
    my $body = self.thunk_sub($<colonpair>.ast<term>, name => ~$<colonpair>);
    $body.outer.create_static_pad;
    make self.void_cc;
    $/.CURSOR.trymop({
        make self.cclass_cc(CClass.new(terms => [ $body.run_BEGIN_CC ]));
    });
}

method metachar:sym« <( » ($/) {
    make ::RxOp::Endpoint.new(|node($/), :type<from>)
}
method metachar:sym« )> » ($/) {
    make ::RxOp::Endpoint.new(|node($/), :type<to>)
}
method regex_def($/) {
    my $ast = $<regex_block>.ast;

    if $<regex_block><onlystar> {
        $ast = ::RxOp::ProtoRedis.new(name => $*CURLEX<!name>);
    }

    my @lift = $ast.oplift;
    my $ltm = ::GLOBAL::OptRxSimple.run_lad($ast.lad);
    $*CURLEX<!sub>.set_ltm($ltm);
    ($ast, my $mb) = ::GLOBAL::OptRxSimple.run($ast);
    if $<regex_block><onlystar> {
        $*CURLEX<!sub>.finish_dispatcher('regex');
    } else {
        $*CURLEX<!sub>.finish(::Op::RegexBody.new(|node($/), pre => @lift,
            name => ($*CURLEX<!name> // ''), rxop => $ast, canback => $mb));
    }
    make ::Op::Lexical.new(|node($/), name => $*CURLEX<!sub>.outervar);
}
method metachar:sym<{*}> ($/) {
    make ::RxOp::ProtoRedis.new(name => '', :!cutltm);
    return;
}

method is_dispatcher($blockoid) {
    $blockoid.Str ~~ m:pos(0) / '{' \s* '*' \s* '}' /;
}
method finish_method_routine ($/) {
    if self.is_dispatcher($<blockoid>) {
        $*CURLEX<!sub>.finish_dispatcher('multi');
    } else {
        $*CURLEX<!sub>.finish($<blockoid>.ast);
    }
    make ::Op::Lexical.new(|node($/), name => $*CURLEX<!sub>.outervar);
}
method routine_def ($/) { self.finish_method_routine($/) }
method method_def ($/)  { self.finish_method_routine($/) }
method install_sub($/, $sub, :$multiness is copy, :$scope is copy, :$class,
        :$longname, :$method_type is copy, :$contextual is copy) {

    $multiness ||= 'only';
    my ($pkg, $name) = self.process_name($longname, :declaring);

    if !$scope {
        if !defined($name) {
            $scope = 'anon';
        } elsif defined($pkg) {
            $scope = 'our';
        } elsif defined($method_type) {
            $scope = 'has';
        } else {
            $scope = 'my';
        }
    }

    if $class eq 'Regex' {
        my $/;
        $*CURLEX<!name> = $name;
        $*CURLEX<!cleanname !sym> =
            !defined($name) ?? (Str, Str) !!
            ($name ~~ /\:sym\<(.*)\>/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name ~~ /\:(\w+)/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name, Str);
        %*RX<sym> = $*CURLEX<!sym>;
        $multiness = 'multi' if defined $*CURLEX<!sym>;
        $*CURLEX<!multi> = $multiness;
    }

    if $scope ne 'my' && $scope ne 'our' && $scope ne 'anon' && $scope ne 'has' {
        $/.CURSOR.sorry("Illegal scope $scope for subroutine");
        $scope = 'anon';
    }

    if $scope eq 'has' && !defined($method_type) {
        $/.CURSOR.sorry('has scope-type is only valid for methods');
        $scope = 'anon';
    }

    if $scope ne 'anon' && !defined($name) {
        $/.CURSOR.sorry("Scope $scope requires a name");
        $scope = 'anon';
    }

    if $scope ne 'our' && defined($pkg) {
        $/.CURSOR.sorry("Double-colon-qualified subs must be our");
        $scope = 'our';
    }

    if $scope eq 'anon' && $multiness ne 'only' {
        $/.CURSOR.sorry("Multi routines must have a name");
        $multiness = 'only';
    }

    if $contextual && (defined($method_type) || $scope ne 'my') {
        $/.CURSOR.sorry("Context-named routines must by purely my-scoped");
        $contextual = False;
    }

    $method_type = Str if $scope eq 'anon';

    my $method_targ = $method_type && $sub.outer.body_of;
    if !$method_targ && defined($method_type) {
        $/.CURSOR.sorry("Methods must be used in some kind of package");
        $method_type = Str;
    }

    if $method_targ && !$method_targ.CAN('add_method') {
        $/.CURSOR.sorry("A {$method_targ.kind} cannot have methods added");
        $method_type = Str;
        $method_targ = Any;
    }

    if $name ~~ Op && (!defined($method_type) || $scope ne 'has' ||
            $method_targ.kind ne 'prole') {
        $/.CURSOR.sorry("Computed names are only implemented for parametric roles");
        $name = "placeholder";
    }

    my $bindlex = $scope eq 'my' || ($scope eq 'our' && !$pkg);

    $sub.set_name(defined($method_type) ?? $method_targ.name ~ "." ~ $name !!
        ($name // 'ANON'));
    $sub.set_class($class);

    my $std = $/.CURSOR;
    {
        my $/;
        if $sub.name ~~ /^(\w+)\:\<(.*)\>$/ {
            my %new = %( $std.default_O(~$0, ~$1) );
            $sub.set_extend('prec', %new.kv);
        }
    }

    my Str $symbol;
    $/.CURSOR.trymop({
        if $bindlex && $class eq 'Regex' {
            $symbol = '&' ~ $name;
            my $proto = $symbol;
            { my $/; $proto ~~ s/\:.*//; }
            $sub.outer.add_dispatcher($proto, |mnode($/))
                if $multiness ne 'only' && !$sub.outer.has_lexical($proto);
            $symbol ~= ":(!proto)" if $multiness eq 'proto';
        } elsif $bindlex {
            $symbol = '&' ~ $name;
            $/.CURSOR.check_categorical($symbol);
            if $multiness ne 'only' && !$sub.outer.has_lexical($symbol) {
                $sub.outer.add_dispatcher($symbol, |mnode($/))
            }

            given $multiness {
                when 'multi' { $symbol ~= ":({ self.gensym })"; }
                when 'proto' { $symbol ~= ":(!proto)"; }
                default {
                    $/.CURSOR.check_categorical($symbol);
                }
            }
        } else {
            $symbol = self.gensym;
        }

        $sub.set_outervar($symbol);
        $sub.set_methodof(defined($method_type) ?? $method_targ !! Any);
        $sub.outer.add_my_sub($symbol, $sub, |mnode($/));

        if $multiness ne 'only' || $scope eq 'our' || $method_type {
            $/.CURSOR.mark_used($symbol);
        }

        if defined($method_type) || $scope eq 'our' {
            $sub.outer.create_static_pad;
        }

        if defined($method_type) {
            my $mode = 0;
            given $method_type {
                when 'sub'      { $mode += 2 }
                when 'normal'   { $mode += 0 }
                when 'private'  { $mode += 1 }
                default         { die "Unimplemented method type $_" }
            }
            given $multiness {
                when 'only'     { $mode += 0 }
                when 'proto'    { $mode += 4 }
                when 'multi'    { $mode += 8 }
                default         { die "Unimplemented multiness $_" }
            }
            if defined $*AUGMENT_BUFFER {
                push $*AUGMENT_BUFFER, $mode, $name, $symbol;
            } else {
                $method_targ.add_method($mode, $name, $sub, |mnode($/));
            }
        }

        if $scope eq 'our' {
            $*unit.bind(($pkg // $sub.outer.cur_pkg).who,
                "&$name", $sub);
        }
    });
}
}

# remove run_dispatch
CgOp._register_ops: < who sc_root sc_indir temporize _addmethod _invalidate
    rxlprim
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (dotnet)
   -L --language=NAME        # select your setting
   -I --include=DIR          # add a directory to search for modules
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp);
}
else {
    my $*repl_outer;
    my $*repl_outer_frame;
    $c.compile_string('$PROCESS::OUTPUT_USED ::= True', !$comp, :repl,
        :evalmode);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, :repl, :evalmode,
                :outer($*repl_outer), :outer_frame($*repl_outer_frame));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
