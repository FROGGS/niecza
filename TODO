Here are a bunch of project ideas, both for me and for anyone else who
wants to help out.  Starred items are ones I've already spent time
thinking about; check with me if you want to build on that.  Plussed
items are considered a priority for v3.

EASY

   Add your favorite missing function to the setting, with tests.
   In particular, I could use: sprintf, dir, write, close, split, ...

   Add $*ARGFILES, %*ENV, your favorite other *-var.

   Add the 'loop' statement.  Should be very straightforward.

   Add decimal literals.  (Don't try to implement your own floating point
   radix converter; use +$str)

 +*Optimize control exceptions to gotos in the intrablock case.

   Add more benchmarks to perf/.

   Fix the qw< > parsing problems.

 + return and take need to accept multiple arguments and wrap them in a Parcel

   Binding to values like @PROCESS::ARGS doesn't contextualize correctly.  Fix.

MEDIUM

   Implement buffer types and binary I/O.

   Implement a general socket API.

   Design and implement a generic system for multiplexed and non-blocking I/O.

  *CATCH and CONTROL blocks.

 + Jump table optimization for when chains.

   Find out what readonly subs are supposed to do with lists, etc and implement
   that.  Also add return-rw, take-rw, and the is rw trait for subs and attrs.

  *Implement BUILD submethod calling.

   Methods with variable names need to call the correct action method.  (See
   the horrible hack in NieczaActions.FALLBACK).

   Audit accelerated context routines for correct undefined value and odd
   representation handling.  +Num shouldn't crash, etc.

 +*A general procedure for communicating data up and down the meta-spiral.
   Use this to make a very simple eval knockoff.

HARD

   Design and implement some sort of NFG thing that allows use codes, graphs,
   etc and handles canonical equivalence in regexes.

 + Replace nam with something that doesn't use as much memory.  (Talk to
   pmurias to get his experiences.)

  *Implement junctions.  You'll need to add some slightly tricky code
   on the slow path of nominal type checks.  You will also need to fix
   the optimized builtins to use nominal type checking.  Bonus points
   if the optimizer can turn if $x == any(1,3,5) into a loop.

  *Implement multiple dispatch.

  *Create multiple numeric types with sensible overloads between them.  Add
   more numeric operators.

   Niecza is probably the ideal platform for prototyping a concurrency
   system which will whirlpool back into the synopses.

  *Parallel hyperops!  Read the Cilk papers, they seem to have a data
   parallelism model most similar to what Perl 6 needs.

   Understand the Str/Stringy distinctions, and improve stringification
   and numification handling for Any.  Develop a warning system.

  *Explicitly imprecise error reporting.  In many circumstances niecza
   doesn't actually have an exact line number; it should be able to
   report a range.

   Design something to take the place of STD's :$*endsym, probably as
   a trait of some kind.

   Design something to deal with the last remnants of cursor mutability
   in STD.pm6.

 +*"Immediate mode metamodel" - Metamodel::StaticSub object should be
   constructed by the closing brace at the latest.  This will require
   a lot of STD hacking and is required for BEGIN to work.

   Study Nil and find the correct way to integrate it into Niecza.

NASTY

  *A multicore job scheduler would be cool.  You'll need to talk with
   TimToady on dependency extraction; there are some subtle points with
   modules that export slangs.

  *Figure out how eval can possibly work.  Do it.

  *Figure out how BEGIN can possibly work.  Do it.
