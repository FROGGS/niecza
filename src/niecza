use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

$GLOBAL::DEBUG_STD = (%*ENV<NIECZA_STD_DEBUG> ?? -1 !! 0);

augment class Any {
    submethod new(|$) { die "Attempted to instantiate undefined class." }
}

our $Sig = Sig;
our $SigParameter = Sig::Parameter;
our $Actions = NieczaActions;
our $PassSimplifier = NieczaPassSimplifier;
our $CgOp = CgOp;
our $CClass = CClass;
our $OptBeta = OptBeta;
our $OptRxSimple = OptRxSimple;

our $Op = Op;
our $OpCgOp = Op::CgOp;
our $OpStatementList = Op::StatementList;
our $OpCallLike = Op::CallLike;
our $OpCallSub = Op::CallSub;
our $OpCallMethod = Op::CallMethod;
our $OpGetSlot = Op::GetSlot;
our $OpSetSlot = Op::SetSlot;
our $OpParen = Op::Paren;
our $OpSimplePair = Op::SimplePair;
our $OpSimpleParcel = Op::SimpleParcel;
our $OpInterrogative = Op::Interrogative;
our $OpHereStub = Op::HereStub;
our $OpYada = Op::Yada;
our $OpShortCircuit = Op::ShortCircuit;
our $OpShortCircuitAssign = Op::ShortCircuitAssign;
our $OpStringLiteral = Op::StringLiteral;
our $OpConditional = Op::Conditional;
our $OpWhileLoop = Op::WhileLoop;
our $OpGeneralLoop = Op::GeneralLoop;
our $OpForLoop = Op::ForLoop;
our $OpImmedForLoop = Op::ImmedForLoop;
our $OpLabelled = Op::Labelled;
our $OpWhen = Op::When;
our $OpStart = Op::Start;
our $OpTry = Op::Try;
our $OpControl = Op::Control;
our $OpMakeJunction = Op::MakeJunction;
our $OpNum = Op::Num;
our $OpAttribute = Op::Attribute;
our $OpWhatever = Op::Whatever;
our $OpWhateverCode = Op::WhateverCode;
our $OpBareBlock = Op::BareBlock;
our $OpSubDef = Op::SubDef;
our $OpLexical = Op::Lexical;
our $OpConstantDecl = Op::ConstantDecl;
our $OpContextVar = Op::ContextVar;
our $OpRequire = Op::Require;
our $OpTake = Op::Take;
our $OpGather = Op::Gather;
our $OpMakeCursor = Op::MakeCursor;
our $OpLetVar = Op::LetVar;
our $OpRegexBody = Op::RegexBody;
our $OpYouAreHere = Op::YouAreHere;
our $OpGetBlock = Op::GetBlock;
our $OpAssign = Op::Assign;
our $OpBuiltin = Op::Builtin;
our $OpLet = Op::Let;
our $OpLetScope = Op::LetScope;
our $OpTopicalHook = Op::TopicalHook;
our $OpLeaveHook = Op::LeaveHook;
our $OpLabelHook = Op::LabelHook;
our $OpLexicalBind = Op::LexicalBind;
our $OpROify = Op::ROify;
our $OpStateDecl = Op::StateDecl;
our $OpDoOnceLoop = Op::DoOnceLoop;
our $OpFlipFlop = Op::FlipFlop;
our $OpTemporize = Op::Temporize;
our $OpIndirectVar = Op::IndirectVar;
our $OpCatchyWrapper = Op::CatchyWrapper;
our $OpGeneralConst = Op::GeneralConst;

our $RxOp = RxOp;
our $RxOpCapturing = RxOp::Capturing;
our $RxOpSym = RxOp::Sym;
our $RxOpString = RxOp::String;
our $RxOpVarString = RxOp::VarString;
our $RxOpQuantifier = RxOp::Quantifier;
our $RxOpSequence = RxOp::Sequence;
our $RxOpConj = RxOp::Conj;
our $RxOpAltBase = RxOp::AltBase;
our $RxOpSeqAlt = RxOp::SeqAlt;
our $RxOpConfineLang = RxOp::ConfineLang;
our $RxOpCut = RxOp::Cut;
our $RxOpBeforeString = RxOp::BeforeString;
our $RxOpZeroWidthCCs = RxOp::ZeroWidthCCs;
our $RxOpNotBeforeString = RxOp::NotBeforeString;
our $RxOpZeroWidth = RxOp::ZeroWidth;
our $RxOpNotBefore = RxOp::NotBefore;
our $RxOpBefore = RxOp::Before;
our $RxOpTilde = RxOp::Tilde;
our $RxOpSubrule = RxOp::Subrule;
our $RxOpSigspace = RxOp::Sigspace;
our $RxOpCutLTM = RxOp::CutLTM;
our $RxOpCutRule = RxOp::CutRule;
our $RxOpCutBrack = RxOp::CutBrack;
our $RxOpSetLang = RxOp::SetLang;
our $RxOpAlt = RxOp::Alt;
our $RxOpCheckBlock = RxOp::CheckBlock;
our $RxOpSaveValue = RxOp::SaveValue;
our $RxOpVoidBlock = RxOp::VoidBlock;
our $RxOpStatement = RxOp::Statement;
our $RxOpProtoRedis = RxOp::ProtoRedis;
our $RxOpAny = RxOp::Any;
our $RxOpQuantCClass = RxOp::QuantCClass;
our $RxOpCClassElem = RxOp::CClassElem;
our $RxOpNone = RxOp::None;
our $RxOpNewline = RxOp::Newline;
our $RxOpStringCap = RxOp::StringCap;
our $RxOpListPrim = RxOp::ListPrim;
our $RxOpEndpoint = RxOp::Endpoint;

our $Operator = Operator;
our $Operator_Function = Operator::Function;
our $Operator_PostCall = Operator::PostCall;
our $Operator_Method = Operator::Method;
our $Operator_FlipFlop = Operator::FlipFlop;
our $Operator_ShortCircuit = Operator::ShortCircuit;
our $Operator_CompoundAssign = Operator::CompoundAssign;
our $Operator_MetaNot = Operator::MetaNot;
our $Operator_Binding = Operator::Binding;
our $Operator_Comma = Operator::Comma;
our $Operator_Ternary = Operator::Ternary;
our $Operator_Temp = Operator::Temp;
our $Operator_Let = Operator::Let;
our $Operator_SmartMatch = Operator::SmartMatch;
our $Operator_DotEq = Operator::DotEq;
our $Operator_Replicate = Operator::Replicate;
our $Operator_Mixin = Operator::Mixin;

# augment class RxOp {
# method oplift() {
#     say "oplift: {self.typename}";
#     my $i = 0;
#     map { say $i++; .oplift }, @$!zyg
# }
# }

augment class NieczaActions {
}

# remove run_dispatch
CgOp._register_ops: < who sc_root sc_indir temporize _addmethod _invalidate
    rxlprim
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (dotnet)
   -L --language=NAME        # select your setting
   -I --include=DIR          # add a directory to search for modules
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $version = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose" => sub { $verb++ },
    "version|v" => sub { $version = True },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    backend => $backend,
    verbose => $verb,
);

if $version {
    $c.compile_string('say "This is Niecza Perl 6 {$?PERL<version>}"', True);
    exit 0;
}

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp);
}
else {
    my $*repl_outer;
    my $*repl_outer_frame;
    $c.compile_string('$PROCESS::OUTPUT_USED ::= True', !$comp, :repl,
        :evalmode);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, :repl, :evalmode,
                :outer($*repl_outer), :outer_frame($*repl_outer_frame));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
