use Metamodel;
use Op;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use NieczaActions;
use CClass;
use Sig;
use OptRxSimple;
augment class CClass {
    method internal($str) { (&CClass::internal)($str) }
}
augment class NieczaActions {
sub node($M) { { file => $*FILE<name>, line => $M.cursor.lineof($M.to) } }
method regex_def($/) {
    sub _symtext($name) {
        ($name ~~ /\:sym\<(.*)\>/) ?? ~$0 !!
            ($name ~~ /\:(\w+)/) ?? ~$0 !!
            Str; #XXX
    }
    my ($name, $path) = $<deflongname> ??
        self.mangle_longname($<deflongname>[0]).<name path> !! Nil;
    my $cname;
    if defined($path) && $path == 0 && $name.^isa(Op) {
        $cname = $name;
        $name = ~$<deflongname>[0];
        $path = Any;
    }

    my $scope = (!defined($name)) ?? "anon" !! ($*SCOPE || "has");

    if $<signature> > 1 {
        $/.CURSOR.sorry("Multiple signatures on a regex NYI");
        return Nil;
    }

    if $cname && $scope ne 'has' {
        $/.CURSOR.sorry("Only has regexes may have computed names");
        make ::Op::StatementList.new;
        return Nil;
    }

    my $isproto;
    my $symtext = ($cname || !defined($name)) ?? Str !! _symtext($name);
    if $*MULTINESS eq 'proto' {
        if $<signature> || !$<regex_block><onlystar> || $scope ne 'has' {
            $/.CURSOR.sorry("Only simple {*} protoregexes with no parameters are supported");
            return Nil;
        }
        $isproto = True;
    } else {
        my $m2 = defined($symtext) ?? 'multi' !! 'only';
        if $*MULTINESS && $*MULTINESS ne $m2 {
            $/.CURSOR.sorry("Inferred multiness disagrees with explicit");
            return Nil;
        }
    }

    if defined($path) && $scope ne 'our' {
        $/.CURSOR.sorry("Putting a regex in a package requires using the our scope.");
        return Nil;
    }

    my $sig = $<signature> ?? $<signature>[0].ast !! Sig.simple;

    if $scope eq 'state' || $scope eq 'supercede' || $scope eq 'augment' {
        $/.CURSOR.sorry("Nonsensical scope $scope for regex");
        return Nil;
    }

    if $scope eq 'our' {
        $/.CURSOR.sorry("our regexes NYI");
        return Nil;
    }

    my $var = ($scope eq 'anon' || $scope eq 'has') ?? self.gensym
        !! '&' ~ $name;

    my $ast = $<regex_block>.ast;
    if $isproto {
        $ast = ::RxOp::ProtoRedis.new(name => $name);
    }

    {
        my $*paren = 0;
        my $*symtext = $symtext;
        my $*dba = $name // 'anonymous regex';
        $ast.check;
    }
    my $lad = OptRxSimple.run_lad($ast.lad);
    my @lift = $ast.oplift;
    ($ast, my $mb) = OptRxSimple.run($ast);
    make ::Op::SubDef.new(|node($/),
        var  => $var,
        method_too => ($scope eq 'has' ?? ['normal', $cname // $name] !! Any),
        body => Body.new(
            ltm   => $lad,
            returnable => True,
            class => 'Regex',
            type  => 'regex',
            name  => $name // 'ANONrx',
            signature => $sig.for_method,
            do => ::Op::RegexBody.new(|node($/), pre => @lift,
                name => ($name // ''), rxop => $ast, canback => $mb)));
}
method regex_infix:sym<|> ($ ) {}
method regex_infix:sym<||> ($ ) {}
method regex_infix:sym<&> ($ ) {}
method regex_infix:sym<&&> ($ ) {}
method type_declarator:constant ($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    my $scope = $*SCOPE // 'my';
    if !$<identifier> && !$<variable> {
        $/.CURSOR.sorry("Anonymous constants NYI"); #wtf?
        return Nil;
    }
    my $slot  = ~($<identifier> // $<variable>);

    make ::Op::ConstantDecl.new(|node($/), name => $slot,
        path => ($scope eq 'our' ?? [ 'OUR' ] !! Array));
}
}

# XXX mega hack.
my class Instant {
    has $.val;
    method to-posix() { $!val }
}

my class IO {
    has $.path; # Str

    method Str() { $.path }
    method IO() { self }

    method slurp() { slurp $.path }
    method spew($text) { spew $.path, $text }

    method combine(*@paths) {
        die "Sorry, paths do not form a monoid." unless @paths;
        my $acc = @paths.shift.IO;
        for @paths { $acc = $acc.append($_) }
        $acc
    }

    method f() { Q:CgOp { (box Bool (rawscall System.IO.File.Exists (obj_getstr {$!path}))) } }
    method d() { Q:CgOp { (box Bool (rawscall System.IO.Directory.Exists (obj_getstr {$!path}))) } }
    method e() { self.f || self.d }
    method relative($base) { $base.IO.append(self) }
    method append($sub) { Q:CgOp { (box Str (rawscall System.IO.Path.Combine (obj_getstr {self}) (obj_getstr {$sub}))) }.IO }
    method but-extension($ext) { Q:CgOp { (box Str (rawscall System.IO.Path.ChangeExtension (obj_getstr {self}) (obj_getstr {$ext}))) }.IO }
    method realpath() { Q:CgOp { (box Str (rawscall System.IO.Path.GetFullPath (obj_getstr {self}))) }.IO }
    method modified() { Instant.new(val => Q:CgOp { (rawscall Builtins,Kernel.GetModTime (obj_getstr {self})) }) }
}

augment class Str {
    method IO() { IO.new(path => self) }
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => ["../lib", "."],
    ),
    frontend => NieczaFrontendSTD.new(
        lang => 'CORE',
        safemode => False,
    ),
    stages => [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ],
    backend => NieczaBackendNAM.new(
        obj_dir => 'obj',
    ),
    verbose => True,
);

$c.compile_module("SAFE");
$c.compile_module("CORE");
$c.compile_string("say 'Hello, world'", False);
