=head1 Synopsis

C<compiler.pod> - overview of Niecza compiler pipeline

=head1 Description

The Perl 6 script F<src/niecza> is the command line wrapper that controls
the startup of Niecza.  After reading command line options it constructs
a compiler object, tweaks its properties and calls one of its compile
methods.

The compiler object is defined in F<src/NieczaCompiler.pm6>.  Each
compile method creates a certain environment and then calls the internal
C<!compile> method.  This runs a parser (front end), a pipeline of
transformation stages (middle end) and a code emitter (back end).

The binary representation of the program being passed between the
components is an abstract syntax tree (AST).  The tree nodes are objects
in subclasses of the base class C<Op> from F<src/Op.pm6>.

The parser is F<src/NieczaFrontendSTD.pm6>, it uses F<src/NieczaGrammar.pm6>
and F<src/NieczaActions.pm6>.  The grammar uses F<src/STD.pm6>, a snapshot
of Larry Wall's standard Perl 6 grammar that continues to evolve at
L<https://github.com/perl6/std>.  The actions module uses a series of
other modules (Op, RxOp, Sig, CClass, OpHelpers, Operator) to create the
AST from Perl 6 source code.  The parser triggers each action when it
matches the corresponding token in the grammar.

The middle end currently consists of F<src/NieczaPassSimplifier.pm6> but
more stages can be plugged in using the F<src/niecza> script.  The
C<!compile> method calls the C<invoke> method of each stage, passing an
AST in and getting a new AST out.  The PassSimplifier stage converts
keywords such as C<next>, C<any> and C<return> into calls to runtime
functions that implement them.  The stages are where code optimizers do
their work.

There are several back ends selectable from the F<src/niecza> script,
the default one is 'dotnet' which begins in F<src/NieczaBackendDotnet.pm6>.
Back ends transform the AST code into a Niecza Abstract Machine (NAM)
structure, do platform specific optimization, and produce a NAM output
format (see L<nam.pod>).  The NAM code is in F<src/NieczaBackendNAM.pm6>
which uses F<src/NAMOutput.pm6>.

The dotnet back end uses a subroutine called C<downcall> that calls
C<rawscall> (defined in F<lib/CLRBackend.cs>) to make a "raw system call"
to a handler, which in dotnet is a C<delegate>.  The downcall handler
for dotnet is called C<DownCall> which resides in F<lib/Builtins.cs>,
and it delegates to the C<NamProcessor> handler, also defined in
F<lib/CLRBackend.cs>, passing it the NAM output.

Think carefully about what happens when C<rawscall> executes.  It looks
like a language interoperability interface between Perl 6 and C#, as if
the two languages are peers sending data to each other.  The details are
a bit weirder.  Perl 6 code itself never executes directly, the code
generated for it by a compiler executes.  Imagine C<rawscall> as a kind
of wormhole made by the compiler to connect events in the Perl 6 world
to events in the executable world.  Niecza is such a Perl 6 compiler
that runs as an Intermediate Language (IL) program executed by a Common
Language Runtime (CLR) (either Mono or .NET).  When a Perl 6 C<rawscall>
executes it is the IL compiled for C<rawscall> that executes.  So how
was the IL for the Perl 6 source code parts of Niecza (the callers of
C<rawscall>) made?  How is the Niecza compiler babby formed?

Consider what a compiler is - a program that writes a program.  Give it
input in one language and it translates to output in another.  And a
compiled compiler is also a program, written in one language and run in
another.  There are then four potentially different languages, sometimes
fewer, depending on whether it is a native compiler, a cross compiler, a
self hosting compiler such as Niecza etc.

Bootstrapping self-hosting compilers is a chicken-or-egg conundrum that
software gurus call a "circular dependency" or "circularity".  In the
case of Niecza today's solution is "here's one we made earlier", in a
F<niecza.zip> that F<Makefile> downloads and expands into F<boot/> when
you first build.  How was the earliest Niecza formed?  Once upon a time,
Niecza was not self hosting, and the initial Nieczas were cross compiled
using code written in Perl 5 and C#.  That obsolete code no longer works
and has therefore been removed.  Phew.  Let's return to CLRBackend.

=cut

<sorear> mberends: rawscall is raw static (method) call; it allows calls
    into C# libraries from Perl 6, like earlier versions of Niecza
    (before I started taking backend portability more seriously) defined
    say using
     (rawscall System.Console.WriteLine (obj_getstr {@args.join('')}))
<sorear> mberends: the downcall mechanism is very hairy
<mberends> sorear: interesting. I thought last night about writing
    something about the bootstrapping implications of downcall
<sorear> mberends: run/Niecza.exe is linked against run/Kernel.dll (from
    the bootstrap zipball), but code you compile with Niecza.exe should
    link against obj/Kernel.dll (compiled from lib/*.cs)
<sorear> the CLR allows you to load two incompatible assemblies with the
    same name, as long as you load them in different "application domains"
<mberends> sorear: thanks! I'll also delete the old content and continue
    writing up CLRBackend.cs
<sorear> the C# DownCall method performs the necessary voodoo to create
    a second appdomain for running code, then invoke the back back end :)
    in CLRBackend.cs in the child appdomain
