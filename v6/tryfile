# vim: ft=perl6
use MONKEY_TYPING;

use STD;
use Stash;
use NAME;

augment class List {
    method shift() { self!fill(1) ?? self!shift-item !! Any }
}

augment class Any {
    method list() { @( self, ) }
}

augment class Stash {
    method iterator () { self.list.iterator }
}

augment class NAME {
}

augment class Regex {
    method ACCEPTS($st) {
        my $i = 0;
        my $str = $st.Str;
        my $mat;
        my $C = Cursor.new($str);
        while !$mat && ($i <= $str.chars) {
            ($mat,) = (self)($C.cursor($i++));
        }
        $mat ?? unitem($mat) !! Any;
    }
}

augment class Match {
    method trim_heredoc () { self } # NYI
}

augment class Hash {
    method hash() { unitem(self) }
}

augment class STD {
token nibbler {
    :my $text = '';
    :my $from = self.pos;
    :my $to = $from;
    :my @nibbles = ();
    :my $multiline = 0;
    [ <!before <stopper> >
        [
        || <starter> <nibbler> <stopper>
                        {
                            push @nibbles, Match.synthetic(:cursor(self), :from($from), :to($to), :method<Str>, :captures()) if $from != $to;

                            my $n = $<nibbler>[(+$<nibbler>)-1]<nibbles>;
                            my @n = @$n;

                            push @nibbles, $<starter>;
                            push @nibbles, @n;
                            push @nibbles, $<stopper>;

                            $text = '';
                            $to = $from = $¢.pos;
                        }
        || <escape>     {
                            push @nibbles, Match.synthetic(:cursor(self), :from($from), :to($to), :method<Str>, :captures()) if $from != $to;
                            push @nibbles, $<escape>[(+$<escape>)-1];
                            $text = '';
                            $to = $from = $¢.pos;
                        }
        || .
                        {{
                            my $ch = substr(self.orig, $¢.pos-1, 1);
                            $text ~= $ch;
                            $to = $¢.pos;
                            if $ch ~~ "\n" {
                                $multiline++;
                            }
                        }}
        ]
    ]*
    {
        push @nibbles, Match.synthetic(:cursor(self), :from($from), :to($to), :method<Str>, :captures()) if $from != $to or !@nibbles;
        $*LAST_NIBBLE = $¢.pos;
        $*LAST_NIBBLE_START = self.pos;
        $*LAST_NIBBLE_MULTILINE = $¢.pos if $multiline;
        $*LAST_NIBBLE_MULTILINE_START = $¢.pos if $multiline;
    }
    $<nibbles> = {@nibbles}
}

method panic (Str $s) {
    die "Recursive panic" if $*IN_PANIC;
    $*IN_PANIC++;
    my $m = "";
    my $here = self;

    my $first = $here.lineof($*LAST_NIBBLE_START);
    my $last = $here.lineof($*LAST_NIBBLE);
    if $first != $last {
        if $here.lineof($here.pos) == $last {
            $m ~= "(Possible runaway string from line $first)\n";
        }
        else {
            $first = $here.lineof($*LAST_NIBBLE_MULTILINE_START);
            $last = $here.lineof($*LAST_NIBBLE_MULTILINE);
            # the bigger the string (in lines), the further back we suspect it
            if $here.lineof($here.pos) - $last < $last - $first  {
                $m ~= "(Possible runaway string from line $first to line $last)\n";
            }
        }
    }

    $m ~= $s;

    if substr(self.orig,$here.pos,1) ~~ /\)|\]|\}|\»/ {
        my $ma = ($m ~~ /(.*?)Confused(.*)/);
        if ($ma) {
            $m = $ma[0] ~ "Unexpected closing bracket" ~ $ma[1];
        }
    }

    $m ~= $here.locmess;
    $m ~= "\n" unless $m ~~ /\n$/;

    if $m ~~ /infix|nofun/ and not $m ~~ /regex/ and not $m ~~ /infix_circumfix/ {
        my @t = $here.suppose( sub { $here.term } );
        my $conf;
        if @t {
            my $endpos = $here.pos;
            my $startpos = @*MEMOS[$endpos]<ws> // $endpos;

            if self.lineof($startpos) != self.lineof($endpos) {
                $conf = "Two terms in a row (previous line missing its semicolon?)";
            }
            elsif @*MEMOS[$here.pos - 1]<baremeth> {
                $conf = "Two terms in a row (method call requires colon or parens to take arguments)";
            }
            elsif @*MEMOS[$here.pos - 1]<arraycomp> {
                $conf = "Two terms in a row (preceding is not a valid reduce operator)";
            }
            else {
                $conf = "Two terms in a row";
            }
        }
        elsif my $type = @*MEMOS[$here.pos - 1]<nodecl> {
            my @t = $here.suppose( sub { $here.variable } );
            if @t {
                my $variable = @t[0].Str;
                $conf = "Bare type $type cannot declare $variable without a preceding scope declarator such as 'my'";
            }
        }
        if $conf && my $ma = ($m ~~ /(.*?)Confused(.*)/) {
            $m = $ma[0] ~ $conf ~ $ma[1];
        }
    }
    elsif my $type = @*MEMOS[$here.pos - 1]<wasname> {
        my @t = $here.suppose( sub { $here.identifier } );
        my $name = @t[0].Str;
        my $s = $*SCOPE ?? "'$*SCOPE'" !! '(missing) scope declarator';
        my $d = $*IN_DECL;
        $d = "$*MULTINESS $d" if $*MULTINESS and $*MULTINESS ne $d;
        my ($a,$b) = $m ~~ /(.*?)Malformed block(.*)/;
        defined($a) and $m = $a ~ "Return type $type is not allowed between '$d' and '$name'; please put it:\n  after the $s but before the '$d',\n  within the signature following the '-->' marker, or\n  as the argument of a 'returns' trait after the signature.$b";
    }

    if @*WORRIES {
        $m ~= "Other potential difficulties:\n  " ~ join( "\n  ", @*WORRIES) ~ "\n";
    }

    $*IN_PANIC--;
    die $m if $*IN_SUPPOSE;     # just throw the exception back to the supposer
    $*IN_PANIC++;

    note $Cursor::RED, '===', $Cursor::CLEAR, 'SORRY!', $Cursor::RED, '===', $Cursor::CLEAR, "\n"
        unless $*FATALS++;
    note $m;
    self.explain_mystery();

    $*IN_PANIC--;
    note "Parse failed\n";
    exit 1;
}

}

augment class STD::P6 {
}

sub infix:<min>($a,$b) { $a > $b ?? $b !! $a }

augment class Cursor {
my %term            = (:dba('term')            , :prec<z=>);
my %methodcall      = (:dba('methodcall')      , :prec<y=>, :assoc<unary>, :uassoc<left>, :fiddly, :!pure);
my %autoincrement   = (:dba('autoincrement')   , :prec<x=>, :assoc<unary>, :uassoc<non>, :!pure);
my %exponentiation  = (:dba('exponentiation')  , :prec<w=>, :assoc<right>, :pure);
my %symbolic_unary  = (:dba('symbolic unary')  , :prec<v=>, :assoc<unary>, :uassoc<left>, :pure);
my %multiplicative  = (:dba('multiplicative')  , :prec<u=>, :assoc<left>, :pure);
my %additive        = (:dba('additive')        , :prec<t=>, :assoc<left>, :pure);
my %replication     = (:dba('replication')     , :prec<s=>, :assoc<left>, :pure);
my %concatenation   = (:dba('concatenation')   , :prec<r=>, :assoc<list>, :pure);
my %junctive_and    = (:dba('junctive and')    , :prec<q=>, :assoc<list>, :pure);
my %junctive_or     = (:dba('junctive or')     , :prec<p=>, :assoc<list>, :pure);
my %named_unary     = (:dba('named unary')     , :prec<o=>, :assoc<unary>, :uassoc<left>, :pure);
my %structural      = (:dba('structural infix'), :prec<n=>, :assoc<non>, :diffy);
my %chaining        = (:dba('chaining')        , :prec<m=>, :assoc<chain>, :diffy, :iffy, :pure);
my %tight_and       = (:dba('tight and')       , :prec<l=>, :assoc<list>);
my %tight_or        = (:dba('tight or')        , :prec<k=>, :assoc<list>);
my %conditional     = (:dba('conditional')     , :prec<j=>, :assoc<right>, :fiddly);
my %item_assignment = (:dba('item assignment') , :prec<i=>, :assoc<right>, :!pure);
my %list_assignment = (:dba('list assignment') , :prec<i=>, :assoc<right>, :sub<e=>, :fiddly, :!pure);
my %loose_unary     = (:dba('loose unary')     , :prec<h=>, :assoc<unary>, :uassoc<left>, :pure);
my %comma           = (:dba('comma')           , :prec<g=>, :assoc<list>, :nextterm<nulltermish>, :fiddly, :pure);
my %list_infix      = (:dba('list infix')      , :prec<f=>, :assoc<list>, :pure);
my %list_prefix     = (:dba('list prefix')     , :prec<e=>, :assoc<unary>, :uassoc<left>);
my %loose_and       = (:dba('loose and')       , :prec<d=>, :assoc<list>);
my %loose_or        = (:dba('loose or')        , :prec<c=>, :assoc<list>);
my %sequencer       = (:dba('sequencer')       , :prec<b=>, :assoc<list>, :nextterm<statement>, :fiddly);
my %LOOSEST         = (:dba('LOOSEST')         , :prec<a=!>);
my %terminator      = (:dba('terminator')      , :prec<a=>, :assoc<list>);
    our $RED    = "\e[31m";
    our $GREEN  = "\e[32m";
    our $YELLOW = "\e[33m";
    our $CLEAR  = "\e[37m";

    # TODO: allow variable :dba()s
    role sym_categorical[$name,$sym,$O] {
        token ::($name) () { $sym $<O>={$O} }
    }
    role bracket_categorical[$name,$sym1,$sym2,$O] {
        token ::($name) () { :my $*GOAL = $sym2; $sym1 {}:s [ :lang($¢.unbalanced($sym2)) <semilist> ] [ $sym2 || <.FAILGOAL($sym2, $name, self.pos)> ] $<O>={$O} }
    }

    method add_categorical($name) {
        # Signature extension, not categorical
        if $name ~~ /^\w+\:\(/ {
            self.add_my_name($name);
            return self;
        }
        my $M = ($name ~~ /^(\w+)\: <?[ \< \« ]> /);
        return self unless $M;
        my $cat = $M[0];
        my $sym = substr($name, $M.to+1, $name.chars-$M.to-2);

        my $O;

        if $cat eq 'infix'            { $O = %additive }
        elsif $cat eq 'prefix'        {
            $O = ($sym ~~ /^\W/) ?? %symbolic_unary !! %named_unary
        }
        elsif $cat eq 'postfix'       { $O = %methodcall }
        elsif $cat eq 'circumfix'     { $O = %term }
        elsif $cat eq 'postcircumfix' { $O = %methodcall }
        elsif $cat eq 'term'          { $O = %term }
        else {
            self.sorry("Cannot extend category:$name with subs");
            return self;
        }

        # XXX to do this right requires .comb and .trans
        if $M = ($sym ~~ /\s+/) {
            my $sym1 = $sym.substr(0, $M.from);
            my $sym2 = $sym.substr($M.to, $sym.chars - $M.to);
            my $cname = $cat ~ ":<$sym1 $sym2>";
            say "Adding categorical handler $cname for $sym1 / $sym2";
            %*LANG<MAIN> = self.WHAT but OUR::bracket_categorical[$cname, $sym1, $sym2, $O];
        } else {
            my $cname = $cat ~ ":<$sym>";
            say "Adding categorical handler $cname for $sym";
            %*LANG<MAIN> = self.WHAT but OUR::sym_categorical[$cname, $sym, $O];
        }
        self.cursor_fresh(%*LANG<MAIN>);
    }

    method canonicalize_name($n) {
        my $M;
        my $name = $n;
        if $M = $name ~~ /^(< $ @ % & >)( \^ || \: <!before \:> )(.*)/ {
            $name = $M[0] ~ $M[2];
        }
        if $name.chars >= 2 && substr($name, $name.chars - 2, 2) ~~ / \: < U D _ > / {
            $name = $name.substr(0, $name.chars - 2);
        }
        return $name unless $name ~~ /::/;
        self.panic("Can't canonicalize a run-time name at compile time: $name") if $name ~~ / '::(' /;

        if $M = $name ~~ /^ (< $ @ % & > < ! * = ? : ^ . >?) (.* '::') (.*) $/ {
            $name = $M[1] ~ "<" ~ $M[0] ~ $M[2] ~ ">";
        }
        my $vname;
        if $M = $name ~~ /^(.*) '::<' (.*) '>' $/ {
            $name = $M[0].Str;
            $vname = $M[1].Str;
        }
        my @components;
        while $M = $name ~~ / '::' / {
            push @components, $name.substr(0, $M.to);
            $name = substr($name, $M.to);
        }
        push @components, $name;
        shift(@components) while @components and @components[0] eq '';
        if (defined $vname) {
            @components[+@components - 1] ~= '::' if @components and @components[+@components - 1] !~~ /\:\:$/;
            push(@components, $vname) if defined $vname;
        }
        @components;
    }

    method locmess () {
        my $pos = self.pos;
        my $line = self.lineof($pos);

        if $pos >= chars(self.orig) {
            $line = $line ~ " (EOF)";
        }

        my $pre = substr(self.orig, 0, $pos);
        my $prel = chars($pre) min 40;
        $pre = substr($pre, chars($pre)-$prel, $prel);
        if my $M = ($pre ~~ /^.*\n/) {
            $pre = substr($pre, $M.to);
        }
        $pre = '<BOL>' if $pre eq '';
        my $post = substr(self.orig, $pos, (chars(self.orig)-$pos) min 40);
        if $M = ($post ~~ /\n/) {
            $post = substr($post,0,$M.from);
        }
        $post = '<EOL>' if $post eq '';
        " at " ~ $*FILE<name> ~ " line $line:\n------> " ~ $Cursor::GREEN ~
            $pre ~ $Cursor::YELLOW ~ "\x23CF" ~ $Cursor::RED ~ $post ~
            $Cursor::CLEAR;
    }

    method line {
        self.lineof(self.pos);
    }

    method lineof ($p) {
        return 1 unless defined $p;
        my $line = @*MEMOS[$p]<L>;
        return $line if $line;
        $line = 1; my $pos = 0;
        self.orig ~~ / [ \n { @*MEMOS[$pos++]<L> = $line++ } ||
                         .  { @*MEMOS[$pos++]<L> = $line } ]* /;
        @*MEMOS[$pos++]<L> = $line;
        return @*MEMOS[$p]<L> // 0;
    }

    method SETGOAL { }
    method FAILGOAL ($stop, $name, $startpos) {
        my $s = "'$stop'";
        $s = '"\'"' if $s eq "'''";
        self.panic("Unable to parse $name" ~ self.cursor($startpos).locmess ~ "\nCouldn't find final $s; gave up");
    }

    method deb(*@str) { note @str }

    method cursor_fresh($k = self) { Q:CgOp {
        (ns (cursor_fresh (cast cursor (@ {self})) (@ {$k})))
    } }
    method cursor_force($pos) {
        $*HIGHWATER = $pos;
        self.cursor($pos);
    }

    method mixin($role) { self.cursor_fresh(self.WHAT but $role) }

    method load_lex($) {
        # NYI
        my $id = "MY:file<NULL.pad>:line(1):pos(0)";
        my $core = Stash.new('!id' => [$id], '!file' => 'NULL.pad',
            '!line' => 1);
        Stash.new('CORE' => $core, 'MY:file<NULL.pad>' => $core,
            'SETTING' => $core, $id => $core);
    }

    method mark_sinks(@sl) {
        #NYI
        self
    }
}

{
    my $*SETTINGNAME = 'NULL';
    my @*MEMOS;
    my $*FILE = { name => '(eval)' };
    my @*ACTIVE;
    my $*HIGHWATER = 0;
    my $*HIGHEXPECT = {};
    my $*HIGHMESS = "";
    my $*LASTSTATE = 0;
    my $*IN_PANIC = 0;
    my $*IN_SUPPOSE = 0;
    my $*FATALS = 0;

    $STD::DEBUG::EXPR = False;
    $STD::DEBUG::symtab = False;

    my $*LAST_NIBBLE = 0;
    my $*LAST_NIBBLE_START = 0;
    my $*LAST_NIBBLE_MULTILINE = 0;
    my $*LAST_NIBBLE_MULTILINE_START = 0;
    my $*GOAL = "(eof)";
    my $*SETTING; my $*CORE; my $*GLOBAL; my $*UNIT; my $*YOU_WERE_HERE;
    my $*CCSTATE; my $*BORG; my %*RX; my $*XACT; my $*VAR; my $*IN_REDUCE;
    STD.parse($*IN.slurp);
}
say "OK";
