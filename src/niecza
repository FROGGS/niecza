use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use JSYNC;
use Metamodel;
use NAMOutput;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

augment class STD {
method lookup_lex($name, $lex?) {
    ($lex // $*CURLEX)<!sub>.lookup_lex($name, $*FILE<name>, self.lineof(self.pos));
}
}

augment class Op::ForLoop {
    method statement_level() {
        my $body = $*CURLEX<!sub>.lookup_lex($!sink)[4];
        my $var = [ map { ::GLOBAL::NieczaActions.gensym },
            0 ..^ $body.count ];
        ::Op::ImmedForLoop.new(source => $!source, var => $var,
            sink => ::GLOBAL::OptBeta.make_call($!sink,
                map { ::Op::LetVar.new(name => $_) }, @$var));
    }
}

augment class NieczaActions {
method thunk_sub($code, :$params = [], :$name, :$class, :$ltm) {
    my $n = $*unit.create_sub(
        name => $name // 'ANON',
        class => $class // 'Block',
        outer => $*CURLEX<!sub>,
        cur_pkg => $*CURLEX<!sub>.cur_pkg,
        in_class => $*CURLEX<!sub>.in_class);
    $n.set_transparent;
    say $ltm.perl if $ltm;
    $n.set_ltm($ltm) if $ltm;
    $n.add_my_name($_, :noinit) for @$params;
    $n.set_signature(Sig.simple(@$params));
    $n.finish($code);
    $n;
}
method check_hash($/) {
    my $do = $<pblock><blockoid>.ast;

    return False unless $do.^isa(::Op::StatementList);
    return True if $do.children == 0;
    return False if $do.children > 1;

    $do = $do.children[0];
    my @bits = $do.^isa(::Op::SimpleParcel) ?? @( $do.items ) !! $do;

    return True if @bits[0].^isa(::Op::SimplePair);

    if @bits[0].^isa(::Op::CallSub) &&
            @bits[0].invocant.^isa(::Op::Lexical) &&
            @bits[0].invocant.name eq '&infix:<=>>' {
        return True;
    }

    if @bits[0].^isa(::Op::Lexical) && substr(@bits[0].name,0,1) eq '%' {
        return True;
    }

    return False;
}
method statement_prefix:gather ($/) {
    make ::Op::Gather.new(|node($/),
        var => self.block_expr($/, $<blast>.ast).name);
}
method add_attribute($/, $name, $sigil, $accessor, $type) {
    my $ns = $*CURLEX<!sub>.body_of;
    $/.CURSOR.sorry("Attribute $name declared outside of any class"),
        return ::Op::StatementList.new unless $ns;
    $/.CURSOR.sorry("Attribute $name declared in an augment"),
        return ::Op::StatementList.new if defined $*AUGMENT_BUFFER;

    if !$ns.CAN('add_attribute') {
        $/.CURSOR.sorry("A $ns.WHAT() cannot have attributes");
        return ::Op::StatementList.new
    }

    my $nb = $*unit.create_sub(
        outer      => $*CURLEX<!sub>,
        name       => $name,
        cur_pkg    => $*CURLEX<!sub>.cur_pkg,
        class      => 'Method');
    $nb.set_transparent;
    $nb.add_my_name('self', noinit => True);
    $nb.set_signature(Sig.simple('self'));
    $nb.finish(::Op::GetSlot.new(name => $name,
        object => ::Op::Lexical.new(name => 'self')));
    $*CURLEX<!sub>.create_static_pad; # for protosub instance
    my $at;

    $/.CURSOR.trymop({
        my $ac = self.gensym;
        $nb.set_outervar($ac);
        $*CURLEX<!sub>.add_my_sub($ac, $nb, |mnode($/));
        $ns.add_attribute($name, $sigil, +$accessor, $type, |mnode($/));
        $ns.add_method(::Metamodel::SubVisibility::private, $name, $nb,
            |mnode($/));
        if $accessor {
            $ns.add_method(0, $name, $nb, |mnode($/));
        }
        $at = True;
    });

    $at ?? ::Op::Attribute.new(name => $name, initializer => $ns) !!
        ::Op::StatementList.new;
}
method install_sub($/, $sub, :$multiness is copy, :$scope is copy, :$class,
        :$longname, :$method_type is copy, :$contextual is copy) {

    $multiness ||= 'only';
    my ($pkg, $name) = self.process_name($longname, :declaring);

    if !$scope {
        if !defined($name) {
            $scope = 'anon';
        } elsif defined($pkg) {
            $scope = 'our';
        } elsif defined($method_type) {
            $scope = 'has';
        } else {
            $scope = 'my';
        }
    }

    if $class eq 'Regex' {
        my $/;
        $*CURLEX<!name> = $name;
        $*CURLEX<!cleanname !sym> =
            !defined($name) ?? (Str, Str) !!
            ($name ~~ /\:sym\<(.*)\>/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name ~~ /\:(\w+)/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name, Str);
        $multiness = 'multi' if defined $*CURLEX<!sym>;
        $*CURLEX<!multi> = $multiness;
    }

    if $scope ne 'my' && $scope ne 'our' && $scope ne 'anon' && $scope ne 'has' {
        $/.CURSOR.sorry("Illegal scope $scope for subroutine");
        $scope = 'anon';
    }

    if $scope eq 'has' && !defined($method_type) {
        $/.CURSOR.sorry('has scope-type is only valid for methods');
        $scope = 'anon';
    }

    if $scope ne 'anon' && !defined($name) {
        $/.CURSOR.sorry("Scope $scope requires a name");
        $scope = 'anon';
    }

    if $scope ne 'our' && defined($pkg) {
        $/.CURSOR.sorry("Double-colon-qualified subs must be our");
        $scope = 'our';
    }

    if $scope eq 'anon' && $multiness ne 'only' {
        $/.CURSOR.sorry("Multi routines must have a name");
        $multiness = 'only';
    }

    if $contextual && (defined($method_type) || $scope ne 'my') {
        $/.CURSOR.sorry("Context-named routines must by purely my-scoped");
        $contextual = False;
    }

    $method_type = Str if $scope eq 'anon';

    my $method_targ = $method_type && $sub.outer.body_of;
    if !$method_targ && defined($method_type) {
        $/.CURSOR.sorry("Methods must be used in some kind of package");
        $method_type = Str;
    }

    if $method_targ && !$method_targ.CAN('add_method') {
        $/.CURSOR.sorry("A {$method_targ.kind} cannot have methods added");
        $method_type = Str;
        $method_targ = Any;
    }

    if $name ~~ Op && (!defined($method_type) || $scope ne 'has' ||
            $method_targ.kind ne 'prole') {
        $/.CURSOR.sorry("Computed names are only implemented for parametric roles");
        $name = "placeholder";
    }

    my $bindlex = $scope eq 'my' || ($scope eq 'our' && !$pkg);

    $sub.set_name(defined($method_type) ?? $method_targ.name ~ "." ~ $name !!
        ($name // 'ANON'));
    $sub.set_class($class);

    my $std = $/.CURSOR;
    {
        my $/;
        if $sub.name ~~ /^(\w+)\:\<(.*)\>$/ {
            my %new = %( $std.default_O(~$0, ~$1) );
            $sub.set_extend('prec', %new.kv);
        }
    }

    my Str $symbol;
    $/.CURSOR.trymop({
        if $bindlex && $class eq 'Regex' {
            $symbol = '&' ~ $name;
            my $proto = $symbol;
            $proto ~~ s/\:.*//;
            $sub.outer.add_dispatcher($proto, |mnode($/))
                if $multiness ne 'only' && !$sub.outer.has_lexical($proto);
            $symbol ~= ":(!proto)" if $multiness eq 'proto';
        } elsif $bindlex {
            $symbol = '&' ~ $name;
            $/.CURSOR.check_categorical($symbol);
            if $multiness ne 'only' && !$sub.outer.has_lexical($symbol) {
                $sub.outer.add_dispatcher($symbol, |mnode($/))
            }

            given $multiness {
                when 'multi' { $symbol ~= ":({ self.gensym })"; }
                when 'proto' { $symbol ~= ":(!proto)"; }
                default {
                    $/.CURSOR.check_categorical($symbol);
                }
            }
        } else {
            $symbol = self.gensym;
        }

        $sub.set_outervar($symbol);
        $sub.set_methodof(defined($method_type) ?? $method_targ !! Any);
        $sub.outer.add_my_sub($symbol, $sub, |mnode($/));

        if $multiness ne 'only' || $scope eq 'our' || $method_type {
            $/.CURSOR.mark_used($symbol);
        }

        if defined($method_type) || $scope eq 'our' {
            $sub.outer.create_static_pad;
        }

        if defined($method_type) {
            my $mode = 0;
            given $method_type {
                when 'sub'      { $mode += 2 }
                when 'normal'   { $mode += 0 }
                when 'private'  { $mode += 1 }
                default         { die "Unimplemented method type $_" }
            }
            given $multiness {
                when 'only'     { $mode += 0 }
                when 'proto'    { $mode += 4 }
                when 'multi'    { $mode += 8 }
                default         { die "Unimplemented multiness $_" }
            }
            if defined $*AUGMENT_BUFFER {
                push $*AUGMENT_BUFFER, $mode, $name, $symbol;
            } else {
                $method_targ.add_method($mode, $name, $sub, |mnode($/));
            }
        }

        if $scope eq 'our' {
            $*unit.bind(($pkg // $sub.outer.cur_pkg).who,
                "&$name", $sub);
        }
    });
}

method process_block_traits($/, @tr) {
    my $sub = $*CURLEX<!sub>;
    my $pack = $sub.body_of;
    for @tr -> $T {
        my $tr = $T.ast;
        if $pack && $tr<name> {
            my $super = $tr<name>;

            $T.CURSOR.sorry("superclass $super.name() declared outside of any class"),
                next unless $sub.body_of;
            $T.CURSOR.sorry("superclass $super.name() declared in an augment"),
                next if defined $*AUGMENT_BUFFER;
            $T.CURSOR.sorry("cannot declare a superclass in this kind of package"),
                next if !$pack.CAN('add_super');

            $T.CURSOR.trymop({
                $pack.add_super($super);
            });
        } elsif $pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports($pack.name, $pack, @exports);
        } elsif !$pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports('&'~$sub.name, $sub, @exports);
            $sub.strong_used = True;
            $sub.outer.create_static_pad;
            $/.CURSOR.mark_used($sub.outervar)
                if defined $sub.outervar;
        } elsif !$pack && $tr<nobinder> {
            $sub.set_signature(Any);
        } elsif !$pack && grep { defined $tr{$_} }, <looser tighter equiv> {
            my $rel = $tr.keys.[0];
            my $to  = $tr.values.[0];
            $to = $to.inside if $to ~~ ::Op::Paren;
            $to = $to.children[0] if $to ~~ ::Op::StatementList && $to.children == 1;

            my $oprec;
            if $to ~~ ::Op::Lexical {
                $oprec = $T.CURSOR.function_O($to.name);
            } elsif $to ~~ ::Op::StringLiteral && $sub.name ~~ /^(\w+)\:\<.*\>$/ {
                $oprec = $T.CURSOR.cat_O(~$0, $to.text);
            } else {
                $T.CURSOR.sorry("Cannot interpret operator reference");
                next;
            }
            unless $sub.get_extend('prec') {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            unless $oprec {
                $T.CURSOR.sorry("No precedence available for reference target");
                next;
            }
            if $rel eq 'equiv' {
                $sub.set_extend('prec', $oprec.kv);
            } else {
                my %prec = $sub.get_extend('prec');
                %prec<prec> = $oprec.<prec>;
                %prec<prec> ~~ s/\=/<=/ if $rel eq 'looser';
                %prec<prec> ~~ s/\=/>=/ if $rel eq 'tighter';
                $sub.set_extend('prec', %prec.kv);
            }
        } elsif !$pack && $tr<assoc> {
            my $arg = ~self.trivial_eval($T, $tr<assoc>);
            my %prec = $sub.get_extend('prec');
            unless %prec {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            unless $arg eq any < left right non list unary chain > {
                $T.CURSOR.sorry("Invalid associativity $arg");
                next;
            }
            %prec<assoc> = $arg;
            $sub.set_extend('prec', %prec.kv);
        } elsif !$pack && $tr<Niecza::absprec> {
            my $arg = ~self.trivial_eval($T, $tr<Niecza::absprec>);
            my %prec = $sub.get_extend('prec');
            unless %prec {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            %prec<prec> = $arg;
            %prec<dba> = "like $sub.name()";
            $sub.set_extend('prec', %prec.kv);
        } elsif !$pack && $tr<Niecza::builtin> {
            $sub.set_extend('builtin',
                self.trivial_eval($T, $tr<Niecza::builtin>));
        } elsif !$pack && $tr<return_pass> {
            $sub.set_return_pass;
        } elsif !$pack && $tr<of> {
        } elsif !$pack && $tr<rw> {
        } elsif !$pack && $tr<unsafe> {
            $sub.set_unsafe;
        } else {
            $T.CURSOR.sorry("Unhandled trait $tr.keys[0] for this context");
        }
    }
}
method regex_def($/) {
    my $endsym;
    for map *.ast, @$<trait> -> $t {
        if $t<unary> || $t<binary> || $t<defequiv> || $t<of> {
            # Ignored for now
        }
        elsif defined $t<endsym> {
            $endsym = $t<endsym>;
        }
        else {
            $/.CURSOR.sorry("Unhandled regex trait $t.keys.[0]");
        }
    }

    if $*CURLEX<!multi> eq 'proto' {
        if ($<signature> && $<signature>[0].ast.params != 1) ||
                !$<regex_block><onlystar> {
            $/.CURSOR.sorry('Only {*} protoregexes with no parameters are supported');
        }
        @*MEMOS[0]<proto_endsym>{$*CURLEX<!cleanname>} = $endsym
            if defined $*CURLEX<!cleanname>;
    } else {
        $endsym //= @*MEMOS[0]<proto_endsym>{$*CURLEX<!cleanname>} if
            defined $*CURLEX<!cleanname>;
    }

    my $ast = $<regex_block>.ast;
    if $*CURLEX<!multi> eq 'proto' {
        $ast = ::RxOp::ProtoRedis.new(name => $*CURLEX<!name>);
    }

    {
        my $*paren = 0;
        my $*symtext = $*CURLEX<!sym>;
        my $*endsym = $endsym;
        my $*dba = $*CURLEX<!name> // 'anonymous regex';
        $ast.check;
    }
    my @lift = $ast.oplift;
    my $ltm = ::GLOBAL::OptRxSimple.run_lad($ast.lad);
    say $ltm.perl;
    $*CURLEX<!sub>.set_ltm($ltm);
    ($ast, my $mb) = ::GLOBAL::OptRxSimple.run($ast);
    $*CURLEX<!sub>.finish(::Op::RegexBody.new(|node($/), pre => @lift,
        name => ($*CURLEX<!name> // ''), rxop => $ast, canback => $mb));
    make ::Op::Lexical.new(|node($/), name => $*CURLEX<!sub>.outervar);
}

method whatever_postcheck($/, $st, $term) {
    if @$st {
        my $slot = self.gensym;

        my $body = $*unit.create_sub(
            outer => $*CURLEX<!sub>,
            class => 'WhateverCode',
            in_class => $*CURLEX<!sub>.in_class,
            cur_pkg => $*CURLEX<!sub>.cur_pkg);

        $body.add_my_name($_, :noinit) for @$st;
        $body.set_signature(::GLOBAL::Sig.new(params => [
            map { ::Sig::Parameter.new(slot => $_, name => $_) }, @$st ]));
        $body.set_transparent;
        $body.finish($term);

        $*CURLEX<!sub>.add_my_sub($slot, $body);

        ::Op::WhateverCode.new(ops => Any, vars => $st, :$slot, |node($/));
    } else {
        $term;
    }
}

method variable_declarator($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }

    my $scope = $*SCOPE // 'my';

    my $start;
    for @$<trait> -> $t {
        if $t.ast<rw> {
        } elsif $t.ast<dynamic> {
        } elsif $t.ast<start> && $*SCOPE eq 'state' {
            $start = $t.ast<start>;
        } else {
            $/.CURSOR.sorry("Trait $t.ast.keys.[0] not available on variables");
        }
    }
    if $<post_constraint> || $<postcircumfix> || $<semilist> {
        $/.CURSOR.sorry("Postconstraints, and shapes on variable declarators NYI");
    }

    if $scope eq 'augment' || $scope eq 'supersede' {
        $/.CURSOR.sorry("Illogical scope $scope for simple variable");
    }

    my $typeconstraint;
    if $*OFTYPE {
        ($typeconstraint) = self.process_name($*OFTYPE<longname>);
        $/.CURSOR.sorry("Common variables are not unique definitions and may not have types") if $scope eq 'our';
    }

    my $v = $<variable>.ast;
    my $t = $v<twigil>;
    my $list = $v<sigil> && $v<sigil> eq '@';
    my $hash = $v<sigil> && $v<sigil> eq '%';
    if ($t && defined "?=~^:".index($t)) {
        $/.CURSOR.sorry("Variables with the $t twigil cannot be declared " ~
            "using $scope; they are created " ~
            ($t eq '?' ?? "using 'constant'." !!
             $t eq '=' ?? "by parsing POD blocks." !!
             $t eq '~' ?? "by 'slang' definitions." !!
             "automatically as parameters to the current block."));
    }

    if $scope ne 'has' && ($t eq '.' || $t eq '!') {
        $/.CURSOR.sorry("Twigil $t is only valid on attribute definitions ('has').");
    }

    if !defined($v<name>) && $scope ne any < my anon state > {
        $/.CURSOR.sorry("Scope $scope requires a name");
    }

    if defined($v<pkg>) || defined($v<iname>) {
        $/.CURSOR.sorry(":: syntax is only valid when referencing variables, not when defining them.");
    }

    my $name = defined($v<name>) ?? $v<sigil> ~ $v<twigil> ~ $v<name> !! "";
    # otherwise identical to my
    my $slot = ($scope eq 'anon' || !defined($v<name>))
        ?? self.gensym !! $name;

    if $scope eq 'has' {
        make self.add_attribute($/, $v<name>, $v<sigil>, $t eq '.',
            $typeconstraint);
    } elsif $scope eq 'state' {
        $/.CURSOR.trymop({
            $/.CURSOR.check_categorical($slot);
            $*CURLEX<!sub>.add_state_name($slot, self.gensym, :$list,
                :$hash, :$typeconstraint, |mnode($/));
        });
        make Op::StateDecl.new(|node($/), inside =>
            Op::Lexical.new(|node($/), name => $slot, :$list, :$hash));
    } elsif $scope eq 'our' {
        make self.package_var($/, $slot, $slot, ['OUR']);
    } else {
        $/.CURSOR.trymop({
            $/.CURSOR.check_categorical($slot);
            $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash,
                :$typeconstraint, |mnode($/));
        });
        make ::Op::Lexical.new(|node($/), name => $slot, :$list, :$hash);
    }

    if $start {
        my $cv = self.gensym;
        $*CURLEX<!sub>.add_state_name(Str, $cv);
        make mklet($/.ast, -> $ll {
            Op::StatementList.new(|node($/), children => [
                Op::Start.new(condvar => $cv, body =>
                    self.inliney_call($/, $start, $ll)), $ll ]) });
    }
}

method INFIX($/) {
    my $fn = $<infix>.ast;
    my ($st,$lhs,$rhs) = self.whatever_precheck($fn, $<left>.ast, $<right>.ast);

    make $fn.with_args($/, $lhs, $rhs);

    if $fn.assignish {
        # Assignments to has and state declarators are rewritten into
        # an appropriate phaser
        if $lhs.^isa(Op::StateDecl) {
            my $cv = self.gensym;
            $*CURLEX<!sub>.add_state_name(Str, $cv);
            make mklet($lhs, -> $ll {
                Op::StatementList.new(|node($/), children => [
                    Op::Start.new(condvar => $cv, body =>
                        $fn.with_args($/, $ll, $rhs)),
                    $ll]) });
        }
        elsif $lhs.^isa(::Op::Attribute) {
            my $init = self.thunk_sub($rhs,
                :name($lhs.initializer.name ~ " init"));
            $init.set_outervar(my $ov = self.gensym);
            $*CURLEX<!sub>.add_my_sub($ov, $init);
            $lhs.initializer.add_initializer($lhs.name, $init);
            make ::Op::StatementList.new;
        }
        elsif $lhs.^isa(::Op::ConstantDecl) && !$lhs.init {
            my $sig = substr($lhs.name, 0, 1);
            if defined '$@&%'.index($sig) {
                self.init_constant($lhs, self.docontext($/, $sig, $rhs));
            } else {
                self.init_constant($lhs, $rhs);
            }
            make $lhs;
        }
    }
    make self.whatever_postcheck($/, $st, $/.ast);
}

method make_constant_into($/, $pkg, $name, $rhs) {
    my $slot = self.gensym;
    $/.CURSOR.trymop({
        $*CURLEX<!sub>.add_common_name($slot, $pkg, $name, |mnode($/));
    });
    self.init_constant(::Op::ConstantDecl.new(|node($/), name => $slot,
        init => False), $rhs);
}

method init_constant($con, $rhs) {
    my $body = self.thunk_sub(
        ::Op::LexicalBind.new(name => $con.name, :$rhs),
        name => "$con.name() init");
    $body.outer.create_static_pad;
    $con.init = True;
    $body.set_phaser(+::Metamodel::Phaser::UNIT_INIT);
    $con;
}

method type_declarator:enum ($/) {
    my $scope = $*SCOPE || 'our';

    my @exports;
    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } else {
            $/.CURSOR.sorry("Unsupported enum trait $t.keys()");
        }
    }

    my @pairs = self.trivial_eval($/, $<term>.ast);
    my $last = -1;
    my ($has_ints, $has_strs);
    for @pairs {
        if $_ !~~ Pair {
            my $key = $_;
            my $value = $last.succ;
            $_ = $key => $value;
        }
        given $last = .value {
            when Int { $has_ints = True; }
            when Str { $has_strs = True; }
            default  { $/.CURSOR.sorry("Enum values must be Int or Str"); }
        }
    }
    if $has_ints && $has_strs {
        $/.CURSOR.sorry("Enum may not contain both Int and Str values");
    }

    my ($basetype) = self.process_name($*OFTYPE<longname>);
    $basetype //= $*CURLEX<!sub>.compile_get_pkg('CORE', $has_strs ?? 'Str' !! 'Int');
    my $kindtype = $has_strs ?? 'StrBasedEnum' !! 'IntBasedEnum';

    if $<name> && $<name>.reduced eq 'longname' && $scope ne 'anon' {
        # Longnamed enum is a kind of type definition

        my ($lexvar, $obj);
        $/.CURSOR.trymop({
            ($lexvar, $obj) = self.do_new_package($/, :$scope,
                class => 'class', name => $<longname>, :@exports);

            $obj.add_super($*CURLEX<!sub>.compile_get_pkg($kindtype));
            $obj.add_super($basetype);

            my $nb = $*unit.create_sub(
                outer      => $*CURLEX<!sub>,
                name       => $obj.name ~ '.enums',
                cur_pkg    => $*CURLEX<!sub>.cur_pkg,
                class      => 'Method');

            $nb.set_transparent;

            my $nbvar = self.gensym;
            $nb.add_my_name('self', noinit => True);
            $nb.set_signature(Sig.simple('self'));
            $nb.finish(self.init_constant(
                self.make_constant($/, 'anon', Any),
                ::Op::CallMethod.new(name => 'new',
                    receiver => mklex($/, 'EnumMap'), args => [$<term>.ast])));
            $*CURLEX<!sub>.create_static_pad;
            $*CURLEX<!sub>.add_my_sub($nbvar, $nb, |mnode($/));
            $obj.add_method(0, 'enums', $nb, |mnode($/));
            $obj.close;

            for @pairs {
                self.make_constant_into($/, $obj, .key, rhs =>
                    ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                        args => [ ::Op::StringLiteral.new(text => .key) ]));
            }

            for @pairs {
                self.init_constant(self.make_constant($/, $scope, .key),
                    ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                        args => [ ::Op::StringLiteral.new(text => .key) ]));
            }
        });

        make mklex($/, $lexvar);
    } else {
        make self.init_constant(
            self.make_constant($/, $<name> ?? $scope !! 'anon', ~$<name>),
            ::Op::CallMethod.new(|node($/), name => 'new',
                receiver => mklex($/, 'EnumMap'),
                args => [$<term>.ast])),
    }
}

sub phaser($/, $ph, :$unique, :$topic, :$csp) {
    my $sub = ($<blast> // $<block>).ast;

    if $unique {
        $/.CURSOR.sorry("Limit one $ph phaser per block, please.")
            if $sub.outer.contains_phaser(+::Metamodel::Phaser.($ph));
        my $code = ($<blast><statement> // $<blast><block><blockoid> // $<block><blockoid>).ast;
        # TODO avoid double finishing
        $sub.finish(::Op::CatchyWrapper.new(inner => $code));
    }

    $sub.outer.noninlinable;

    if $topic {
        $sub.has_lexical('$_') || $sub.add_my_name('$_');
        $sub.parameterize_topic;
        $sub.set_signature(Sig.simple('$_'));
    }
    $*CURLEX<!sub>.create_static_pad if $csp;
    $sub.set_phaser(+::Metamodel::Phaser.($ph));
    make ::Op::StatementList.new;
}
method statement_control:CATCH ($/) { phaser($/, 'CATCH', :unique, :topic) }
method statement_control:CONTROL ($/) { phaser($/, 'CONTROL', :unique, :topic) }
method statement_prefix:PRE ($/) { phaser($/, 'PRE') }
method statement_prefix:POST ($/) { phaser($/, 'POST', :topic) }
method statement_prefix:KEEP ($/) { phaser($/, 'KEEP', :topic) }
method statement_prefix:UNDO ($/) { phaser($/, 'UNDO', :topic) }
method statement_prefix:ENTER ($/) { phaser($/, 'ENTER') }
method statement_prefix:LEAVE ($/) { phaser($/, 'LEAVE', :topic) }

method statement_prefix:CHECK ($/) { phaser($/, 'CHECK', :csp) }
method statement_prefix:END ($/) { phaser($/, 'END', :csp) }
method statement_prefix:INIT ($/) { phaser($/, 'INIT', :csp) }

# XXX 'As soon as possible' isn't quite soon enough here
method statement_prefix:BEGIN ($/) {
    $*CURLEX<!sub>.create_static_pad;
    $<blast>.ast.set_phaser(+::Metamodel::Phaser::UNIT_INIT);
    make ::Op::StatementList.new;

    # MAJOR HACK - allows test code like BEGIN { @*INC.push: ... } to work
    repeat while False {
        my $c = ($<blast><statement> || $<blast><block><blockoid>).ast;

        last unless $c ~~ Op::StatementList;
        last unless $c.children == 1;
        my $d = $c.children.[0];
        last unless $d ~~ Op::CallMethod;
        last unless $d.receiver ~~ Op::ContextVar;
        last unless $d.receiver.name eq '@*INC';
        last if $d.private || $d.ismeta;
        last unless $d.name eq any <push unshift>;
        last unless +$d.getargs == 1;
        last unless defined my $str = self.trivial_eval($/, $d.getargs.[0]);
        @*INC."$d.name()"($str);
    }
}


method package_var($/, $slot, $name, $path) {
    $/.CURSOR.trymop({
        $/.CURSOR.check_categorical($slot);
        my $ref = $path.^can('FALLBACK') ?? $path !!
            $*CURLEX<!sub>.compile_get_pkg(@$path, :auto);
        $*CURLEX<!sub>.add_common_name($slot, $ref, $name, |mnode($/));
        $/.CURSOR.mark_used($slot);
    });
    ::Op::Lexical.new(|node($/), name => $slot);
}

method default_value($/) { make self.thunk_sub($<EXPR>.ast) }
method parameter($/) {
    my $rw = ?( $*SIGNUM && $*CURLEX<!rw_lambda> );
    my $copy = False;
    my $sorry;
    my $slurpy = False;
    my $slurpycap = False;
    my $optional = False;
    my $rwt = False;
    my $type;

    if $<type_constraint> {
        ($type) = self.process_name($<type_constraint>[0]<typename><longname>);
    }

    for @( $<trait> ) -> $trait {
        if $trait.ast<rw> { $rw = True }
        elsif $trait.ast<copy> { $copy = True }
        elsif $trait.ast<parcel> { $rwt = True }
        elsif $trait.ast<readonly> { $rw = False }
        else {
            $trait.CURSOR.sorry('Unhandled trait ' ~ $trait.ast.keys.[0]);
        }
    }

    if $<post_constraint> > 0 {
        $/.sorry('Parameter post constraints NYI');
        make ::Sig::Parameter.new;
        return Nil;
    }

    my $default = $<default_value> ?? $<default_value>[0].ast !! Any;
    $default.set_name("$/ init") if $default;

    my $tag = $<quant> ~ ':' ~ $<kind>;
    if    $tag eq '**:*' { $sorry = "Slice parameters NYI" }
    elsif $tag eq '*:*'  { $slurpy = True }
    elsif $tag eq '|:*'  { $slurpycap = True }
    elsif $tag eq '\\:!' { $rwt = True }
    elsif $tag eq '\\:?' { $rwt = True; $optional = True }
    elsif $tag eq ':!'   { }
    elsif $tag eq ':*'   { $optional = True }
    elsif $tag eq ':?'   { $optional = True }
    elsif $tag eq '?:?'  { $optional = True }
    elsif $tag eq '!:!'  { }
    elsif $tag eq '!:?'  { $optional = True }
    elsif $tag eq '!:*'  { }
    else                 { $sorry = "Confusing parameters ($tag)" }
    if $sorry { $/.CURSOR.sorry($sorry); }
    my $p = $<param_var> // $<named_param>;

    if defined $p.ast<slot> {
        # TODO: type constraint here
    }

    make ::Sig::Parameter.new(name => ~$/, mdefault => $default,
        :$optional, :$slurpy, :$rw, tclass => $type,
        :$slurpycap, rwtrans => $rwt, is_copy => $copy, |$p.ast);
}
method package_def ($/) {
    my $sub = $*CURLEX<!sub>;
    my $obj = $sub.body_of;

    my $bodyvar = self.gensym;
    $sub.outer.add_my_sub($bodyvar, $sub);
    my $ast = ($<blockoid> // $<statementlist>).ast;

    if defined $*AUGMENT_BUFFER {
        # generate an INIT block to do the augment
        my $ph = $*unit.create_sub(
            outer      => $sub,
            cur_pkg    => $sub.cur_pkg,
            name       => "phaser-$sub.name()",
            class      => 'Code',
            run_once   => $sub.run_once);

        my @ops;
        for @( $*AUGMENT_BUFFER ) -> $mode, $name, $sym {
            push @ops, CgOp._addmethod(CgOp.letvar('!mo'), $mode,
                CgOp.str($name), CgOp.fetch(CgOp.scopedlex($sym)));
        }
        my $fin = CgOp.letn('!mo', CgOp.class_ref('mo', $obj),
            @ops, CgOp._invalidate(CgOp.letvar('!mo')), CgOp.corelex('Nil'));

        $ph.finish(::Op::CgOp.new(op => $fin));
        $sub.create_static_pad;
        $ph.set_phaser(+::Metamodel::Phaser::INIT);

        make ::Op::CallSub.new(|node($/), invocant => mklex($/, $bodyvar));
    }
    else {
        if $<stub> {
            $*unit.stub_stash($/.from, $obj);

            make mklex($/, $*CURLEX<!sub>.outervar);
        }
        else {
            $/.CURSOR.trymop({ $obj.close; });

            if $obj.kind eq 'prole' {
                # return the frame object so that role instantiation can
                # find the cloned methods
                $ast = ::Op::StatementList.new(|node($/), children => [
                    $ast, mkcall($/, '&callframe') ]);
                $sub.create_static_pad;
                $obj.set_instantiation_block($sub);

                make mklex($/, $*CURLEX<!sub>.outervar);
            } else {
                make ::Op::StatementList.new(|node($/), children => [
                    ::Op::CallSub.new(invocant => mklex($/, $bodyvar)),
                    ::Op::Lexical.new(name => $*CURLEX<!sub>.outervar) ]);
            }
        }
    }

    $sub.finish($ast);
}

}

CgOp._register_ops: < who sc_root sc_indir temporize _addmethod _invalidate
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => [ NieczaPassSimplifier.new ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
