# vim: ft=perl6
use MONKEY_TYPING;

use STD;
use Stash;
use NAME;
use JSYNC;

sub _subst($M is rw, $text is rw, $regex, $repl) {
    $text = $text.Str;
    $M = ($text ~~ $regex);
    if $M {
        $text = $text.substr(0, $M.from) ~
            (($repl ~~ Str) ?? $repl !! $repl()) ~
                $text.substr($M.to, $text.chars - $M.to);
    }
    ?$M;
}

augment class Cool {
    method lc() { Q:CgOp { (box Str (str_tolower (unbox str (@ {self.Str})))) }}
    method uc() { Q:CgOp { (box Str (str_toupper (unbox str (@ {self.Str})))) }}
}

sub lc($s) { $s.Str.lc }
sub uc($s) { $s.Str.uc }

augment class List {
}

augment class Mu {
}

augment class Cool {
}

augment class Any {
}

augment class Stash {
    method iterator () { self.list.iterator }
}

augment class NAME {
}

augment class Regex {
}

augment class Match {
    method trim_heredoc () { self } # NYI
}

augment class Hash {
}

augment class STD {
    our $ALL;
method load_lex($setting) {
    if $setting eq 'NULL' {
        my $id = "MY:file<NULL.pad>:line(1):pos(0)";
        my $core = Stash.new('!id' => [$id], '!file' => 'NULL.pad',
            '!line' => 1);
        return Stash.new('CORE' => $core, 'MY:file<NULL.pad>' => $core,
            'SETTING' => $core, $id => $core);
    }

    return Stash.new(%( from-jsync(slurp($setting ~ ".syml")) ));
}
method gettrait($traitname,$param) {
    my $text;
    my $M;
    if @$param {
        $text = $param.[0].Str;
        _subst($M, $text, /^\<(.*)\>$/, { $M[0] }) or
            _subst($M, $text, /^\((.*)\)$/, { $M[0] });
    }
    if ($traitname eq 'export') {
        if (defined $text) {
            while _subst($M, $text, /\:/, "") { }
        }
        else {
            $text = 'DEFAULT';
        }
        self.set_export($text);
        $text;
    }
    elsif (defined $text) {
        $text;
    }
    else {
        1;
    }
}
method find_stash ($n, $crlex = $*CURLEX) {
    my $name = $n;
    my $curlex = $crlex;
    self.deb("find_stash $name") if $DEBUG::symtab;

    return Any if $name ~~ /\:\:\(/;
    my @components = self.canonicalize_name($name);
    if +@components > 1 {
        return Any if @components[0] eq 'COMPILING::';
        return Any if @components[0] eq 'CALLER::';
        return Any if @components[0] eq 'CONTEXT::';
        if $curlex = self.find_top_pkg(@components[0]) {
            self.deb("Found lexical package ", @components[0]) if $DEBUG::symtab;
            shift @components;
        }
        else {
            self.deb("Looking for GLOBAL::<$name>") if $DEBUG::symtab;
            $curlex = $*GLOBAL;
        }
        while +@components > 1 {
            my $lex = shift @components;
            $curlex = $curlex.{$lex};
            return Any unless $curlex;
            try {
                my $outlexid = $curlex.[0];
                return Any unless $outlexid;
                $curlex = $ALL.{$outlexid};
                return Any unless $curlex;
            };
            self.deb("Found $lex okay") if $DEBUG::symtab;
        }
    }
    $name = shift(@components)//'';
    return $curlex if $name eq '';

    my $lex = $curlex;
    my $old;
    while $lex {
        return $old if $old = $lex.{$name};
        my $oid = $lex.<OUTER::>[0] || last;
        $lex = $ALL.{$oid};
    }
    return $old if $old = $curlex.{$name};
    return $old if $old = $*GLOBAL.{$name};
    return Any;
}
method do_import($m, $args) { #, perl6.vim stupidity
    my @imports;
    my $module = $m.Str;
    my $M;
    if $M = ($module ~~ /(class|module|role|package)\s+(\S+)/) {
        $module = $M[1];
    }

    my $pkg = self.find_stash($module);
    if $pkg<really> {
        $pkg = $pkg<really><UNIT>;
    }
    else {
        $pkg = self.find_stash($module ~ '::');
    }
    if $args {
        my $text = $args.Str;
        return self unless $text;
        while _subst($M, $text, /^\s*\:?(OUR|MY|STATE|HAS|AUGMENT|SUPERSEDE)?\<(.*?)\>\,?/, "") {
            my $scope = lc($M[0] // 'my');
            my $imports = $M[1].Str;
            my $*SCOPE = $scope;
            @imports = $imports.comb(/\S+/);
            for @imports -> $i {
                my $imp = $i;
                if $pkg {
                    if _subst($M, $imp, /^\:/, "") {
                        my @tagimports;
                        try { @tagimports = $pkg<EXPORT::>{$imp}.keys }
                        self.do_import_aliases($pkg, @tagimports);
                    }
                    elsif $pkg{$imp}<export> {
                        self.add_my_name($imp, $pkg{$imp});
                    }
                    elsif $pkg{'&'~$imp}<export> {
                        $imp = '&' ~ $imp;
                        self.add_my_name($imp, $pkg{$imp});
                    }
                    elsif $pkg{$imp} {
                        self.worry("Can't import $imp because it's not exported by $module");
                        next;
                    }
                }
                else {
                    self.add_my_name($imp);
                }
            }
        }
    }
    else {
        return self unless $pkg;
        try { @imports = $pkg<EXPORT::><DEFAULT::>.keys };
        my $*SCOPE = 'my';
        self.do_import_aliases($pkg, @imports);
    }

    self;
}
method do_import_aliases($pkg, *@names) {
#    say "attempting to import @names";
    for @names -> $n {
        next if $n ~~ /^\!/;
        next if $n ~~ /^PARENT\:\:/;
        next if $n ~~ /^OUTER\:\:/;
        self.add_my_name($n, $pkg{$n});
    }
    self;
}

}

augment class STD::P6 {
my %term            = (:dba('term')            , :prec<z=>);
my %methodcall      = (:dba('methodcall')      , :prec<y=>, :assoc<unary>, :uassoc<left>, :fiddly, :!pure);
    token trait_mod:of {
        ['of'|'returns']:s <typename>
        [ <?{ $*DECLARAND<of> }> <.sorry("Extra 'of' type; already declared as type " ~ $*DECLARAND<of>.Str)> ]?
        { $*DECLARAND<of> = $<typename>.Str; }
    }
    token dotty:sym<.*> {
        ('.' [ <[+*?=]> | '^' '!'? ]) :: <.unspacey> <dottyop>
        $<sym> = {$0.Str}
        <O(|%methodcall)>
    }

    token dotty:sym<.> {
        <sym> <.unspacey> <dottyop>
        <O(|%methodcall)>
    }

    token privop {
        '!' <methodop>
        <O(|%methodcall)>
    }
    token term:name
    {
        :my $name;
        :my $pos;
        <longname>
        {
            $name = $<longname>.Str;
            $pos = $¢.pos;
        }
        [
        ||  <?{
                $¢.is_name($name) or substr($name,0,2) eq '::'
            }>
            { $¢.check_nodecl($name); }

            # parametric type?
            :dba('type parameter')
            <.unsp>? [ <?before '['> <postcircumfix> ]?

            :dba('namespace variable lookup')
            [
                <?after '::'>
                <?before [ '«' | '<' | '{' | '<<' ] > <postcircumfix>
                { $*VAR = Match.synthetic(:cursor($¢), :from(self.pos), :to($¢.pos), :captures(), :method<Str>) }
            ]?

        # unrecognized names are assumed to be post-declared listops.
        || <args> { self.add_mystery($<longname>,$pos,'termish') unless $<args><invocant>; }
            {{
                if $*BORG and $*BORG.<block> {
                    if not $*BORG.<name> {
                        $*BORG.<culprit> = $<longname>.cursor($pos);
                        $*BORG.<name> = $*BORG<name> // $name;
                    }
                }
            }}
        ]
        <O(|%term)>
    }
}

augment class Cursor {
    our $RED    = "\e[31m";
    our $GREEN  = "\e[32m";
    our $YELLOW = "\e[33m";
    our $CLEAR  = "\e[37m";
}

sub compiler(:$filename, :$text, :$settingname) {
    my $*SETTINGNAME = $settingname;
    my @*MEMOS;
    my $*FILE = { name => $filename };
    my @*ACTIVE;
    my $*HIGHWATER = 0;
    my $*HIGHEXPECT = {};
    my $*HIGHMESS = "";
    my $*LASTSTATE = 0;
    my $*IN_PANIC = 0;
    my $*IN_SUPPOSE = 0;
    my $*FATALS = 0;

    $STD::DEBUG::EXPR = False;
    $STD::DEBUG::symtab = False;

    my $*LAST_NIBBLE = 0;
    my $*LAST_NIBBLE_START = 0;
    my $*LAST_NIBBLE_MULTILINE = 0;
    my $*LAST_NIBBLE_MULTILINE_START = 0;
    my $*GOAL = "(eof)";
    my $*SETTING; my $*CORE; my $*GLOBAL; my $*UNIT; my $*YOU_WERE_HERE;
    my $*CCSTATE; my $*BORG; my %*RX; my $*XACT; my $*VAR; my $*IN_REDUCE;
    STD.parse($text);

    my $all;

    # setting?
    if $*YOU_WERE_HERE {
        $all = $STD::ALL;
        $all<SETTING> = $*YOU_WERE_HERE;
        $all<CORE> = $*YOU_WERE_HERE if $*UNIT<$?LONGNAME> eq 'CORE';
    }
    else {
        $all = {};
        for keys %( $STD::ALL ) -> $key {
            next if $key ~~ /^MY\:file\<\w+\.setting\>/ or $key eq 'CORE' or $key eq 'SETTING';
            $all{$key} = $STD::ALL{$key};
        }
    }

    $all
}

if !@*ARGS {
    note "Usage: tryfile.exe [--symbols]? [--setting NAME]? [-e TEXT | FILENAME | -]";
    exit 1;
}

my $symbols = False;
my $setting = 'CORE';
if @*ARGS[0] eq '--symbols' {
    $symbols = True;
    shift @*ARGS;
}
if @*ARGS[0] eq '--setting' {
    shift @*ARGS;
    $setting = shift @*ARGS;
}

my $out;
if @*ARGS[0] eq '-' {
    $out = compiler(filename => '(eval)', text => $*IN.slurp, settingname => $setting);
} elsif @*ARGS[0] eq '-e' {
    $out = compiler(filename => '(eval)', text => @*ARGS[1], settingname => $setting);
} else {
    $out = compiler(filename => @*ARGS[0], text => slurp(@*ARGS[0]), settingname => $setting);
}

if $symbols {
    say to-jsync($out);
} else {
    say "OK"
}
