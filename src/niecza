use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use JSYNC;
use Metamodel;
use NAMOutput;
use NieczaActions;
use NieczaBackendClisp;
use NieczaBackendDotnet;
use NieczaBackendHoopl;
use NieczaBackendNAM;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

augment class Op::Interrogative {
    method code($body) {
        my $c;
        given $!name {
            when "VAR" {
                return CgOp.var_get_var($!receiver.cgop($body));
            }
            $c = CgOp.fetch($.receiver.cgop($body));
            when "HOW" { $c = CgOp.how($c); }
            when "WHO" { $c = CgOp.who($c); }
            when "WHAT" { $c = CgOp.obj_what($c); }
            default { die "Invalid interrogative $_"; }
        }
        CgOp.newscalar($c);
    }
}

augment class Operator::Method {
    method with_args($/, *@args) {
        if $!name eq any(< HOW WHAT WHO VAR >) && !$!private && !$!meta {
            if $!args {
                $/.CURSOR.sorry("Interrogative operator $.name does not take arguments");
                return Op::StatementList.new;
            }
            Op::Interrogative.new(|node($/), receiver => @args[0],
                name => $.name);
        } else {
            if defined($!package) && !$!private {
                $/.CURSOR.sorry("Qualified references to non-private methods NYI");
            }
            $*CURLEX<!sub>.noninlinable if $!name eq 'eval';
            my $pclass;
            if $.private {
                if $.package {
                    $pclass = $.package;
                } elsif $*CURLEX<!sub>.in_class -> $c {
                    $pclass = $c;
                } else {
                    $/.CURSOR.sorry("Cannot resolve class for private method");
                }
            }
            ::Op::CallMethod.new(|node($/),
                receiver => @args[0],
                ismeta   => $.meta,
                name     => $.name,
                private  => $.private,
                pclass   => $pclass,
                args     => [ @$.args ]);
        }
    }
}

augment class NieczaActions {

sub mkstringycat($/, *@strings) {
    my @a;
    for @strings -> $s {
        my $i = ($s !~~ Op) ?? ::Op::StringLiteral.new(|node($/),
            text => $s) !! $s;

        # this *might* belong in an optimization pass
        if @a && @a[*-1] ~~ ::Op::StringLiteral &&
                $i ~~ ::Op::StringLiteral {
            @a[*-1] = ::Op::StringLiteral.new(|node($/),
                text => (@a[*-1].text ~ $i.text));
        } else {
            push @a, $i;
        }
    }
    if @a == 0 {
        return ::Op::StringLiteral.new(|node($/), text => "");
    } elsif  @a == 1 {
        return (@a[0] ~~ ::Op::StringLiteral) ?? @a[0] !!
            mkcall($/, '&prefix:<~>', @a[0]);
    } else {
        return mkcall($/, '&infix:<~>', @a);
    }
}


# this is to be the one place where names are processed

# MODES
# declaring: returns (Package, Str) or Op(defer, returns full Str)
# method:    returns Op(defer, returns full Str)
# reference: returns Package or Op(defer, bvalish lexicoid)

# OPTIONS
# clean:     remove :sym<xyz>

method process_name($/, :$declaring, :$defer, :$method, :$clean, :$sigil!) {

    return () unless defined $/;

    my @ns = @( $<name>.ast<names> );
    my $dc = $<name>.ast.<dc>;
    my $ext = '';

    if !$clean {
        for @( $<colonpair> ) {
            $ext ~= $_.ast<ext> // (
                $_.CURSOR.sorry("Invalid colonpair for name extension");
                "";
            )
        }
    }

    if !$defer {
        for @ns {
            if $_.^isa(Op) {
                $_ = self.trivial_eval($/, $_);
                if $_ ~~ Cool {
                    $_ = ~$_;
                } else {
                    $_ = "XXX";
                    $/.CURSOR.sorry("Name components must evaluate to strings");
                }
            }
        }
    }

    if $declaring {
        die "Unimplemented" if $defer;
        return () unless @ns;
        my $head = $sigil ~ pop(@ns) ~ $ext;
        return Any, $head unless @ns;

        # the remainder is assumed to name an existing or new package
        my $pkg;
        $/.CURSOR.trymop({
            $pkg = $*CURLEX<!sub>.compile_get_pkg(@ns, :auto);
        });
        return $pkg, $head;
    }
    else {
        die "NYI";
    }
}

method install_sub($/, $sub, :$multiness is copy, :$scope is copy, :$class,
        :$longname, :$method_type is copy, :$contextual is copy) {

    $multiness ||= 'only';
    my ($pkg, $name) = self.process_name($longname, :declaring, :sigil(""));

    if !$scope {
        if !defined($name) {
            $scope = 'anon';
        } elsif defined($pkg) {
            $scope = 'our';
        } elsif defined($method_type) {
            $scope = 'has';
        } else {
            $scope = 'my';
        }
    }

    if $class eq 'Regex' {
        my $/;
        $*CURLEX<!name> = $name;
        $*CURLEX<!cleanname !sym> =
            ($name ~~ /\:sym\<(.*)\>/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name ~~ /\:(\w+)/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name, Str);
        $multiness = 'multi' if defined $*CURLEX<!sym>;
        $*CURLEX<!multi> = $multiness;
    }

    if $scope ne 'my' && $scope ne 'our' && $scope ne 'anon' && $scope ne 'has' {
        $/.CURSOR.sorry("Illegal scope $scope for subroutine");
        $scope = 'anon';
    }

    if $scope eq 'has' && !defined($method_type) {
        $/.CURSOR.sorry('has scope-type is only valid for methods');
        $scope = 'anon';
    }

    if $scope ne 'anon' && !defined($name) {
        $/.CURSOR.sorry("Scope $scope requires a name");
        $scope = 'anon';
    }

    if $scope ne 'our' && defined($pkg) {
        $/.CURSOR.sorry("Double-colon-qualified subs must be our");
        $scope = 'our';
    }

    if $scope eq 'anon' && $multiness ne 'only' {
        $/.CURSOR.sorry("Multi routines must have a name");
        $multiness = 'only';
    }

    if $contextual && (defined($method_type) || $scope ne 'my') {
        $/.CURSOR.sorry("Context-named routines must by purely my-scoped");
        $contextual = False;
    }

    $method_type = Str if $scope eq 'anon';

    my $method_targ = $method_type && $sub.outer.body_of;
    if $method_targ {
        $method_targ = $*unit.deref($method_targ);
    } elsif defined($method_type) {
        $/.CURSOR.sorry("Methods must be used in some kind of package");
        $method_type = Str;
    }

    if $method_targ && !$method_targ.^can('add_method') {
        $/.CURSOR.sorry("A {$method_targ.WHAT} cannot have methods added");
        $method_type = Str;
        $method_targ = Any;
    }

    if $name ~~ Op && (!defined($method_type) || $scope ne 'has' ||
            $method_targ !~~ ::Metamodel::ParametricRole) {
        $/.CURSOR.sorry("Computed names are only implemented for parametric roles");
        $name = "placeholder";
    }

    my $bindlex = $scope eq 'my' || ($scope eq 'our' && !$pkg);

    $sub.set_name(defined($method_type) ?? $method_targ.name ~ "." ~ $name !!
        ($name // 'ANON'));
    $sub.class = $class;
    $sub.returnable = True;

    my $std = $/.CURSOR;
    {
        my $/;
        if $sub.name ~~ /^(\w+)\:\<(.*)\>$/ {
            my %new = %( $std.default_O(~$0, ~$1) );
            $sub.extend.<prec> = %new;
        }
    }

    my Str $symbol;
    $/.CURSOR.trymop({
        if $bindlex && $class eq 'Regex' {
            $symbol = '&' ~ $name;
            my $proto = $symbol;
            $proto ~~ s/\:.*//;
            $sub.outer.add_dispatcher($proto, |mnode($/))
                if $multiness ne 'only' && !$sub.outer.lexicals.{$proto};
            $symbol ~= ":(!proto)" if $multiness eq 'proto';
        } elsif $bindlex {
            $symbol = '&' ~ $name;
            $/.CURSOR.check_categorical($symbol);
            if $multiness ne 'only' && !$sub.outer.lexicals.{$symbol} {
                $sub.outer.add_dispatcher($symbol, |mnode($/))
            }

            given $multiness {
                when 'multi' { $symbol ~= ":({ self.gensym })"; }
                when 'proto' { $symbol ~= ":(!proto)"; }
                default {
                    $/.CURSOR.check_categorical($symbol);
                }
            }
        } else {
            $symbol = self.gensym;
        }

        $sub.outervar = $symbol;
        $sub.methodof = defined($method_type) ?? $method_targ.xref !! Any;
        $sub.outer.add_my_sub($symbol, $sub, |mnode($/));

        if $multiness ne 'only' || $scope eq 'our' || $method_type {
            $sub.outer.lexicals-used{$symbol} = True;
        }

        if defined($method_type) || $scope eq 'our' {
            $sub.strong_used = True;
            $sub.outer.create_static_pad;
        }

        if defined($method_type) {
            if $sub.outer.augment_hack {
                push $sub.outer.augment_hack,
                    [ $multiness, $method_type, $name, $symbol, $sub.xref ];
            } else {
                $method_targ.add_method($multiness, $method_type, $name,
                    $symbol, $sub.xref, |mnode($/));
            }
        }

        if $scope eq 'our' {
            $sub.outer.bind_our_name($pkg, "&$name", $sub.xref);
        }
    });
}

method regex_def_1 ($, $/ = $*cursor) {
    self.install_sub($/, $*CURLEX<!sub>, scope => $*SCOPE, class => 'Regex',
        method_type => (($*SCOPE || 'has') eq 'has') ?? 'normal' !! Any,
        longname => $<deflongname>, multiness => $*MULTINESS);
}

method routine_def_1 ($, $/ = $*cursor) {
    self.install_sub($/, $*CURLEX<!sub>, scope => $*SCOPE, class => 'Sub',
        longname => $<deflongname>, multiness => $*MULTINESS,
        contextual => ($<sigil> && $<sigil> eq '&*'));
}

method method_def_1 ($, $/ = $*cursor) {
    my $type = $<type> ?? ~$<type> !! '';
    if $type ne '' && $*HAS_SELF eq 'partial' {
        $type = '';
        $/.CURSOR.sorry("Type symbols cannot be used with submethod");
    }

    self.install_sub($/, $*CURLEX<!sub>, scope => $*SCOPE,
        method_type => ($type eq '^' ?? 'meta' !! $type eq '!' ?? 'private' !!
            $*HAS_SELF eq 'partial' ?? 'sub' !! 'normal'),
        longname => $<longname>, multiness => $*MULTINESS,
        :class($*HAS_SELF eq 'partial' ?? 'Submethod' !! 'Method'));
}


method statement_prefix:BEGIN ($/) {
    $<blast>.ast.is_phaser = 2;
    $*CURLEX<!sub>.create_static_pad;
    make ::Op::StatementList.new;

    # MAJOR HACK - allows test code like BEGIN { @*INC.push: ... } to work
    repeat while False {
        my $c = $<blast>.ast.code;

        last unless $c ~~ Op::StatementList;
        last unless $c.children == 1;
        my $d = $c.children.[0];
        last unless $d ~~ Op::CallMethod;
        last unless $d.receiver ~~ Op::ContextVar;
        last unless $d.receiver.name eq '@*INC';
        last if $d.private || $d.ismeta;
        last unless $d.name eq any <push unshift>;
        last unless +$d.getargs == 1;
        last unless defined my $str = self.trivial_eval($/, $d.getargs.[0]);
        @*INC."$d.name()"($str);
    }
}
}

CgOp._register_ops: < who
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => [ NieczaPassSimplifier.new ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
