use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use JSYNC;
use Metamodel;
use NAMOutput;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

augment class Op::CallMethod {
    method code($body) {
        my $name = ($.name ~~ Op) ?? CgOp.obj_getstr($.name.cgop($body))
            !! CgOp.str($.name);
        my $meta = $!ismeta // '';
        if $.private {
            CgOp.subcall(CgOp.stab_privatemethod(
                    CgOp.class_ref('mo', $!pclass), $name),
                $.receiver.cgop($body), self.argblock($body));
        } elsif $meta eq '^' {
            CgOp.let($.receiver.cgop($body), -> $r {
                CgOp.methodcall(CgOp.newscalar(CgOp.how(CgOp.fetch($r))),
                    $name, $r, self.argblock($body))});
        } elsif $meta eq '?' {
            # TODO maybe use a lower-level check
            CgOp.let($.receiver.cgop($body), -> $r { CgOp.let($name, -> $n {
                CgOp.ternary(
                    CgOp.obj_getbool(CgOp.methodcall(CgOp.newscalar(CgOp.how(
                        CgOp.fetch($r))), "can", $r, CgOp.box('Str',$n))),
                    CgOp.methodcall($r, $n, self.argblock($body)),
                    CgOp.scopedlex('Nil'))})});
        } else {
            CgOp.methodcall($.receiver.cgop($body),
                $name, self.argblock($body));
        }
    }
}

augment grammar STD::Regex {
    rule nibbler(:$reset?) {
        :temp %*RX;
        :my $stub = do { #OK
            %*RX<paren> //= 0;
            %*RX<paren> = 0 if $reset;
            %*RX<altparen> = %*RX<maxparen> = %*RX<paren>;
        };
        [ <.normspace>? < || | && & > ]?
        <EXPR>
        { CALLER::CALLER::<%*RX>.<paren> = %*RX<maxparen> max %*RX<paren> unless $reset }
        [
        || <?infixstopper>
        || $$ <.panic: "Regex not terminated">
        || (\W)<.sorry("Unrecognized regex metacharacter " ~ $0.Str ~ " (must be quoted to match literally)")>
        || <.panic: "Regex not terminated">
        ]
    }
}

augment class NieczaActions {
method metachar:sym<( )> ($/) {
    make self.rxcapturize($/, %*RX<paren>++,
        self.encapsulate_regex($/, $<nibbler>.ast, passcut => True));
}
method rxcapturize($M, $name, $rxop is copy) {
    if !$rxop.^isa(::RxOp::Capturing) {
        # $<foo>=[...]
        $rxop = self.encapsulate_regex($M, $rxop, passcut => True,
            passcap => True);
    }

    # $<foo>=(...)
    # XXX might not quite be right
    if +$rxop.captures == 1 && $rxop.captures.[0] ~~ /^\d+$/ {
        return $rxop.clone(captures => [$name]);
    }

    return $rxop.clone(captures => [ $name, @( $rxop.captures ) ]);
}
method metachar:var ($/) {
    sub _isnum { $_ ~~ /^\d+$/ }
    if $<binding> {
        my $a = $<binding><quantified_atom>.ast.uncut;
        my $cid = $<variable>.ast.<capid>;

        if !defined $cid {
            $/.CURSOR.sorry("Non-Match bindings NYI");
            make ::RxOp::Sequence.new;
            return Nil;
        }

        if $a.^isa(::RxOp::VoidBlock) {
            make ::RxOp::SaveValue.new(capid => $cid, block => $a.block);
            return Nil;
        }

        if _isnum($cid) {
            %*RX<paren> = $cid + 1;
        }

        make self.rxcapturize($/, $cid, $a);
        return Nil;
    }
    make ::RxOp::VarString.new(param => ~$<variable>,
        ops => self.rxembed($/, self.do_variable_reference($/, $<variable>.ast), True));
}
method metachar:sym<{ }> ($/) {
    $/.CURSOR.trymop({
        $<embeddedblock>.ast.add_my_name('$¢', :noinit, |mnode($/));
        $<embeddedblock>.ast.set_signature(Sig.simple('$¢'));
    });

    make ::RxOp::VoidBlock.new(block => self.inliney_call($/,
        $<embeddedblock>.ast, ::Op::MakeCursor.new(|node($/))));
}
method method_def_2 ($, $/ = $*cursor) {
    if $<multisig> > 1 {
        $/.CURSOR.sorry("You may only use *one* signature");
    }
    $*CURLEX<!sub>.set_signature($<multisig> ?? $<multisig>[0].ast !! Any);
    self.process_block_traits($/, $<trait>);
}

method do_new_package($/, :$sub = $*CURLEX<!sub>, :$scope!, :$name!, :$class!,
        :$exports) {

    $scope := $scope || 'our';
    if $scope ne 'our' && $scope ne 'my' && $scope ne 'anon' {
        $/.CURSOR.sorry("Invalid packageoid scope $scope");
        $scope := 'anon';
    }

    my ($pkg, $head) = self.process_name($name, :declaring, :clean);

    if defined($pkg) && $scope ne 'our' {
        $/.CURSOR.sorry("Pathed definitions require our scope");
        $scope := 'our';
    }

    if !$head {
        $scope := 'anon';
        $head  := 'ANON';
    }

    my $npkg;
    my $lexname;
    $/.CURSOR.trymop({
        my $old;
        if $scope ne 'anon' && !$pkg && $sub.has_lexical($head) {
            my @linfo = $sub.lookup_lex($head);
            die "Cannot resume definition - $head not a packageoid"
                unless @linfo[0] eq 'package';
            $old = @linfo[4];
        } elsif defined $pkg {
            $old = $*unit.get($pkg.who, $head);
        }

        my $lexed_already;

        if $old && $old.kind eq $class && !$old.closed {
            $npkg = $old;
            $lexed_already = True;
        } elsif $scope eq 'our' {
            my $opkg = $pkg // $sub.cur_pkg;
            $npkg = $*unit.create_type(name => $head, :$class,
                who => $opkg.who ~ '::' ~ $head);
            $*unit.bind($opkg.who, $head, $npkg, |mnode($/));
        } else {
            my $id = $*unit.anon_stash;
            $npkg = $*unit.create_type(name => $head, :$class,
                who => "::$id");
            $*unit.bind("", $id, $npkg, |mnode($/));
        }

        $lexname = (!$lexed_already && $scope ne 'anon' && !defined($pkg))
            ?? $head !! self.gensym;

        $sub.add_my_stash($lexname, $npkg, |mnode($/));
        $sub.add_exports($head, $npkg, @$exports) if $exports;
    });

    $lexname, $npkg
}

method process_block_traits($/, @tr) {
    my $sub = $*CURLEX<!sub>;
    my $pack = $sub.body_of;
    for @tr -> $T {
        my $tr = $T.ast;
        if $pack && $tr<name> {
            my $super = $tr<name>;

            $T.CURSOR.sorry("superclass $super.name() declared outside of any class"),
                next unless $sub.body_of;
            $T.CURSOR.sorry("superclass $super.name() declared in an augment"),
                next if defined $*AUGMENT_BUFFER;
            $T.CURSOR.sorry("cannot declare a superclass in this kind of package"),
                next if !$pack.CAN('add_super');

            $T.CURSOR.trymop({
                $pack.add_super($super);
            });
        } elsif $pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports($pack.name, $pack, @exports);
        } elsif !$pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports('&'~$sub.name, $sub, @exports);
            $sub.outer.create_static_pad;
            $/.CURSOR.mark_used($sub.outervar)
                if defined $sub.outervar;
        } elsif !$pack && $tr<nobinder> {
            $sub.set_signature(Any);
        } elsif !$pack && grep { defined $tr{$_} }, <looser tighter equiv> {
            my $rel = $tr.keys.[0];
            my $to  = $tr.values.[0];
            $to = $to.inside if $to ~~ ::Op::Paren;
            $to = $to.children[0] if $to ~~ ::Op::StatementList && $to.children == 1;

            my $oprec;
            if $to ~~ ::Op::Lexical {
                $oprec = $T.CURSOR.function_O($to.name);
            } elsif $to ~~ ::Op::StringLiteral && $sub.name ~~ /^(\w+)\:\<.*\>$/ {
                $oprec = $T.CURSOR.cat_O(~$0, $to.text);
            } else {
                $T.CURSOR.sorry("Cannot interpret operator reference");
                next;
            }
            unless $sub.get_extend('prec') {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            unless $oprec {
                $T.CURSOR.sorry("No precedence available for reference target");
                next;
            }
            if $rel eq 'equiv' {
                $sub.set_extend('prec', $oprec.kv);
            } else {
                my %prec = $sub.get_extend('prec');
                %prec<prec> = $oprec.<prec>;
                %prec<prec> ~~ s/\=/<=/ if $rel eq 'looser';
                %prec<prec> ~~ s/\=/>=/ if $rel eq 'tighter';
                $sub.set_extend('prec', %prec.kv);
            }
        } elsif !$pack && $tr<assoc> {
            my $arg = ~self.trivial_eval($T, $tr<assoc>);
            my %prec = $sub.get_extend('prec');
            unless %prec {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            unless $arg eq any < left right non list unary chain > {
                $T.CURSOR.sorry("Invalid associativity $arg");
                next;
            }
            %prec<assoc> = $arg;
            $sub.set_extend('prec', %prec.kv);
        } elsif !$pack && $tr<Niecza::absprec> {
            my $arg = ~self.trivial_eval($T, $tr<Niecza::absprec>);
            my %prec = $sub.get_extend('prec');
            unless %prec {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            %prec<prec> = $arg;
            %prec<dba> = "like $sub.name()";
            $sub.set_extend('prec', %prec.kv);
        } elsif !$pack && $tr<Niecza::builtin> {
            $sub.set_extend('builtin',
                self.trivial_eval($T, $tr<Niecza::builtin>));
        } elsif !$pack && $tr<return_pass> {
            $sub.set_return_pass;
        } elsif !$pack && $tr<of> {
        } elsif !$pack && $tr<rw> {
        } elsif !$pack && $tr<unsafe> {
            $sub.set_unsafe;
        } else {
            $T.CURSOR.sorry("Unhandled trait $tr.keys[0] for this context");
        }
    }
}

method statement_control:use ($/) {
    make ::Op::StatementList.new;
    return if $<version>; # just ignore these

    my $name = $<module_name>.ast<name>;
    my $args = $<arglist> ?? $<arglist>.ast !! [];

    if defined $<module_name>.ast.<args> {
        $/.CURSOR.sorry("'use' of an instantiated role not yet understood");
        return;
    }

    if $args {
        $/.CURSOR.sorry("'use' with arguments NYI");
        return;
    }

    if ($name eq 'MONKEY_TYPING' || $name eq 'fatal' || $name eq 'lib') {
        return;
    }

    my $u2 = $*unit.need_unit($name);

    my $module = $u2.mainline.compile_get_pkg($name.split('::'));
    my $exp;
    try $exp = $*unit.rel_pkg($module, 'EXPORT', 'DEFAULT');

    # in the :: case, $module will usually be visible via GLOBAL
    if !defined($name.index('::')) {
        $*CURLEX<!sub>.add_my_stash($name, $module);
    }

    return unless $exp;

    my $h = $/.CURSOR;
    for $*unit.list_stash($exp.who) -> $uname, $obj {
        if !$obj || $obj.kind eq 'sub' {
            $*CURLEX<!sub>.add_common_name($uname, $exp, $uname);
        } else {
            $*CURLEX<!sub>.add_my_stash($uname, $obj);
        }
        $h.check_categorical($uname);
        $h = $h.cursor_fresh(%*LANG<MAIN>);
    }
}
method assertion:sym<{ }> ($/) {
    $/.CURSOR.trymop({
        $<embeddedblock>.ast.add_my_name('$¢', :noinit, |mnode($/));
        $<embeddedblock>.ast.set_signature(Sig.simple('$¢'));
    });

    make ::RxOp::CheckBlock.new(block => self.inliney_call($/,
        $<embeddedblock>.ast, ::Op::MakeCursor.new(|node($/))));
}
method methodop($/) {
    if $<longname> {
        my ($c) = self.process_name($<longname>, :defer);
        make ::Operator::Method.new(name => 'die');
        unless $c {
            $/.CURSOR.sorry("Method call requires a name");
            return;
        }
        if $c<iname> {
            $/.CURSOR.sorry("Indirectly named method calls NYI");
            return;
        }
        make ::Operator::Method.new(name => $c<name>, package => $c<pkg>);
    } elsif $<quote> {
        make ::Operator::Method.new(name => $<quote>.ast);
    } elsif $<variable> {
        make ::Operator::Function.new(function =>
            self.do_variable_reference($/, $<variable>.ast));
    }

    $/.ast.args = $<args>[0].ast[0] if $<args>[0];
    $/.ast.args = $<arglist>[0].ast if $<arglist>[0];
}

method blockoid($/) {
    # XXX horrible cheat, but my data structures aren't up to the task of
    # $::UNIT being a class body &c.
    if $/ eq '{YOU_ARE_HERE}' {
        $*unit.set_bottom($*CURLEX<!sub>);
        $*CURLEX<!sub>.create_static_pad;

        loop (my $l = $*CURLEX<!sub>; $l; $l.=outer) {
            # this isn't *quite* right, as it will cause declaring
            # anything more in the same scope to fail.
            $/.CURSOR.mark_used($_) for $l.lex_names;
        }

        make ::Op::YouAreHere.new(|node($/), unitname => $*UNITNAME);
    } else {
        make $<statementlist>.ast;
    }
}
}

augment class Op::BareBlock {
    method statement_level() {
        $*CURLEX<!sub>.lookup_lex($!var).[4].set_run_once;
        ::GLOBAL::OptBeta.make_call($!var);
    }
}

CgOp._register_ops: < who sc_root sc_indir temporize _addmethod _invalidate
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => [ NieczaPassSimplifier.new ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
