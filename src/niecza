use Metamodel;
use Op;
use RxOp;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;
use OptRxSimple;
use Sig;
use STD;

augment class CgOp {
method bif_simple_eval($str) { self._cgop("bif_simple_eval", $str) }
}

augment class STD::P6 { #OK exist
my %list_prefix     = (:dba('list prefix')     , :prec<e=>, :assoc<unary>, :uassoc<left>);
    regex prefix_circumfix_meta_operator:reduce {
        :my $*IN_REDUCE = 1;
        :my ($op, $term);
        <?before '['\S+']'>
        $<s> = (
            '['
            [
            || <op=.infixish('red')> <?before ']'>
            || \\<op=.infixish('tri')> <?before ']'>
            || <!>
            ]
            ']' ['Â«'|<?>]
        )
        { $op = $<s><op>; }

        <.can_meta($op, "reduce with")>

        [
        || <!{ $op<O><diffy> }>
        || <?{ $op<O><assoc> eq 'chain' }>
        || <.sorry("Can't reduce with " ~ $op<sym> ~ " because " ~ $op<O><dba> ~ " operators are diffy and not chaining")>
        ]

        [
        || <?before '('>
        || <?before \s+ [ <?stdstopper> { $term = 1 } ]? >
        || { $term = 1 }
        ]

        <O(|%($op<O>), |%list_prefix, assoc => 'unary', uassoc => 'left', term => $term)>
        $<sym> = {$<s>.Str}

    }
}

augment class NieczaActions {
my %_decl2class = (
    package => ::Op::PackageDef,
    class   => ::Op::ClassDef,
    module  => ::Op::ModuleDef,
    grammar => ::Op::GrammarDef,
    role    => ::Op::RoleDef,
);

method package_def ($/) {
    make ::Op::StatementList.new;
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
        return Nil;
    }
    my $scope = $*SCOPE;
    if !$<longname> {
        $scope = 'anon';
    }

    if $scope eq 'supersede' {
        $/.CURSOR.sorry('Supercede is not yet supported');
        return Nil;
    }
    if $scope eq 'has' || $scope eq 'state' {
        $/.CURSOR.sorry("Illogical scope $scope for package block");
        return Nil;
    }

    my ($name, $outervar, @augpkg);

    my $optype = %_decl2class{$*PKGDECL};
    my $blocktype = $*PKGDECL;
    my $bodyvar = self.gensym;
    my ($ourpkg, $ourvar);

    if $scope eq 'augment' {
        my $r = self.mangle_longname($<longname>[0]);
        $name = $r<name>;
        @augpkg = @( $r<path> // ['MY'] );
    } elsif $<longname> {
        my $r = self.mangle_longname($<longname>[0]);
        $name = $r<name>;
        if ($r<path>:exists) && $scope ne 'our' {
            $/.CURSOR.sorry("Block name $<longname> requires our scope");
            $scope = 'our';
        }
        if $scope eq 'our' {
            $ourpkg = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            $ourvar = $r<name>;
        }
        $outervar = ($scope eq 'anon' || ($r<path>:exists)) ?? self.gensym
            !! $name;
    } else {
        $name = 'ANON';
        $outervar = self.gensym;
    }

    if $scope eq 'augment' {
        my $stmts = $<statementlist> // $<blockoid>;
        $stmts = $stmts.ast;
        my $cbody = self.sl_to_block($blocktype, $stmts, subname => "augment-" ~ ($name // 'ANON'));

        make ::Op::Augment.new(
            |node($/),
            pkg     => [@augpkg],
            name    => $name,
            bodyvar => $bodyvar,
            body    => $cbody);
    } elsif !$*DECLARAND<stub> {
        my $stmts = $<statementlist> // $<blockoid>;
        my @export;

        $stmts = ::Op::StatementList.new(children =>
            [ self.process_package_traits($/, @export, $<trait>), $stmts.ast ]);

        my $cbody = self.sl_to_block($blocktype, $stmts,
            subname => ($*PKGDECL ~ '-' ~ ($name // 'ANON')));
        make $optype.new(
            |node($/),
            signature => ($blocktype eq 'role' && $<signature> ??
                $<signature>[0].ast !! Any),
            name    => $name,
            var     => $outervar,
            exports => @export,
            bodyvar => $bodyvar,
            ourpkg  => $ourpkg,
            ourvar  => $ourvar,
            body    => $cbody);
    } else {
        make $optype.new(
            |node($/),
            name    => $name,
            var     => $outervar,
            ourpkg  => $ourpkg,
            ourvar  => $ourvar,
            stub    => True);
    }
}

method infix:sym<.=> ($/) { make ::Operator::DotEq.new }

method dottyopish ($/) { make $<term>.ast }

method dotty:sym<.*> ($/) {
    if $<sym> eq '.=' {
        make $<dottyop>.ast.meta_assign;
        return;
    }
    if !$<dottyop>.ast.^isa(::Operator::Method) {
        $/.CURSOR.sorry("Modified method calls can only be used with actual methods");
        make Operator.funop('&postfix:<++>', 1);
        return Nil;
    }
    if $<sym> eq '.^' {
        make $<dottyop>.ast.clone(:meta);
    } else {
        $/.CURSOR.sorry("NYI dottyop form $<sym>");
        make Operator.funop('&postfix:<++>', 1);
    }
}


method multi_declarator:null ($/) { make $<declarator>.ast }

method variable_declarator($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    if $<trait> || $<post_constraint> || $<postcircumfix> || $<semilist> {
        $/.CURSOR.sorry("Traits, postconstraints, and shapes on variable declarators NYI");
    }

    my $scope = $*SCOPE // 'my';

    if $scope eq 'augment' || $scope eq 'supersede' {
        $/.CURSOR.sorry("Illogical scope $scope for simple variable");
    }

    my $typeconstraint;
    if $*OFTYPE {
        my ($name,$rest) = self.mangle_longname($*OFTYPE<longname>)<name rest>;
        $typeconstraint = defined($rest) ?? [ @$rest,$name ] !! [ 'MY', $name ];
        $/.CURSOR.sorry("Common variables are not unique definitions and may not have types") if $scope eq 'our';
    }

    my $v = $<variable>.ast;
    my $t = $v<twigil>;
    if ($t && defined "?=~^:".index($t)) {
        $/.CURSOR.sorry("Variables with the $t twigil cannot be declared " ~
            "using $scope; they are created " ~
            ($t eq '?' ?? "using 'constant'." !!
             $t eq '=' ?? "by parsing POD blocks." !!
             $t eq '~' ?? "by 'slang' definitions." !!
             "automatically as parameters to the current block."));
    }

    if $scope ne 'has' && ($t eq '.' || $t eq '!') {
        $/.CURSOR.sorry("Twigil $t is only valid on attribute definitions ('has').");
    }

    if defined $v<rest> {
        $/.CURSOR.sorry(":: syntax is only valid when referencing variables, not when defining them.");
    }

    my $name = $v<sigil> ~ $v<twigil> ~ $v<name>;
    # otherwise identical to my
    my $slot = ($scope eq 'anon') ?? self.gensym !! $name;

    if $scope eq 'has' {
        make ::Op::Attribute.new(|node($/), name => $v<name>,
            accessor => $t eq '.', :$typeconstraint);
    } elsif $scope eq 'state' {
        make ::Op::Lexical.new(|node($/), name => $slot, state_decl => True,
            state_backing => self.gensym, declaring => True, :$typeconstraint,
            list => $v<sigil> eq '@', hash => $v<sigil> eq '%');
    } elsif $scope eq 'our' {
        make ::Op::PackageVar.new(|node($/), name => $slot, slot => $slot,
            path => [ 'OUR' ]);
    } else {
        make ::Op::Lexical.new(|node($/), name => $slot, declaring => True,
            list => $v<sigil> eq '@', hash => $v<sigil> eq '%', :$typeconstraint);
    }
}

}

augment class Operator {
class DotEq is Operator {
    method assignish() { True }
    method meta_assign() { die ".= may not be metaoperated" }
    method meta_not() { die ".= may not be metaoperated" }
    method with_args($/, *@args) {
        @args[1].meta_assign.with_args($/, @args[0]);
    }
}
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -B --backend=NAME         # select backend (nam, dotnet, clisp)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $stages;
if $bcnd eq 'clisp' {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassSimplifier.new,
    ];
} else {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ];
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => $stages,
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        $c.compile_string("say (" ~ $l ~ ").perl", !$comp, $stop);
    }
}
