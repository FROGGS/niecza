use Metamodel;
use Op;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use CgOp;
use NieczaActions;
use Metamodel;
use CClass;
use Sig;
use OptRxSimple;
use RxOp;
use STD;

augment class NieczaActions {
sub node($M) { { line => $M.cursor.lineof($M.to) } }
method FALLBACK($meth, $/) {
    if $meth eq '::($name)' { # XXX STD miscompilation
        if $<O><prec> eq 't=' { # additive
            make ::Op::Lexical.new(|node($/), name => '&infix:<' ~ self.get_op_sym($/) ~ '>');
        } elsif $<semilist> && $<O><prec> eq 'y=' {
            my $sym = $*GOAL eq '}' ?? '{ }' !! $*GOAL eq ']' ?? '[ ]' !!
                die "Unhandled postcircumfix ending in $*GOAL";
            make { postcircumfix => $sym, args => $<semilist>.ast };
        }
        return Nil;
    } elsif substr($meth,0,7) eq 'prefix:' {
    } elsif substr($meth,0,8) eq 'postfix:' {
    } elsif substr($meth,0,6) eq 'infix:' {
        make ::Op::Lexical.new(|node($/), name => '&infix:<' ~ self.get_op_sym($/) ~ '>');
        return Nil;
    } else {
        $/.CURSOR.sorry("Action method $meth not yet implemented");
    }
}
}

augment class STD { #OK exist
role herestop1 {
    token stopper { ^^ {} \h*? $*DELIM \h* <.unv>?? $$ \v? }
}

# XXX be sure to temporize @herestub_queue on reentry to new line of heredocs
our @herestub_queue;
token quibble ($l) {
    :my ($lang, $start, $stop);
    <babble($l)>
    { my $B = $<babble><B>; ($lang,$start,$stop) = @$B; }

    $start <nibble($lang)> [ $stop || <.panic: "Couldn't find terminator $stop"> ]

    {
        if $lang.hereinfo.[0] {
            push @herestub_queue,
                ::STD::Herestub.new(
                    delim => ~$<nibble>,
                    orignode => $Â¢,
                    writeback => $lang.hereinfo.[1],
                    lang => $lang.hereinfo.[0],
                );
        }
    }
}

method heredoc () {
    my $here = self;
    while my $herestub = shift @herestub_queue {
        my $*DELIM = $herestub.delim;
        my $lang = $herestub.lang.mixin( herestop1 );
        my $doc;
        if defined($doc = first /:r :lang($lang) <nibbler> <stopper>/.($here)) {
            $herestub.writeback.[0] = $doc;
            $here = $here.cursor($doc.to);
            # $herestub.orignode<doc> = $doc; NIECZA immutable matches
        }
        else {
            self.panic("Ending delimiter $*DELIM not found");
        }
    }
    return self.cursor($here.pos);  # return to initial type
}
}

augment class Op::HereStub { #OK exist
    method zyg() {
        if defined($.node.[0]) && $.node.[0] ~~ Match {
            $.node.[0] = $.node.[0]<nibbler>.ast
        }
        $.node.[0] // die "Here document used before body defined";
    }
}

# XXX mega hack.
my class Instant {
    has $.val;
    method to-posix() { $!val }
}

my class IO {
    has $.path; # Str

    method Str() { $.path }
    method IO() { self }

    method slurp() { slurp $.path }
    method spew($text) { spew $.path, $text }

    method combine(*@paths) {
        die "Sorry, paths do not form a monoid." unless @paths;
        my $acc = @paths.shift.IO;
        for @paths { $acc = $acc.append($_) }
        $acc
    }

    method f() { Q:CgOp { (box Bool (rawscall System.IO.File.Exists (obj_getstr {$!path}))) } }
    method d() { Q:CgOp { (box Bool (rawscall System.IO.Directory.Exists (obj_getstr {$!path}))) } }
    method e() { self.f || self.d }
    method relative($base) { $base.IO.append(self) }
    method append($sub) { Q:CgOp { (box Str (rawscall System.IO.Path.Combine (obj_getstr {self}) (obj_getstr {$sub}))) }.IO }
    method but-extension($ext) { Q:CgOp { (box Str (rawscall System.IO.Path.ChangeExtension (obj_getstr {self}) (obj_getstr {$ext}))) }.IO }
    method realpath() { Q:CgOp { (box Str (rawscall System.IO.Path.GetFullPath (obj_getstr {self}))) }.IO }
    method modified() { Instant.new(val => Q:CgOp { (rawscall Builtins,Kernel.GetModTime (obj_getstr {self})) }) }
}

augment class Str {
    method IO() { IO.new(path => self) }
}

sub GetOptions(*@pairs, :$permute = True, :onerror($onerror_), :onarg($onarg_)) {
    my @nonopt;
    my $onerror = $onerror_ // sub ($message) {
        note $message;
        exit 1;
    };
    my $onarg = $onarg_ // sub ($arg) {
        push @nonopt, $arg;
        if !$permute {
            push @nonopt, @*ARGS;
            @*ARGS = ();
        }
    };
    my @unpk;
    sub pick_long_option($st) {
        my @cand = grep { chars($_[0]) > 1 &&
            substr($_[0],0,chars($st)) eq $st }, @unpk;
        $onerror.("Ambiguous long option --$st; could be any of {map *[0], @cand}") if @cand > 1;
        $onerror.("No match for long option --$st") if !@cand;
        @cand[0];
    }
    sub pick_short_option($st) {
        my @cand = grep { $_[0] eq $st }, @unpk;
        $onerror.("No match for short option -$st") if !@cand;
        @cand[0];
    }
    for @pairs -> $p {
        my $key = $p.key;
        my $type = '';
        if $key ~~ /<[:=]>s$/ {
            $type = ~$/;
            $key = substr($key, 0, $/.from);
        }
        for $key.split('|') {
            push @unpk, [ $_, $type, $p.value ];
        }
    }

    while @*ARGS {
        my $opt = shift @*ARGS;
        if $opt eq '--' {
            $onarg.(shift @*ARGS) while @*ARGS;
            last;
        }
        elsif substr($opt, 0, 2) eq '--' {
            if $opt ~~ /'='/ {
                my $obl = pick_long_option(substr($opt, 2, $/.from - 2));
                $onerror.("Long option --$obl[0] does not accept an argument")
                    if $obl[1] eq '';
                $obl[2].(substr($opt, $/.to));
            } else {
                my $obl = pick_long_option(substr($opt, 2));
                if $obl[1] eq '=s' {
                    $onerror.("Argument required for long option --$obl[0]")
                        unless @*ARGS;
                    $obl[2].(shift @*ARGS);
                } else {
                    $obl[2].(Str);
                }
            }
        }
        elsif chars($opt) > 1 && substr($opt, 0, 1) eq '-' {
            $opt = substr($opt, 1);
            while $opt ne '' {
                my $obl = pick_short_option(substr($opt, 0, 1));
                $opt = substr($opt, 1);
                if $obl[1] eq '' || $obl[1] eq ':s' && $opt eq '' {
                    $obl[2].(Str);
                }
                elsif $opt ne '' {
                    $obl[2].($opt);
                    $opt = '';
                }
                else {
                    $onerror.("Argument required for short option -$obl[0]")
                        unless @*ARGS;
                    $obl[2].(shift @*ARGS);
                }
            }
        }
        else {
            $onarg.($opt);
        }
    }

    @*ARGS = @nonopt;
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -B --backend=NAME         # select backend (nam, dotnet, clisp)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction, implies -L SAFE
      --help                 # display this message

backend options:
      --aot                  # run ahead-of-time compiler (mono)
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = False;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "verbose|v" => sub { $verb = True },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $safe ?? 'SAFE' !! $lang,
        safemode => $safe,
    ),
    stages => [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        $c.compile_string($l, !$comp, $stop);
    }
}
