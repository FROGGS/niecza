use Metamodel;
use Op;
use RxOp;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaBackendHoopl;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;
use OptRxSimple;
use STD;
use Sig;

class Op::SubsetDef is Op {
    has Str $.name;
    has Array $.basetype; # Array of Str
    has Array $.ourname; # Maybe[Array of Str], else gensymmish
    has Str $.lexvar;
    has $.body; # Body
    has @.exports; # Array of Str

    method code($ ) { CgOp.scopedlex($.lexvar) }
}

class Op::EnumDef is Op {
    has Str $.name;
    has Array $.basetype; # Maybe[Array of Str]
    has Array $.ourname; # Maybe[Array of Str], else gensymmish
    has Str $.lexvar;
    has @.pairs; # Array of Pair[Str,Int|Str]
    has @.exports; # Array of Str

    method code($ ) { CgOp.methodcall(CgOp.scopedlex($.lexvar), 'enums') }
}

augment class Op::Lexical { #OK
    method code_bvalue($ , $ro, $rhscg) {
        my $type = CgOp.class_ref('mo', 'Any');
        CgOp.prog(
            CgOp.scopedlex($.name, defined($ro) ?? CgOp.newboundvar(+?$ro,
                +(?($.list || $.hash)), $type, $rhscg) !! $rhscg),
            CgOp.scopedlex($.name));
    }
}

augment class Op::PackageVar { #OK
    method code_bvalue($ , $ro, $rhscg) {
        my $type = CgOp.class_ref('mo', 'Any');
        CgOp.prog(
            CgOp.scopedlex($.slot,
                defined($ro) ?? CgOp.newboundvar(+?$ro,
                    +(?($.list || $.hash)), $type, $rhscg) !! $rhscg),
            CgOp.scopedlex($.slot));
    }
}

augment class Sig::Parameter { #OK
    method !default_get($body) {
        if defined $!mdefault {
            CgOp.call_uncloned_sub(@$!mdefault);
        } elsif $!defouter {
            CgOp.outerlex($!slot);
        } elsif $!optional {
            CgOp.class_ref('typeVar', @$!tclass);
        } else {
            CgOp.die("No value in $body.name() available for parameter $!name");
        }
    }

    method bind_inline($body, @posr) {
        my $get = $!full_parcel ?? self.parcel_get_inline(@posr) !!
            $!slurpycap ?? self.slurpycap_get_inline(@posr) !!
            $!slurpy ?? self.slurpy_get_inline(@posr) !!
            self.single_get_inline($body, @posr);

        if (defined $!slot) {
            if $!is_copy {
                self.do_copy($get);
            } else {
                my $type = CgOp.class_ref('mo', @!tclass);
                CgOp.scopedlex($!slot, $!rwtrans ?? $get !!
                    CgOp.newboundvar(+(!$!rw), +$!list, $type, $get));
            }
        } else {
            CgOp.sink($get);
        }
    }
}

augment class NieczaActions {
method trivial_eval($/, $ast) {
    if $ast.^isa(::Op::SimpleParcel) {
        [,] map { self.trivial_eval($/, $_) }, @( $ast.items )
    } elsif $ast.^isa(::Op::StringLiteral) {
        $ast.text;
    } elsif $ast.^isa(::Op::Paren) {
        self.trivial_eval($/, $ast.inside);
    } else {
        $/.CURSOR.sorry("Compile time expression is insufficiently trivial");
        "XXX"
    }
}

method type_declarator:subset ($/) {
    my $ourname = Array; my $lexvar = self.gensym; my $name;
    my $scope = $*SCOPE;
    if $scope && $scope ne 'our' && $scope ne 'my' && $scope ne 'anon' {
        $/.CURSOR.sorry("Invalid subset scope $scope");
        $scope = 'anon';
    }
    if $<longname> {
        $scope ||= 'my';
        my $r = self.mangle_longname($<longname>[0], True);
        $name = $r<name>;
        if ($r<path>:exists) && $scope ne 'our' {
            $/.CURSOR.sorry("Block name $<longname> requires our scope");
            $scope = 'our';
        }
        if $scope eq 'our' {
            $ourname = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            $ourname = [ @$ourname, $name ];
        } elsif $scope eq 'my' {
            $lexvar  = $name;
        }
    } else {
        if ($scope || 'anon') ne 'anon' {
            $/.CURSOR.sorry("Cannot have a non-anon subset with no name");
        }
        $name = 'ANON';
    }

    my $basetype = $*OFTYPE ?? self.simple_longname($*OFTYPE<longname>) !!
        ['MY', 'Any'];
    my @exports;

    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } elsif $t<of> {
            $basetype = $t<of>;
        } else {
            $/.CURSOR.sorry("Unsupported subset trait $t.keys()");
        }
    }

    my $body = self.transparent($/, $<EXPR> ?? $<EXPR>[0].ast !!
        mklex($/, 'True'));

    make ::Op::SubsetDef.new(|node($/), :$name, :$lexvar, :$ourname,
        :$body, :@exports, :$basetype);
}

method type_declarator:constant ($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    my $scope = $*SCOPE // 'my';
    my $slot  = ~($<identifier> // $<variable> // self.gensym);

    make ::Op::ConstantDecl.new(|node($/), name => $slot,
        path => ($scope eq 'our' ?? [ 'OUR' ] !! Array));
}

# note: named and unnamed enums are quite different beasts
method type_declarator:enum ($/) {
    my $scope = $*SCOPE;
    if $scope && $scope ne 'our' && $scope ne 'my' && $scope ne 'anon' {
        $/.CURSOR.sorry("Invalid enum scope $scope");
        $scope = 'anon';
    }

    my @exports;
    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } else {
            $/.CURSOR.sorry("Unsupported enum trait $t.keys()");
        }
    }

    my $basetype = $*OFTYPE ?? self.simple_longname($*OFTYPE<longname>) !! Any;

    my @pairs = self.trivial_eval($/, $<term>.ast);
    my $last = -1;
    my ($has_ints, $has_strs);
    for @pairs {
        if $_ !~~ Pair {
            my $key = $_;
            my $value = $last.succ;
            $_ = $key => $value;
        }
        given $last = .value {
            when Int { $has_ints = True; }
            when Str { $has_strs = True; }
            default  { $/.CURSOR.sorry("Enum values must be Int or Str"); }
        }
    }
    if $has_ints && $has_strs {
        $/.CURSOR.sorry("Enum may not contain both Int and Str values");
    }

    if $<name> && $<name>.reduced eq 'longname' && ($scope ||= 'my') ne 'anon' {
        # Longnamed enum is a kind of type definition
        my $ourname = Array;
        my $lexvar = self.gensym;
        my $r = self.mangle_longname($<longname>[0], True);
        my $name = $r<name>;
        if ($r<path>:exists) && $scope ne 'our' {
            $/.CURSOR.sorry("Enum name $<longname> requires our scope");
            $scope = 'our';
        }
        if $scope eq 'our' {
            $ourname = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            $ourname = [ @$ourname, $name ];
        } elsif $scope eq 'my' {
            $lexvar  = $name;
        }
        make ::Op::EnumDef.new(|node($/), :@pairs, :$ourname, :$lexvar, :$name,
            :@exports, :$basetype);
    } else {
        my $slot  = ~($<name> // self.gensym);

        make ::Op::ConstantDecl.new(|node($/), name => $slot,
            init => ::Op::CallMethod.new(|node($/), name => 'new',
                receiver => mklex($/, 'EnumMap'),
                args => [$<term>.ast]),
            path => ($scope eq 'our' ?? [ 'OUR' ] !! Array));
    }
}

method parameter($/) {
    my $rw = False;
    my $copy = False;
    my $sorry;
    my $slurpy = False;
    my $slurpycap = False;
    my $optional = False;
    my $rwt = False;
    my $type;

    if $<type_constraint> {
        $type = self.simple_longname($<type_constraint>[0]<typename><longname>);
    }

    for @( $<trait> ) -> $trait {
        if $trait.ast<rw> { $rw = True }
        elsif $trait.ast<copy> { $copy = True }
        elsif $trait.ast<parcel> { $rwt = True }
        elsif $trait.ast<readonly> { $rw = False }
        else {
            $trait.CURSOR.sorry('Unhandled trait ' ~ $trait.ast.keys.[0]);
        }
    }

    if $<post_constraint> > 0 {
        $/.sorry('Parameter post constraints NYI');
        make ::Sig::Parameter.new;
        return Nil;
    }

    my $default = $<default_value> ?? $<default_value>[0].ast !! Any;

    my $tag = $<quant> ~ ':' ~ $<kind>;
    if    $tag eq '**:*' { $sorry = "Slice parameters NYI" }
    elsif $tag eq '*:*'  { $slurpy = True }
    elsif $tag eq '|:*'  { $slurpycap = True }
    elsif $tag eq '\\:!' { $rwt = True }
    elsif $tag eq '\\:?' { $rwt = True; $optional = True }
    elsif $tag eq ':!'   { }
    elsif $tag eq ':*'   { $optional = True }
    elsif $tag eq ':?'   { $optional = True }
    elsif $tag eq '?:?'  { $optional = True }
    elsif $tag eq '!:!'  { }
    elsif $tag eq '!:?'  { $optional = True }
    elsif $tag eq '!:*'  { }
    else                 { $sorry = "Confusing parameters ($tag)" }
    if $sorry { $/.CURSOR.sorry($sorry); }
    my $p = $<param_var> // $<named_param>;

    make ::Sig::Parameter.new(name => ~$/, :$default,
        :$optional, :$slurpy, :$rw, type => $type,
        :$slurpycap, rwtrans => $rwt, is_copy => $copy, |$p.ast);
}

method do_variable_reference($M, $v) {
    if $v<term> {
        return $v<term>;
    }

    my $tw = $v<twigil>;
    my $sl = $v<sigil> ~ $tw ~ $v<name>;

    if defined($v<rest>) && $tw ~~ /<[*=~?^:]>/ {
        $M.CURSOR.sorry("Twigil $tw cannot be used with qualified names");
        return ::Op::StatementList.new;
    }

    if $tw eq '!' {
        self.docontext($M, $v<sigil>, ::Op::CallMethod.new(|node($M),
            name => $v<name>, private => True, receiver => mklex($M, 'self'),
            ppath => $v<rest>));
    }
    elsif $tw eq '.' {
        if defined $v<rest> {
            $M.CURSOR.sorry('$.Foo::bar syntax NYI');
            return ::Op::StatementList.new;
        }

        self.docontext($M, $v<sigil>, ::Op::CallMethod.new(|node($M),
            name => $v<name>, receiver => mklex($M, 'self')));
    }
    # no twigil in lex name for these
    elsif $tw eq '^' || $tw eq ':' {
        ::Op::Lexical.new(|node($M), name => $v<sigil> ~ $v<name>);
    }
    elsif $tw eq '*' {
        ::Op::ContextVar.new(|node($M), name => $sl);
    }
    elsif $tw eq '' || $tw eq '?' {
        if defined($v<rest>) {
            ::Op::PackageVar.new(path => $v<rest>, name => $sl,
                slot => self.gensym, |node($M));
        } elsif $tw eq '?' && $sl eq '$?POSITION' {
            mkcall($M, '&infix:<..^>',
                ::Op::Num.new(|node($M), value => [10, ~$M.from]),
                ::Op::Num.new(|node($M), value => [10, ~$M.to]));
        } elsif $tw eq '?' && $sl eq '$?LINE' {
            ::Op::Num.new(|node($M), value => [10, ~$M.cursor.lineof($M.from)]);
        } elsif $tw eq '?' && $sl eq '&?BLOCK' {
            ::Op::GetBlock.new(|node($M))
        } elsif $tw eq '?' && $sl eq '&?ROUTINE' {
            ::Op::GetBlock.new(|node($M), :routine)
        } else {
            ::Op::Lexical.new(|node($M), name => $sl);
        }
    }
    else {
        $M.CURSOR.sorry("Unhandled reference twigil $tw");
    }
}
}

augment class Op::YouAreHere { #OK
    method code($ ) {
        CgOp.you_are_here(CgOp.str($.unitname))
    }
}

class Op::LeaveHook is Op {
    has $.inner;
    method zyg() { $.inner }

    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.xspan("start$id", "end$id", 0, $.inner.cgop($body),
            11, '', "end$id");
    }
}

class Op::GetBlock is Op {
    has Bool $.routine;
    method code($body is copy) {
        constant %good = (:Routine, :Submethod, :Regex, :Method, :Sub);
        my $op = CgOp.callframe;
        my $pt = $body;
        loop {
            die "No current routine" if !$body;
            last if !$body.transparent &&
                (!$!routine || %good{$body.class});
            $body .= outer;
            $op = CgOp.frame_outer($op);
        }
        CgOp.newscalar(CgOp.frame_sub($op));
    }

    method begin() {
        loop (my $c = @*opensubs[*-1]; $c.unit === $*unit; $c = $c.outer) {
            $c.strong_used = True;
        }
    }
}

for < you_are_here frame_outer frame_sub
        > -> $name {
    my $fnc = anon sub CgOperator (\|@parcel) {
        Q:CgOp {
            (letn arr {[@parcel]}
                  items (getslot items vvarlist (@ (l arr)))
              (sink (vvarlist_shift (l items)))
              (vvarlist_unshift (l items) {$name})
              (l arr))
        }
    };
    Q:CgOp { (rnull (_cgop _addmethod (obj_llhow (@ {CgOp})) 0
        (obj_getstr {$name}) (@ {$fnc}))) }
}
Q:CgOp { (rnull (_cgop _invalidate (obj_llhow (@ {CgOp})))) };

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $stages;
if $bcnd eq 'clisp' {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassSimplifier.new,
    ];
} elsif $bcnd eq 'hoopl' {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassSimplifier.new,
    ];
} else {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ];
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => $stages,
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
}
