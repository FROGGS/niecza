use Metamodel;
use Op;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;

sub mkstringycat($/, *@strings) {
    my @a;
    for @strings -> $s {
        my $i = ($s !~~ Op) ?? ::Op::StringLiteral.new(|node($/),
            text => $s) !! $s;

        # this *might* belong in an optimization pass
        if @a && @a[*-1] ~~ ::Op::StringLiteral &&
                $i ~~ ::Op::StringLiteral {
            @a[*-1] = ::Op::StringLiteral.new(|node($/),
                text => (@a[*-1].text ~ $i.text));
        } else {
            push @a, $i;
        }
    }
    if @a == 0 {
        return ::Op::StringLiteral.new(|node($/), text => "");
    } elsif  @a == 1 {
        return (@a[0] ~~ ::Op::StringLiteral) ?? @a[0] !!
            mkcall($/, '&prefix:<~>', @a[0]);
    } else {
        return mkcall($/, '&infix:<~>', @a);
    }
}

augment class NieczaActions {
method process_nibble($/, @bits, $prefix?) {
    my @acc;
    for @bits -> $n {
        my $ast = $n.ast;

        if $ast ~~ CClass {
            $n.CURSOR.sorry("Cannot use a character class in a string");
            $ast = "";
        }

        if $ast !~~ Op && defined $prefix {
            $ast = $ast.split(/^^<before \s>[ $prefix || \s* ]/).join("");
        }

        push @acc, $ast;
    }

    my $post = $/.CURSOR.postprocessor;
    make mkstringycat($/, @acc);

    if $post eq 'null' {
        # already OK
    }
    # actually quotewords is a bit trickier than this...
    elsif $post eq 'words' || $post eq 'quotewords' {
        my $sl = $/.ast;
        if !$sl.^isa(::Op::StringLiteral) {
            make ::Op::CallMethod.new(|node($/), :name<words>, receiver => $sl);
        }
        else {
            my @tok = $sl.text.words;
            @tok = map { ::Op::StringLiteral.new(|node($/), text => $_) }, @tok;

            make ((@tok == 1) ?? @tok[0] !!
                ::Op::SimpleParcel.new(|node($/), items => @tok));
        }
    }
    elsif $post eq 'path' {
        # TODO could stand to be a lot fancier.
        make ::Op::CallMethod(|node($/), receiver => $/.ast, :name<IO>);
    }
    elsif $post eq 'run' {
        make mkcall($/, 'rungather', $/.ast);
    }
    else {
        $/.CURSOR.sorry("Unhandled postprocessor $post");
    }

    $/.ast;
}

method circumfix:sym«< >» ($/)   { make $<nibble>.ast }
method circumfix:sym«<< >>» ($/) { make $<nibble>.ast }
method circumfix:sym<« »> ($/)   { make $<nibble>.ast }

method postcircumfix:sym«< >» ($/) {
    make Operator.funop('&postcircumfix:<{ }>', 1, $<nibble>.ast);
}

method quote_mod:w  ($) { }
method quote_mod:ww ($) { }
method quote_mod:p  ($) { }
method quote_mod:x  ($) { }
method quote_mod:to ($) { }
method quote_mod:s  ($) { }
method quote_mod:a  ($) { }
method quote_mod:h  ($) { }
method quote_mod:f  ($) { }
method quote_mod:c  ($) { }
method quote_mod:b  ($) { }
}

augment class CgOp {
method xspan(*@items) { self._cgop('xspan', @items) }
}

augment class Op {
class Control is Op {
    has $.payload = die "Control.payload required"; # Op
    has $.name = "";
    has $.number = die "Control.number required"; # Num

    method zyg() { $.payload }

    method code($body) {
        CgOp.control($.number, CgOp.null('frame'), CgOp.int(-1),
            ($.name eq '' ?? CgOp.null('str') !! CgOp.str($.name)),
            $.payload.cgop($body));
    }
}
}

augment class Op::WhileLoop { #OK exist
    method code_labelled($body, $l) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.prog(
            CgOp.whileloop(+$.until, +$.once,
                CgOp.obj_getbool($.check.cgop($body)),
                CgOp.sink(CgOp.xspan("redo$id", "next$id", 0, $.body.cgop($body),
                    1, $l, "next$id", 2, $l, "last$id", 3, $l, "redo$id"))),
            CgOp.label("last$id"),
            CgOp.corelex('Nil'));
    }
}

augment class Op::ImmedForLoop { #OK exist
    method code_labelled($body, $l) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.rnull(CgOp.letn(
            "!iter$id", CgOp.vvarlist_new_empty,
            $.var, CgOp.null('var'),
            CgOp.vvarlist_push(CgOp.letvar("!iter$id"),
                $.source.cgop($body)),
            CgOp.whileloop(0, 0,
                CgOp.iter_hasflat(CgOp.letvar("!iter$id")),
                CgOp.prog(
                    CgOp.letvar($.var,
                        CgOp.vvarlist_shift(CgOp.letvar("!iter$id"))),
                    CgOp.sink(CgOp.xspan("redo$id", "next$id", 0,
                        $.sink.cgop($body),
                        1, $l, "next$id",
                        2, $l, "last$id",
                        3, $l, "redo$id")))),
            CgOp.label("last$id")));
    }
}

augment class Op::When { #OK exist
    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.ternary(CgOp.obj_getbool(CgOp.methodcall(
                $.match.cgop($body), 'ACCEPTS', CgOp.scopedlex('$_'))),
            CgOp.xspan("start$id", "end$id", 0, CgOp.prog(
                    CgOp.sink($.body.cgop($body)),
                    CgOp.control(6, CgOp.null('frame'), CgOp.int(-1),
                        CgOp.null('str'), CgOp.corelex('Nil'))),
                7, '', "end$id"),
            CgOp.corelex('Nil'));
    }
}

augment class Op::Try { #OK exist
    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.xspan("start$id", "end$id", 1, $.body.cgop($body),
            5, '', "end$id");
    }
}

augment class Op::TopicalHook { #OK exist
    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.xspan("start$id", "end$id", 0, $.inner.cgop($body),
            6, '', "end$id");
    }
}

augment class Op::LabelHook { #OK exist
    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.xspan("start$id", "end$id", 0, $.inner.cgop($body),
            map({ 8, $_, "goto_$_" }, @$.labels));
    }
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -B --backend=NAME         # select backend (nam, dotnet, clisp)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction, implies -L SAFE
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $safe ?? 'SAFE' !! $lang,
        safemode => $safe,
    ),
    stages => [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        $c.compile_string("say (" ~ $l ~ ").perl", !$comp, $stop);
    }
}
