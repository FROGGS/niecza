# vim: ft=perl6
my module SAFE;

my class Mu {
    # rawcall to avoid putting a rw binding on self... TODO
    method defined is rawcall {
        Q:CgOp { (box Bool (rawcall (@ (pos 0)) IsDefined)) }
    }
    method head { @(self).head }
    method Bool() { self.defined }
    method Str() {
        my $tn := Q:CgOp { (box Str (rawcall (@ {self}) GetTypeName)) };
        if self.defined {
            $tn ~ "()<instance>"
        } else {
            $tn ~ "()"
        }
    }
    method so() { self.Bool }
    method not() { ! self.Bool }
    method RAWCREATE is rawcall { Q:CgOp {
        (withtypes i Int32 max Int32 obj DynObject
          [l max (getfield Length (getfield pos (callframe)))]
          [l i (int 1)]
          [l obj (rawnew DynObject (getfield klass (cast DynObject
                  (@ (pos 0)))))]
          [whileloop 0 0 (< (l i) (l max)) (prog
              [rawcall (l obj) SetSlot
                (unbox String (@ (pos (l i))))
                (nsw (@ (pos (+ (l i) (int 1)))))]
              [l i (+ (l i) (int 2))])]
          [ns (l obj)])
    } }
    method bless($obj) { Q:CgOp {
        (prog
          [setfield klass (cast DynObject (@ {$obj}))
            (getfield klass (cast DynObject (@ {self})))]
          {$obj})
    } }
    method CREATE() { Q:CgOp {
        (rawscall Kernel.DefaultNew (@ (l self))) } }
    method new() { Q:CgOp { (rawscall Kernel.DefaultNew (@ {self})) } }
}

my class Any is Mu {
    method flat() { (self,).flat }

    method ACCEPTS($t) { self === $t }
    method !butWHENCE($cr) {
        Q:CgOp { (rawnew SimpleVariable (bool 1) (bool 0) (@ {$cr}) (@ {self})) }
    }
}

my class Cool {
}

my class Num is Cool {
    has $!value;
    method Str () { Q:CgOp {
        (box Str (rawcall (unbox Double (@ {self})) ToString))
    } }
    method Bool() { Q:CgOp {
        (box Bool (compare != (double 0)
                    (unbox Double (@ {self}))))
    } }
    method Numeric() { self }
    method ACCEPTS($t) { self == $t }
}

my class Str is Cool {
    has $!value;
    method Str () { self }
    method ACCEPTS($t) { self eq $t }
    method chars() { Q:CgOp {
        (box Num (cast Double (getfield Length (unbox String (@ (l self))))))
    } }
    method say() { Q:CgOp {
        (prog [rawscall Console.WriteLine
                (unbox String (@ {self}))]
              [box Bool (bool 1)]
        )
    } }
    method substr($from, $len) { Q:CgOp {
        (box Str (rawcall [unbox String (@ {self})] Substring
                    [cast Int32 (unbox Double (@ {$from}))]
                    [cast Int32 (unbox Double (@ {$len}))]))
    } }
}

my class Scalar {
    has $!value;
}

my class Sub {
    has $!outer;
    has $!info;

    # Should be for Block, not Sub
    method ACCEPTS($t) { (self)($t) }
}

my class ClassHOW {
    has $!value;
    method isa($obj, $type) { Q:CgOp {
        (box Bool (rawcall (@ {$obj}) Isa
          (getfield klass (cast DynObject (@ {$type})))))
    } }
    method does($obj, $role) { self.isa($obj, $role) } #no roles yet
}

my class EnumType is Cool { }
my class Bool is EnumType {
    has $!value;
    method Str() { self ?? "Bool::True" !! "Bool::False" }
    method Bool() { self }
    method ACCEPTS($) { self }
    method Numeric() { self ?? 1 !! 0 }
    our constant True  = Q:CgOp { (box Bool (bool 1)) };
    our constant False = Q:CgOp { (box Bool (bool 0)) };
}
# TODO: import
constant True  = Q:CgOp { (box Bool (bool 1)) };
constant False = Q:CgOp { (box Bool (bool 0)) };

# taking a slurpy is wrong for this due to flattening.  I'm not sure what is
# right, maybe **@foo
sub infix:<~> is rawcall { Q:CgOp {
    (letn buf (rawnew System.Text.StringBuilder)
          i   (int 0)
          max (getfield Length (getfield pos (callframe)))
      [whileloop 0 0 (< (l i) (l max)) (prog
          [rawcall (l buf) Append
            (unbox String (@ (methodcall (pos (l i)) Str)))]
          [l i (+ (l i) (int 1))])]
      [box Str (rawcall (l buf) ToString)])
} }

sub infix:<+>($l,$r) { Q:CgOp {
    (box Num (+ (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<->($l,$r) { Q:CgOp {
    (box Num (- (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<*>($l,$r) { Q:CgOp {
    (box Num (* (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:</>($l,$r) { Q:CgOp {
    (box Num (/ (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< < >>($l,$r) { Q:CgOp {
    (box Bool (< (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< > >>($l,$r) { Q:CgOp {
    (box Bool (> (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< <= >>($l,$r) { Q:CgOp {
    (box Bool (<= (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< >= >>($l,$r) { Q:CgOp {
    (box Bool (>= (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< == >>($l,$r) { Q:CgOp {
    (box Bool (== (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< != >>($l,$r) { Q:CgOp {
    (box Bool (!= (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub warn($str) { Q:CgOp {
    (prog [rawscall Console.Error.WriteLine
            (unbox String (@ {$str.Str}))]
          [box Bool (bool 1)]
    )
} }

sub say($obj) { ($obj ~~ Cool) ?? $obj.say !! $obj.Str.say }

sub exit() { Q:CgOp {
    (prog [rawscall System.Environment.Exit (int 0) ]
          [null Variable]
    )
} }

sub infix:<=> is rawcall { Q:CgOp { (prog [assign (pos 0) (pos 1)] (pos 0)) } }

# Buglet in STD: standard infix operators look custom inside the setting, and
# forget their precedence.
sub prefix:<-->($v) { $v = ($v - 1); $v }
sub prefix:<++>($v) { $v = ($v + 1); $v }
sub postfix:<-->($v) { my $old = $v; $v = ($v - 1); $old }
sub postfix:<++>($v) { my $old = $v; $v = ($v + 1); $old }

sub prefix:<~>($v) { $v.Str } # should be Stringy
sub prefix:<?>($v) { $v.Bool }
sub prefix:<->($v) { 0 - $v }
sub prefix:<+>($x) { $x.Numeric }

sub prefix:<!>($v) { $v ?? False !! True }

sub infix:<eq>($l,$r) { Q:CgOp {
    (box Bool (compare == (unbox String (@ {$l.Str}))
      (unbox String (@ {$r.Str}))))
} }
sub infix:<ne>($l,$r) { Q:CgOp {
    (box Bool (compare != (unbox String (@ {$l.Str}))
      (unbox String (@ {$r.Str}))))
} }
# this one is horribly wrong and only handles the ref eq case.
sub infix:<===>($l,$r) { Q:CgOp {
    (box Bool (compare == (@ {$l}) (@ {$r})))
} }

sub infix:<~~>($t,$m) { ($m.defined) ?? ($m.ACCEPTS($t)) !! ($t.^does($m)) }

sub infix:<,>() {}

{YOU_ARE_HERE}
