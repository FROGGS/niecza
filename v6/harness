use Metamodel;
use Op;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use CgOp;
use NieczaActions;
use Metamodel;
use CClass;
use Sig;
use OptRxSimple;
use RxOp;

augment class Metamodel::Namespace {
}
augment class NieczaActions {
sub node($M) { { file => $*FILE<name>, line => $M.cursor.lineof($M.to) } }
sub mkcall($/, $name, *@positionals) {
    ::Op::CallSub.new(|node($/),
        invocant => ::Op::Lexical.new(|node($/), :$name), :@positionals);
}
my %loose2tight = (
    '&&' => '&&', '||' => '||', '//' => '//', 'andthen' => 'andthen',
    'orelse' => '//', 'and' => '&&', 'or' => '||',
);

method get_op_sym($M) {
    if $M.reduced eq '::($name)' { # XXX STD miscompilation
        return ~$M;
    } elsif $M.reduced ~~ /\:sym\<(.*)\>/ {
        return ~$0;
    } elsif $M.reduced ~~ /\:(\w+)/ {
        return ~$0;
    } elsif $M.reduced eq 'PRE' {
        return ~$M; # TODO: replace with better metaop
    } else {
        die "Cannot extract operator symbol ($M) ($M.reduced())";
    }
}

# XXX Niecza  Needs improvement
method FALLBACK($meth, $/) {
    if $meth eq '::($name)' { # XXX STD miscompilation
        if $<O><prec> eq 't=' { # additive
            make ::Op::Lexical.new(|node($/), name => '&infix:<' ~ self.get_op_sym($/) ~ '>');
        }
        return Nil;
    } elsif substr($meth,0,7) eq 'prefix:' {
    } elsif substr($meth,0,8) eq 'postfix:' {
    } elsif substr($meth,0,6) eq 'infix:' {
        make ::Op::Lexical.new(|node($/), name => '&infix:<' ~ self.get_op_sym($/) ~ '>');
        return Nil;
    } else {
        $/.CURSOR.sorry("Action method $meth not yet implemented");
    }
}
method postop($/) {
    make $<postcircumfix> ?? $<postcircumfix>.ast !!
        { postfix => self.get_op_sym($<postfix>) };
}

method PREFIX($/) {
    my $op = "\&prefix:<{ self.get_op_sym($<op>) }>";
    my $rarg = $<arg>.ast;

    # Macros
    if $op eq '&prefix:<temp>' {
        if !$rarg.^isa(::Op::ContextVar) || $rarg.uplevel {
            $/.CURSOR.sorry('Non-contextual case of temp NYI');
            make ::Op::StatementList.new;
            return Nil;
        }
        make mkcall($/, '&infix:<=>',
            ::Op::Lexical.new(name => $rarg.name, declaring => True,
                        hash => substr($rarg.name,0,1) eq '%',
                        list => substr($rarg.name,0,1) eq '@'),
            ::Op::ContextVar.new(name => $rarg.name, uplevel => 1));
        return Nil;
    }

    my ($st, $arg) = self.whatever_precheck($op, $rarg);
    make self.whatever_postcheck($/, $st, mkcall($/, $op, $arg));
}
method named_param($/) {
    my %rt;
    sub good($a, $b is rw) { $a ~~ /^<[@$%]><[.*!]>?(.*)/ && ($b = [~$0]; True) }
    if $<name> {
        if $<named_param> {
            %rt = %( $<named_param>.ast );
        } else {
            %rt = %( $<param_var>.ast );
        }
        %rt<names> = [ @( %rt<names> // [] ), ~$<name> ];
    } else {
        %rt = %( $<param_var>.ast );
        if %rt<slot> && good(%rt<slot>, %rt<names>) {
        } else {
            $/.CURSOR.sorry("Abbreviated named parameter must have a name");
        }
    }
    %rt<positional> = False;
    make %rt;
}
sub _isinfix($out is rw, $str) {
    $str ~~ /'&infix:<'(.*)'>'/ && ($out = $0; True)
}
method LIST($/) {
    if $/.CURSOR.^isa(::STD::Regex) {
        self.LISTrx($/);
        return Nil;
    }
    # STD guarantees that all elements of delims have the same sym
    # the last item may have an ast of undef due to nulltermish
    my $fn = $<delims>[0].ast;
    my $opn = $fn.^isa(::Op::Lexical) ?? $fn.name !!
        ($fn.^isa(::Op::CallSub) && $fn.invocant.^isa(::Op::Lexical)) ??
            $fn.invocant.name !! '';
    _isinfix((my $op), $opn);
    my ($st, @pos) = self.whatever_precheck($opn,
        grep *.&defined, map *.ast, @( $<list> ));

    if $op eq ',' {
        make ::Op::SimpleParcel.new(|node($/), items => @pos);
    } elsif %loose2tight{$op} {
        make ::Op::ShortCircuit.new(|node($/), kind => %loose2tight{$op},
            args => @pos);
    } else {
        make ::Op::CallSub.new(|node($/), invocant => $fn,
            positionals => @pos);
    }
    make self.whatever_postcheck($/, $st, $/.ast);
}

}

# XXX mega hack.
my class Instant {
    has $.val;
    method to-posix() { $!val }
}

my class IO {
    has $.path; # Str

    method Str() { $.path }
    method IO() { self }

    method slurp() { slurp $.path }
    method spew($text) { spew $.path, $text }

    method combine(*@paths) {
        die "Sorry, paths do not form a monoid." unless @paths;
        my $acc = @paths.shift.IO;
        for @paths { $acc = $acc.append($_) }
        $acc
    }

    method f() { Q:CgOp { (box Bool (rawscall System.IO.File.Exists (obj_getstr {$!path}))) } }
    method d() { Q:CgOp { (box Bool (rawscall System.IO.Directory.Exists (obj_getstr {$!path}))) } }
    method e() { self.f || self.d }
    method relative($base) { $base.IO.append(self) }
    method append($sub) { Q:CgOp { (box Str (rawscall System.IO.Path.Combine (obj_getstr {self}) (obj_getstr {$sub}))) }.IO }
    method but-extension($ext) { Q:CgOp { (box Str (rawscall System.IO.Path.ChangeExtension (obj_getstr {self}) (obj_getstr {$ext}))) }.IO }
    method realpath() { Q:CgOp { (box Str (rawscall System.IO.Path.GetFullPath (obj_getstr {self}))) }.IO }
    method modified() { Instant.new(val => Q:CgOp { (rawscall Builtins,Kernel.GetModTime (obj_getstr {self})) }) }
}

augment class Op::Lexical {
    method code_bvalue($ , $ro, $rhscg) {
        CgOp.prog(
            CgOp.scopedlex($.name, CgOp.newboundvar(+$ro, +($.list || $.hash), $rhscg)),
            CgOp.scopedlex($.name));
    }
}
augment class Op::PackageVar {
    method code_bvalue($ , $ro, $rhscg) {
        CgOp.prog(
            CgOp.scopedlex($.slot,
                CgOp.newboundvar(+$ro, +($.list || $.hash), $rhscg)),
            CgOp.scopedlex($.slot));
    }
}

augment class RxOp::CClassElem {
    method lad() { [ 'CC', @( $.cc.terms ) ] }
}

augment class Metamodel::StaticSub {
}

augment class Str {
    method IO() { IO.new(path => self) }
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => ["../lib", "."],
    ),
    frontend => NieczaFrontendSTD.new(
        lang => 'CORE',
        safemode => False,
    ),
    stages => [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ],
    backend => NieczaBackendNAM.new(
        obj_dir => 'obj',
    ),
    verbose => True,
);

#$c.compile_module("SAFE");
#$c.compile_module("CORE");
$c.compile_string("say 'Hello, world'", False);
