# vim: ft=perl6 fdm=marker
my module SAFE;

# Fundamental types {{{
my class Mu {
    # rawcall to avoid putting a rw binding on self... TODO
    method defined is rawcall {
        Q:CgOp { (box Bool (rawcall (@ (pos 0)) IsDefined)) }
    }
    method head { @(self).head }
    method Bool() { self.defined }
    method Str() {
        my $tn := Q:CgOp { (box Str (rawcall (@ {self}) GetTypeName)) };
        if self.defined {
            $tn ~ "()<instance>"
        } else {
            $tn ~ "()"
        }
    }
    method so() { self.Bool }
    method not() { ! self.Bool }
    method RAWCREATE is rawcall { Q:CgOp {
        (withtypes i Int32 max Int32 obj DynObject
          [l max (getfield Length (getfield pos (callframe)))]
          [l i (int 1)]
          [l obj (rawnew DynObject (getfield klass (cast DynObject
                  (@ (pos 0)))))]
          [whileloop 0 0 (< (l i) (l max)) (prog
              [rawcall (l obj) SetSlot
                (unbox String (@ (pos (l i))))
                (nsw (@ (pos (+ (l i) (int 1)))))]
              [l i (+ (l i) (int 2))])]
          [ns (l obj)])
    } }
    method bless($obj) { Q:CgOp {
        (prog
          [setfield klass (cast DynObject (@ {$obj}))
            (getfield klass (cast DynObject (@ {self})))]
          {$obj})
    } }
    method CREATE() { Q:CgOp {
        (rawscall Kernel.DefaultNew (@ (l self))) } }
    method new() { Q:CgOp { (rawscall Kernel.DefaultNew (@ {self})) } }
}

my class Any is Mu {
    method at-pos($ix) {
        ($ix == 0) ?? self !! die("Invalid index on non-list")
    }
    method flat() { (self,).flat }

    method ACCEPTS($t) { self === $t }
    method !butWHENCE($cr) {
        Q:CgOp { (rawnew SimpleVariable (bool 1) (bool 0) (@ {$cr}) (@ {self})) }
    }
}

my class Cool {
    method grep($sm) {
        my $itp = @(self).clone;
        gather while $itp {
            my $r = $itp.shift;
            take $r if $r ~~ $sm;
        }
    }
    method map($func) {
        my $itp = @(self).clone;
        gather while $itp {
            my $r = $itp.shift;
            take $func($r);
        }
    }
    method for($func) {
        my $itp = @(self).clone;
        while $itp {
            my $r = $itp.shift;
            $func($r);
        }
    }

    method say() { self.Str.say }
    method chars() { self.Str.chars }
    method substr($x,$y) { self.Str.substr($x,$y) }

    method at-pos($i) { self.flat.at-pos($i) }
    method elems() { self.flat.elems }
    method iterator() { self.flat.iterator }
    method join($sep) { self.flat.join($sep) }
}
# }}}
# Scalar types {{{
my class Num is Cool {
    has $!value;
    method Str () { Q:CgOp {
        (box Str (rawcall (unbox Double (@ {self})) ToString))
    } }
    method Bool() { Q:CgOp {
        (box Bool (compare != (double 0)
                    (unbox Double (@ {self}))))
    } }
    method Numeric() { self }
    method ACCEPTS($t) { self == $t }
}

my class Str is Cool {
    has $!value;
    method Str () { self }
    method ACCEPTS($t) { self eq $t }
    method chars() { Q:CgOp {
        (box Num (cast Double (getfield Length (unbox String (@ (l self))))))
    } }
    method say() { Q:CgOp {
        (prog [rawscall Console.WriteLine
                (unbox String (@ {self}))]
              [box Bool (bool 1)]
        )
    } }
    method substr($from, $len) { Q:CgOp {
        (box Str (rawcall [unbox String (@ {self})] Substring
                    [cast Int32 (unbox Double (@ {$from}))]
                    [cast Int32 (unbox Double (@ {$len}))]))
    } }
}

my class Scalar {
    has $!value;
}

my class Sub {
    has $!outer;
    has $!info;

    # Should be for Block, not Sub
    method ACCEPTS($t) { (self)($t) }
}

my class ClassHOW {
    has $!value;
    method isa($obj, $type) { Q:CgOp {
        (box Bool (rawcall (@ {$obj}) Isa
          (getfield klass (cast DynObject (@ {$type})))))
    } }
    method does($obj, $role) { self.isa($obj, $role) } #no roles yet
}

my class EnumType is Cool { }
my class Bool is EnumType {
    has $!value;
    method Str() { self ?? "Bool::True" !! "Bool::False" }
    method Bool() { self }
    method ACCEPTS($) { self }
    method Numeric() { self ?? 1 !! 0 }
    our constant True  = Q:CgOp { (box Bool (bool 1)) };
    our constant False = Q:CgOp { (box Bool (bool 0)) };
}
# TODO: import
constant True  = Q:CgOp { (box Bool (bool 1)) };
constant False = Q:CgOp { (box Bool (bool 0)) };
# }}}
# Fundamental scalar operators {{{
# taking a slurpy is wrong for this due to flattening.  I'm not sure what is
# right, maybe **@foo
sub infix:<~> is rawcall { Q:CgOp {
    (letn buf (rawnew System.Text.StringBuilder)
          i   (int 0)
          max (getfield Length (getfield pos (callframe)))
      [whileloop 0 0 (< (l i) (l max)) (prog
          [rawcall (l buf) Append
            (unbox String (@ (methodcall (pos (l i)) Str)))]
          [l i (+ (l i) (int 1))])]
      [box Str (rawcall (l buf) ToString)])
} }

sub infix:<+>($l,$r) { Q:CgOp {
    (box Num (+ (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<->($l,$r) { Q:CgOp {
    (box Num (- (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<*>($l,$r) { Q:CgOp {
    (box Num (* (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:</>($l,$r) { Q:CgOp {
    (box Num (/ (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< < >>($l,$r) { Q:CgOp {
    (box Bool (< (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< > >>($l,$r) { Q:CgOp {
    (box Bool (> (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< <= >>($l,$r) { Q:CgOp {
    (box Bool (<= (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< >= >>($l,$r) { Q:CgOp {
    (box Bool (>= (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< == >>($l,$r) { Q:CgOp {
    (box Bool (== (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub infix:<< != >>($l,$r) { Q:CgOp {
    (box Bool (!= (unbox Double (@ {$l})) (unbox Double (@ {$r}))))
} }

sub warn($str) { Q:CgOp {
    (prog [rawscall Console.Error.WriteLine
            (unbox String (@ {$str.Str}))]
          [box Bool (bool 1)]
    )
} }

sub say($obj) { ($obj ~~ Cool) ?? $obj.say !! $obj.Str.say }

sub exit() { Q:CgOp {
    (prog [rawscall System.Environment.Exit (int 0) ]
          [null Variable]
    )
} }

sub infix:<=> is rawcall { Q:CgOp { (prog [assign (pos 0) (pos 1)] (pos 0)) } }

# Buglet in STD: standard infix operators look custom inside the setting, and
# forget their precedence.
sub prefix:<-->($v) { $v = ($v - 1); $v }
sub prefix:<++>($v) { $v = ($v + 1); $v }
sub postfix:<-->($v) { my $old = $v; $v = ($v - 1); $old }
sub postfix:<++>($v) { my $old = $v; $v = ($v + 1); $old }

sub prefix:<~>($v) { $v.Str } # should be Stringy
sub prefix:<?>($v) { $v.Bool }
sub prefix:<->($v) { 0 - $v }
sub prefix:<+>($x) { $x.Numeric }

sub prefix:<!>($v) { $v ?? False !! True }

sub infix:<eq>($l,$r) { Q:CgOp {
    (box Bool (compare == (unbox String (@ {$l.Str}))
      (unbox String (@ {$r.Str}))))
} }
sub infix:<ne>($l,$r) { Q:CgOp {
    (box Bool (compare != (unbox String (@ {$l.Str}))
      (unbox String (@ {$r.Str}))))
} }
# this one is horribly wrong and only handles the ref eq case.
sub infix:<===>($l,$r) { Q:CgOp {
    (box Bool (compare == (@ {$l}) (@ {$r})))
} }

sub infix:<~~>($t,$m) { ($m.defined) ?? ($m.ACCEPTS($t)) !! ($t.^does($m)) }
# }}}
# Aggregate types {{{
# Parcel: immutable list of boxes which have no context - may flatten, may
# autovivify, don't rebind or push/shift/etc
# List: mutable list of boxes without much context.  accessing off end returns
# undefined.  lazy.
# Seq: mutable list of boxes which are taken to be read-only scalars. The .Seq
# coercion makes the elements of a List read-only and maybe fetches them too.
# Array: mutable list of read-write scalar boxes

sub unitem is rawcall {
    Q:CgOp { (newrwlistvar (@ (pos 0))) }
}

my class Iterator {
    # subclasses must provide .reify, return parcel
}

sub flat(*@x) { @x }

my class Whatever { }

my class EMPTY { }

my class List { ... }
my class Seq { ... }
my class Array { ... }

my class Parcel is Cool {
    has $!value;
    # $!value -> Variable[]

    method flat() { List.SETUP(True, self) }
    method list() { List.SETUP(False, self) }

    method elems() { Q:CgOp {
        (box Num (cast Double (getfield Length
              (unbox 'Variable[]' (@ {self})))))
    } }

    method iterator() {
        my class ParcelIterator is Iterator {
            has $.reify;
        }
        ParcelIterator.RAWCREATE("reify", self);
    }
}

# Maybe this should be a constant, but constants are currently forced to
# scalar-nature (TODO)
sub Nil is rawcall { Q:CgOp { (newrwlistvar (@ (box Parcel (rawnewarr 'Variable')))) } }

my class List is Cool {
    has @!items;
    has @!rest;
    has $!flat;
    method flat() {
        unitem(Q:CgOp { (box Bool (getslot (s flat) (@ {self}))) }
            ?? self !! self.SETUP(True, (&infix:<,>(self.iterator))));
    }
    method list() { unitem(self) }

    method clone() { Q:CgOp {
        (letn dys (cast DynObject (@ {self}))
              new (rawnew DynObject (getfield klass (l dys)))
          (rawcall (l new) SetSlot (s flat)
            (rawcall (l dys) GetSlot (s flat)))
          (rawcall (l new) SetSlot (s items) (rawnew VarDeque
              (cast VarDeque (rawcall (l dys) GetSlot (s items)))))
          (rawcall (l new) SetSlot (s rest) (rawnew VarDeque
              (cast VarDeque (rawcall (l dys) GetSlot (s rest)))))
          (newrwlistvar (l new)))
    } }

    method SETUP($flat, $parcel) { Q:CgOp {
        (letn new (rawnew DynObject (rawcall (@ {self}) GetMO))
          (rawcall (l new) SetSlot (s flat) (unbox Boolean (@ {$flat.Bool})))
          (rawcall (l new) SetSlot (s rest) (rawnew VarDeque
              (unbox 'Variable[]' (@ {$parcel}))))
          (rawcall (l new) SetSlot (s items) (rawnew VarDeque))
          (newrwlistvar (l new)))
    } }

    method Seq() {
        Seq.SETUP(True, (&infix:<,>(self.iterator)));
    }

    #| Takes an object and applies whatever semantics the List subclass
    #| needs to apply on stuff out of the iterator stack
    method !elem is rawcall { Q:CgOp { (pos 1) } }

    sub has-iterators($self) { Q:CgOp {
        (box Bool (!= (i 0) (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s rest))) Count)))
    } }

    sub count-items($self) { Q:CgOp {
        (box Num (cast Double (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s items))) Count)))
    } }

    sub shift-iterator($self) { Q:CgOp {
        (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s rest))) Shift)
    } }

    sub shift-item($self) { Q:CgOp {
        (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s items))) Shift)
    } }

    method !item-at-pos($ix) { Q:CgOp {
        (getindex (cast Int32 (unbox Double (@ {$ix}))) (cast VarDeque (rawcall (cast DynObject (@ {self})) GetSlot (s items))))
    } }

    sub pop-item($self) { Q:CgOp {
        (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s items))) Pop)
    } }

    sub push-iterator is rawcall { Q:CgOp {
        (prog (rawcall (cast VarDeque (rawcall (cast DynObject (@ (pos 0))) GetSlot (s rest))) Push (pos 1)) (null Variable))
    } }

    sub push-item is rawcall { Q:CgOp {
        (prog (rawcall (cast VarDeque (rawcall (cast DynObject (@ (pos 0))) GetSlot (s items))) Push (pos 1)) (null Variable))
    } }

    method !fill($nr) { Q:CgOp {
        (letn  nr    (cast Int32 (unbox Double (@ {$nr})))
               items (cast VarDeque (getslot (s items) (@ {self})))
               rest  (cast VarDeque (getslot (s rest) (@ {self})))
               flat  (cast Boolean  (getslot (s flat) (@ {self})))
               v     (null Variable)
               ItMo  (rawcall (@ {Iterator}) GetMO)
          (whileloop 0 0
            (ternary (< (rawcall (l items) Count) (l nr))
              (!= (rawcall (l rest) Count) (i 0)) (b 0))
            (prog
              (l v (rawcall (l rest) Shift))
              (ternary (ternary (l flat) (getfield islist (l v)) (b 0))
                (rawcall (l rest) Unshift (methodcall (l v) iterator))
                (ternary (rawcall (@ (l v)) Isa (l ItMo))
                  (rawcall (l rest) UnshiftN (unbox 'Variable[]'
                      (@ (methodcall (l v) reify))))
                  (rawcall (l items) Push (methodcall {self} !elem (l v)))))))
          (box Bool (>= (rawcall (l items) Count) (l nr))))
    } }

    method Bool() { self!fill(1) }
    method shift() {
        self!fill(1);
        shift-item(self);
    }

    method eager() {
        self!fill(1_000_000_000);
        self;
    }

    method head { self!fill(1) ?? self!item-at-pos(0) !! Any }

    method elems() { self!fill(1000_000_000); count-items(self); }
    method Numeric () { self.elems }

    method at-pos($i) {
        self!fill($i + 1);
        self!item-at-pos($i);
    }

    method iterator() {
        my class ListIterator is Iterator {
            has $!list;
            has $!reify;
            method reify() {
                $!reify // ($!reify = (
                    $!list ??
                        ($!list.shift, ListIterator.RAWCREATE("list", $!list,
                            "reify", Any)) !!
                        &infix:<,>()));
            }
        }
        my $itp = self.clone;
        ListIterator.RAWCREATE("list", $itp, "reify", Any);
    }

    method join($sep) {
        my $t;
        for self.flat -> $x {
            $t = ($t.defined ?? ($t ~ ($sep ~ $x)) !! $x);
        }
        $t // '';
    }

    method Str() { self.join(" ") }

    method push(*@items) {
        push-iterator(self, @items.Seq.eager.iterator)
    }
    method pop() {
        self.eager;
        pop-item(self);
    }
}

# exactly like List, but flattens, and with "is copy" semantics on stuff
my class Seq is List {
    method !elem($x) { my $y = $x; $y }
    method Seq { self }
}

my class Array is List {
    method new() {
        Array.SETUP(True, &infix:<,>())
    }

    method LISTSTORE(*@in) {
        # fetch everything NOW in case self is mentioned
        my $inn := @in.Seq.eager;

        Q:CgOp { (prog
            (rawcall (cast DynObject (@ {self})) SetSlot (s items)
              (rawcall (cast DynObject (@ {$inn})) GetSlot (s items)))
            (null Variable))
        };
        unitem(self);
    }

    method !extend is rawcall {
        Q:CgOp {
            (letn i (cast VarDeque (getslot (s items) (@ (pos 0))))
                  ct (- (cast Int32 (unbox Double (@ (pos 1))))
                        (rawcall (l i) Count))
              (ternary (>= (l ct) (int 0)) [prog]
                [die "Autovivification collision"])
              (whileloop 0 0 (!= (l ct) (int 0))
                (prog
                  (l ct (- (l ct) (int 1)))
                  (rawcall (l i) Push (newrwscalar (@ {Any})))))
              (rawcall (l i) Push (pos 2))
              (null Variable))
        };
    }

    method at-pos($ix) {
        self!fill($ix+1)
            ?? self!item-at-pos($ix)
            !! Any!butWHENCE(sub () is rawcall {
                self!extend($ix, Q:CgOp { (pos 0) });
            });
    }
}

my class Hash {
    has $!value;
    method new() { Q:CgOp { (box Hash (rawnew Dictionary<string,Variable>)) } }
    method !extend is rawcall {
        Q:CgOp {
            (letn d [unbox Dictionary<string,Variable> (@ (pos 0))]
                  k [unbox String (@ (methodcall (pos 1) Str))]
              [ternary (rawcall (l d) ContainsKey (l k))
                (die "Autovivification collision")
                (prog)]
              [setindex (l k) (l d) (pos 2)]
              [null Variable])
        };
    }

    # TODO: We need something like pir:: notation for this to not suck
    method at-key($key) {
        Q:CgOp {
            (box Bool (rawcall [unbox Dictionary<string,Variable> (@ (l self))]
                ContainsKey [unbox String (@ (methodcall (l $key) Str))]))
        }
            ?? Q:CgOp {
                (getindex [unbox String (@ (methodcall (l $key) Str))]
                  [unbox Dictionary<string,Variable> (@ (l self))])
            } !! Any!butWHENCE({ self!extend($key, Q:CgOp { (pos 0) }) });
    }
}

my class Enum is Cool {
    has $.key;
    has $.value;

    method kv() {
        ($.key, $.value);
    }

    method pairs() {
        self.flat;
    }
}

my class Pair is Enum {
}
# }}}
# List utilities {{{
sub postcircumfix:<[ ]> is rawcall {
    my $index ::= Q:CgOp { (pos 1) };

    (Q:CgOp { (pos 0) }).defined
        ?? (Q:CgOp { (pos 0) }).at-pos($index)
        !! Any!butWHENCE(sub () is rawcall {
            my $ar := Q:CgOp { (getindex (int 0) (getfield pos
                                 (getfield outer (callframe)))) };
            $ar.defined && die("Autovivification collision");
            $ar = Array.new;
            $ar!extend($index, Q:CgOp { (pos 0) });
        });
}

sub postcircumfix:<{ }> is rawcall {
    my $key ::= Q:CgOp { (pos 1) };

    (Q:CgOp { (pos 0) }).defined
        ?? (Q:CgOp { (pos 0) }).at-key($key)
        !! Any!butWHENCE(sub () is rawcall {
            my $ar := Q:CgOp { (getindex (int 0) (getfield pos
                                 (getfield outer (callframe)))) };
            $ar.defined && die("Autovivification collision");
            $ar = Hash.new;
            $ar!extend($key, Q:CgOp { (pos 0) });
        });
}

my class GatherIterator is Iterator {
    has $!frame;
    has $!reify;

    method reify() {
        my $*nextframe;
        $!reify // ($!reify = (
            Q:CgOp {
                (letn getv (rawsccall Kernel.CoTake (cast Frame
                    (@ {$!frame})))
                  (box Parcel (ternary (== (@ {EMPTY}) (@ (l getv)))
                    (rawnewarr Variable)
                    (rawnewarr Variable
                      (l getv)
                      {GatherIterator.RAWCREATE("frame", $*nextframe, "reify", Any)}))))
            }));
    }
}

sub _gather($fr) {
    List.SETUP(True, (&infix:<,>(GatherIterator.RAWCREATE("frame", $fr,
        "reify", Any))));
}

sub take($p) { # should be \|$p
    Q:CgOp { (rawsccall Kernel.Take (l $p)) }
}

sub infix:<< => >>($k, $v) { Pair.RAWCREATE("key", $k, "value", $v) }

sub infix:<,> is rawcall {
    Q:CgOp { (newrwlistvar (@ (box Parcel (getfield pos (callframe))))) };
}
# }}}
# Flow inspection and control {{{
my class CallFrame {
    method caller() { Q:CgOp {
        (letn c (getfield caller (cast Frame (@ (l self))))
          (ternary
            (!= (letvar c) (null Frame))
            (ns (letvar c))
            (l Any)))
    } }
    method outer() { Q:CgOp {
        (letn c (getfield outer (cast Frame (@ (l self))))
          (ternary
            (!= (letvar c) (null Frame))
            (ns (letvar c))
            (l Any)))
    } }

    method file() { Q:CgOp { (box Str (rawcall
        (cast Frame (@ (l self))) ExecutingFile)) } }
    method line() { Q:CgOp { (box Num (cast Double (rawcall
        (cast Frame (@ (l self))) ExecutingLine))) } }

    method hints($var) { Q:CgOp { (rawcall (cast Frame (@ (l self)))
        LexicalFind (unbox String (@ (l $var)))) } }
}

sub caller { Q:CgOp { (ns (getfield caller (getfield caller (callframe)))) } }
sub callframe { Q:CgOp { (ns (getfield caller (callframe))) } }

sub die($msg) { Q:CgOp { (prog (die (@ (l $msg))) (null Variable)) } }

# XXX multi dispatch
sub next {
    Q:CgOp { (rawsccall Kernel.SearchForHandler (int 1) (null Frame) (int -1) (null String) (null Variable)) }
}
sub last {
    Q:CgOp { (rawsccall Kernel.SearchForHandler (int 2) (null Frame) (int -1) (null String) (null Variable)) }
}
sub redo {
    Q:CgOp { (rawsccall Kernel.SearchForHandler (int 3) (null Frame) (int -1) (null String) (null Variable)) }
}
sub return is rawcall {
    Q:CgOp { (rawsccall Kernel.SearchForHandler (int 4) (null Frame) (int -1) (null String) (pos 0)) }
}

sub assignop($fn) {
    anon sub ANON is rawcall {
        Q:CgOp { (pos 0) } = $fn(Q:CgOp { (pos 0) }, Q:CgOp { (pos 1) })
    }
}
# }}}
# Regular expression support {{{
my class Cursor {
    method new($str) { Q:CgOp { (ns (rawnew Cursor
        (@ {self}) (unbox System.String (@ {$str})))) } }
    method pos { Q:CgOp { (box Num (cast Double (getfield pos
        (cast Cursor (@ {self}))))) } }
    method cursor($np) { Q:CgOp { (ns (rawcall
        (cast Cursor (@ {self})) At
          (cast Int32 (unbox Double (@ {$np}))))) } }
    method orig { Q:CgOp {
        (box Str (getfield backing (cast Cursor (@ {self})))) } }
    method ws() { Q:CgOp { (rawcall (cast Cursor (@ {self})) SimpleWS) } }
    method at-key($k) { Q:CgOp {
        (rawcall (cast Cursor (@ {self})) GetKey (unbox String (@ {$k.Str})))
    } }
    method at-pos($i) { self.at-key($i) }
}

my class Match {
    method at-key($k) { Q:CgOp {
        (rawcall (cast Cursor (@ {self})) GetKey (unbox String (@ {$k.Str})))
    } }
    method at-pos($i) { self.at-key($i) }
    method new($) { die "Match.new NYI" }
    method from { Q:CgOp { (box Num (cast Double (getfield from
        (cast Cursor (@ {self}))))) } }
    method to { Q:CgOp { (box Num (cast Double (getfield pos
        (cast Cursor (@ {self}))))) } }
    method orig { Q:CgOp {
        (box Str (getfield backing (cast Cursor (@ {self})))) } }
    method chars { $.defined ?? $.to - $.from !! 0 }
    method Str { $.defined ?? $.orig.substr($.from, $.chars) !! "" }
}

my class Regex is Sub {
    method ACCEPTS($str) {
        my $i = 0;
        my $mat;
        my $C = Cursor.new($str);
        while !$mat && ($i <= $str.chars) {
            $mat = (self)($C.cursor($i++));
        }
        $mat.head;
    }
}

my class Grammar is Cursor {
    method parse($text) {
        my @results := self.new($text).TOP\
            .grep({ $_.to == $text.chars });
        @results ?? @results.shift !! Any; # TODO List.at-pos
    }
}
# }}}

{YOU_ARE_HERE}
