use Metamodel;
use Op;
use RxOp;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaBackendHoopl;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;
use OptRxSimple;
use STD;
use Sig;

augment class NieczaActions {
method method_def ($/) {
    make ::Op::StatementList.new;
    my $scope = $*SCOPE // 'has';
    my $type = $<type> ?? ~$<type> !! '';
    $type = ($type eq ''  ?? 'normal' !!
             $type eq '^' ?? 'meta' !!
             $type eq '!' ?? 'private' !!
             (
                 $/.CURSOR.sorry("Unhandled method decoration $type");
                 return Nil;
             ));
    $scope = 'anon' if !$<longname>;
    my $name = $<longname> ?? self.unqual_longname($<longname>,
        "Qualified method definitions not understood") !! Any; #XXX

    if $<sigil> {
        $/.CURSOR.sorry("Method sgils NYI");
        return Nil;
    }
    if $type eq 'meta' {
        $/.CURSOR.sorry("Metamethod mixins NYI");
        return Nil;
    }
    if $<multisig> > 1 {
        $/.CURSOR.sorry("Multiple multisigs (what?) NYI");
        return Nil;
    }

    if ($scope eq 'augment' || $scope eq 'supersede' || $scope eq 'state') {
        $/.CURSOR.sorry("Illogical scope $scope for method");
        return Nil;
    }

    if ($scope eq 'our') {
        $/.CURSOR.sorry("Packages NYI");
        return Nil;
    }
    my $sig = $<multisig> ?? $<multisig>[0].ast !!
        self.get_placeholder_sig($/);

    my $unsafe = False;
    for @( $<trait> ) -> $t {
        if $t.ast<nobinder> {
            $sig = Any;
        } elsif $t.ast<unsafe> {
            $unsafe = True;
        } elsif $t.ast<of> {
        } elsif $t.ast<rw> {
        } else {
            $/.CURSOR.sorry("NYI method trait $t");
        }
    }

    my $bl = self.sl_to_block('sub', $<blockoid>.ast,
        subname => $name, :$unsafe,
        signature => $sig ?? $sig.for_method !! Any);

    make self.block_to_closure($/, $bl, bindlex => ($scope eq 'my'),
        multiness => ($*MULTINESS || Any),
        bindmethod => ($scope ne 'anon' ?? [ $type, $name ] !! Any));
}

method routine_def ($/) {
    make ::Op::StatementList.new;
    if $<sigil> && $<sigil>[0] eq '&*' {
        $/.CURSOR.sorry("Contextual sub definitions NYI");
        return Nil;
    }
    my $dln = $<deflongname>[0];
    if $<multisig> > 1 {
        $/.CURSOR.sorry("Multiple multisigs (what?) NYI");
        return Nil;
    }
    my @export;
    my $return_pass = 0;
    my $signature = $<multisig> ?? $<multisig>[0].ast !!
        self.get_placeholder_sig($/);
    my $unsafe = False;
    for @( $<trait> ) -> $t {
        if $t.ast.<export> {
            push @export, @( $t.ast<export> );
        } elsif $t.ast<nobinder> {
            $signature = Any;
        } elsif $t.ast<return_pass> {
            $return_pass = 1;
        } elsif $t.ast<of> {
        } elsif $t.ast<rw> {
        } elsif $t.ast<unsafe> {
            $unsafe = True;
        } else {
            $/.CURSOR.sorry("Sub trait $t.ast.keys.[0] not available");
        }
    }
    my $scope = !$dln ?? 'anon' !! ($*SCOPE || 'my');
    my ($m,$p) = $dln ?? self.mangle_longname($dln).<name path> !! ();

    if $scope ne 'my' && $scope ne 'our' && $scope ne 'anon' {
        $/.CURSOR.sorry("Illegal scope $scope for subroutine");
        return Nil;
    }
    if $scope eq 'our' {
        $/.CURSOR.sorry('Package subs NYI');
        return Nil;
    } elsif $p {
        $/.CURSOR.sorry('Defining a non-our sub with a package-qualified name makes no sense');
        return Nil;
    }

    make self.block_to_closure($/,
        bindlex => ($scope eq 'my'),
        multiness => ($*MULTINESS || Any),
        self.sl_to_block('sub',
            $<blockoid>.ast,
            returnable => !$return_pass,
            subname => $m, :$unsafe,
            signature => $signature),
        bindpackages => @export);
}

method variable_declarator($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    for @$<trait> -> $t {
        if $t.ast<rw> {
        } else {
            $/.CURSOR.sorry("Trait $t.ast.keys.[0] not available on variables");
        }
    }
    if $<post_constraint> || $<postcircumfix> || $<semilist> {
        $/.CURSOR.sorry("Postconstraints, and shapes on variable declarators NYI");
    }

    my $scope = $*SCOPE // 'my';

    if $scope eq 'augment' || $scope eq 'supersede' {
        $/.CURSOR.sorry("Illogical scope $scope for simple variable");
    }

    my $typeconstraint;
    if $*OFTYPE {
        $typeconstraint = self.simple_longname($*OFTYPE<longname>);
        $/.CURSOR.sorry("Common variables are not unique definitions and may not have types") if $scope eq 'our';
    }

    my $v = $<variable>.ast;
    my $t = $v<twigil>;
    if ($t && defined "?=~^:".index($t)) {
        $/.CURSOR.sorry("Variables with the $t twigil cannot be declared " ~
            "using $scope; they are created " ~
            ($t eq '?' ?? "using 'constant'." !!
             $t eq '=' ?? "by parsing POD blocks." !!
             $t eq '~' ?? "by 'slang' definitions." !!
             "automatically as parameters to the current block."));
    }

    if $scope ne 'has' && ($t eq '.' || $t eq '!') {
        $/.CURSOR.sorry("Twigil $t is only valid on attribute definitions ('has').");
    }

    if defined $v<rest> {
        $/.CURSOR.sorry(":: syntax is only valid when referencing variables, not when defining them.");
    }

    my $name = $v<sigil> ~ $v<twigil> ~ $v<name>;
    # otherwise identical to my
    my $slot = ($scope eq 'anon') ?? self.gensym !! $name;

    if $scope eq 'has' {
        make ::Op::Attribute.new(|node($/), name => $v<name>,
            accessor => $t eq '.', :$typeconstraint);
    } elsif $scope eq 'state' {
        make ::Op::Lexical.new(|node($/), name => $slot, state_decl => True,
            state_backing => self.gensym, declaring => True, :$typeconstraint,
            list => $v<sigil> eq '@', hash => $v<sigil> eq '%');
    } elsif $scope eq 'our' {
        make ::Op::PackageVar.new(|node($/), name => $slot, slot => $slot,
            path => [ 'OUR' ]);
    } else {
        make ::Op::Lexical.new(|node($/), name => $slot, declaring => True,
            list => $v<sigil> eq '@', hash => $v<sigil> eq '%', :$typeconstraint);
    }
}


method integer($/) {
    $<decint> andthen make [10, ~$<decint>];
    $<octint> andthen make [8,  ~$<octint>];
    $<hexint> andthen make [16, ~$<hexint>];
    $<binint> andthen make [2,  ~$<binint>];
}

method dec_number ($/) {
    if $<escale> { make +((~$/).comb(/<-[_]>/).join("")) }
    else { make [10, ~$/] }
}

method number($/) {
    my $child = $<integer> // $<dec_number> // $<rad_number>;
    make (defined($child) ?? $child.ast !!
        $child eq 'NaN' ?? NaN !! Inf);
}
}

augment class RxOp { #OK exist
method ctxopzyg()  { map *.ctxopzyg, @$!zyg }
}

augment class RxOp::VarString { #OK exist
    method ctxopzyg() { $!ops, 1 }
}

augment class RxOp::SetLang { #OK exist
    method ctxopzyg() { $!expr, 1 }
}

augment class RxOp::CheckBlock { #OK exist
    method ctxopzyg() { $!block, 1 }
}

augment class RxOp::SaveValue { #OK exist
    method ctxopzyg() { $!block, 1 }
}

augment class RxOp::VoidBlock { #OK exist
    method ctxopzyg() { $!block, 0 }
}

augment class Op::RegexBody { #OK exist
    method ctxzyg($ ) { (map { $_, 0 }, @$.pre), $.rxop.ctxopzyg }
}

augment class RxOp::Subrule { #OK exist
    method ctxopzyg() { defined($!regex) ?? ($!regex, 1) !! () }
    method code($body) {
        my $callf = $!regex ?? $!regex.cgop($body) !!
            CgOp.methodcall(CgOp.rxcall("MakeCursorV"),
                $!method);

        my @code;

        if $!selfcut {
            push @code, CgOp.rxincorpcut($.captures, +?$!zerowidth,
                +?$!negative, +?$!passcap, $callf);
        } else {
            my $bt = self.label;

            push @code, CgOp.rxcall("InitCursorList", $callf);
            push @code, CgOp.label($bt);
            push @code, CgOp.rxincorpshift($.captures, +?$!passcap, $bt);
        }

        @code;
    }
}

augment class RxOp::Alt { #OK exist
    method code($body) {
        my @ls = map { self.label }, @$.zyg;
        my @lads = @( $.optimized_lads // (map { $_.lad }, @$.zyg) );
        my $end = self.label;

        die "check screwed up" unless defined $.dba;

        my @code;
        push @code, CgOp.ltm_push_alts([@lads], $.dba, [@ls]);
        push @code, CgOp.goto('backtrack');
        my $i = 0;
        while $i < @ls {
            push @code, CgOp.label(@ls[$i]);
            push @code, $.zyg[$i].code($body);
            push @code, CgOp.goto($end) unless $i == @ls - 1;
            $i++;
        }
        push @code, CgOp.label($end);
        push @code, CgOp.popcut;
        @code;
    }
}

# XXX should there be a different class for this?
augment class Op::Num { #OK exist
    method code($) {
        if $.value ~~ Array {
            CgOp.const(CgOp.exactnum(|$.value))
        } else {
            CgOp.const(CgOp.box('Num', CgOp.double($.value)))
        }
    }
}

augment class Op::Labelled { #OK exist
    method statement_level() {
        self.new(name => $.name, stmt => $.stmt.statement_level);
    }
}

class RxOp::CutBrack is RxOp {
    method code($) { CgOp.rxcall('CommitGroup', CgOp.str("BRACK")) }
    method lad() { [ 'Null' ]; }
}

augment class CgOp {
method methodcall($obj, $name, *@args) {
    my ($sig, $aout) = CgOp._process_arglist(@args);
    CgOp._cgop('methodcall', $name, $sig, $obj, @$aout);
}
method rxincorpcut($caps,$zw,$ng,$pc,$call) { self._cgop("rxincorpcut",$caps,$zw,$ng,$pc,$call) }
method rxincorpshift($caps,$pc,$label) { self._cgop("rxincorpshift",$caps,$pc,$label) }
method boxlist($mo,$obj) { self._cgop("boxlist", $mo, $obj) }
method bif_comma(*@bits) { self._cgop("bif_comma", @bits) }
method bif_pair($key,$val) { self._cgop("bif_pair", $key, $val) }
# DELETE label_table, ladconstruct, get_lexer
method ltm_push_alts (*@x) { self._cgop("ltm_push_alts", @x) }
method outerlex ($n) { self._cgop("outerlex", $n) }
method newtypedscalar ($t) { self._cgop("newtypedscalar", $t) }
method bif_rand () { self._cgop("bif_rand") }
method exactnum ($base, $digits) { self._cgop("exactnum", $base, $digits) }
method bif_rat_approx ($center, $eps) { self._cgop("bif_rat_approx", $center, $eps) }
method bif_coerce_to_num ($v) { self._cgop("bif_coerce_to_num", $v) }
method bif_coerce_to_int ($v) { self._cgop("bif_coerce_to_int", $v) }
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $stages;
if $bcnd eq 'clisp' {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassSimplifier.new,
    ];
} elsif $bcnd eq 'hoopl' {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassSimplifier.new,
    ];
} else {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ];
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => $stages,
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        $c.compile_string("say (" ~ $l ~ ").perl", !$comp, $stop);
    }
}
