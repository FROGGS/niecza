use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use JSYNC;
use Metamodel;
use NAMOutput;
use NieczaActions;
use NieczaBackendClisp;
use NieczaBackendDotnet;
use NieczaBackendHoopl;
use NieczaBackendNAM;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

augment class NieczaActions {
method blast($/) {
    if $<block> {
        make $<block>.ast;
    } else {
        make self.thunk_sub($<statement>.ast.statement_level);
    }
}

method install_sub($/, $sub, :$multiness is copy, :$scope is copy, :$class,
        :$path, :$name is copy, :$method_type is copy, :$contextual is copy) {

    $multiness ||= 'only';
    $path := Any if $name ~~ Op; #Hack

    if !$scope {
        if !defined($name) {
            $scope = 'anon';
        } elsif defined($path) {
            $scope = 'our';
        } elsif defined($method_type) {
            $scope = 'has';
        } else {
            $scope = 'my';
        }
    }

    if $scope ne 'my' && $scope ne 'our' && $scope ne 'anon' && $scope ne 'has' {
        $/.CURSOR.sorry("Illegal scope $scope for subroutine");
        $scope = 'anon';
    }

    if $scope eq 'has' && !defined($method_type) {
        $/.CURSOR.sorry('has scope-type is only valid for methods');
        $scope = 'anon';
    }

    if $scope ne 'anon' && !defined($name) {
        $/.CURSOR.sorry("Scope $scope requires a name");
        $scope = 'anon';
    }

    if $scope ne 'our' && defined($path) {
        $/.CURSOR.sorry("Double-colon-qualified subs must be our");
        $scope = 'our';
    }

    if $scope eq 'anon' && $multiness ne 'only' {
        $/.CURSOR.sorry("Multi routines must have a name");
        $multiness = 'only';
    }

    if $contextual && (defined($method_type) || $scope ne 'my') {
        $/.CURSOR.sorry("Context-named routines must by purely my-scoped");
        $contextual = False;
    }

    $method_type = Str if $scope eq 'anon';

    my $method_targ = $method_type && $sub.outer.body_of;
    if $method_targ {
        $method_targ = $*unit.deref($method_targ);
    } elsif defined($method_type) {
        $/.CURSOR.sorry("Methods must be used in some kind of package");
        $method_type = Str;
    }

    if $method_targ && !$method_targ.^can('add_method') {
        $/.CURSOR.sorry("A {$method_targ.WHAT} cannot have methods added");
        $method_type = Str;
        $method_targ = Any;
    }

    if $name ~~ Op && (!defined($method_type) || $scope ne 'has' ||
            $method_targ !~~ ::Metamodel::ParametricRole) {
        $/.CURSOR.sorry("Computed names are only implemented for parametric roles");
        $name = "placeholder";
    }

    my $bindlex = $scope eq 'my' || ($scope eq 'our' && !$path);

    $sub.set_name(($name ~~ Op) ?? '::($name)' !!
        defined($method_type) ?? $method_targ.name ~ "." ~ $name !!
        ($name // 'ANON'));
    $sub.class = $class;
    $sub.returnable = True;

    (sub () {
        my $std = $/.CURSOR;
        if $sub.name ~~ /^(\w+)\:\<(.*)\>$/ {
            my %new = %( $std.default_O(~$0, ~$1) );
            $sub.prec_info = %new;
        }
    }).();

    my Str $symbol;
    $/.CURSOR.trymop({
        if $bindlex && $class eq 'Regex' {
            $symbol = '&' ~ $name;
            my $proto = $symbol;
            $proto ~~ s/\:.*//;
            $sub.outer.add_dispatcher($proto, |mnode($/))
                if $multiness ne 'only' && !$sub.outer.lexicals.{$proto};
            $symbol ~= ":(!proto)" if $multiness eq 'proto';
        } elsif $bindlex {
            $symbol = '&' ~ $name;
            $/.CURSOR.check_categorical($symbol);
            if $multiness ne 'only' && !$sub.outer.lexicals.{$symbol} {
                $sub.outer.add_dispatcher($symbol, |mnode($/))
            }

            given $multiness {
                when 'multi' { $symbol ~= ":({ self.gensym })"; }
                when 'proto' { $symbol ~= ":(!proto)"; }
                default {
                    $/.CURSOR.check_categorical($symbol);
                }
            }
        } else {
            $symbol = self.gensym;
        }

        $sub.outervar = $symbol;
        $sub.methodof = defined($method_type) ?? $method_targ.xref !! Any;
        $sub.outer.add_my_sub($symbol, $sub, |mnode($/));

        if $multiness ne 'only' || $scope eq 'our' || $method_type {
            $sub.outer.lexicals-used{$symbol} = True;
        }

        if defined($method_type) || $scope eq 'our' {
            $sub.strong_used = True;
            $sub.outer.create_static_pad;
        }

        if defined($method_type) {
            if $sub.outer.augment_hack {
                push $sub.outer.augment_hack,
                    [ $multiness, $method_type, $name, $symbol, $sub.xref ];
            } else {
                $method_targ.add_method($multiness, $method_type, $name,
                    $symbol, $sub.xref, |mnode($/));
            }
        }

        if $scope eq 'our' {
            $sub.exports = [[@($sub.outer.find_pkg($path // ['OUR'])), '&'~$name]];
        }
    });
}


method type_declarator:enum ($/) {
    my $scope = $*SCOPE || 'our';
    if $scope && $scope ne 'our' && $scope ne 'my' && $scope ne 'anon' {
        $/.CURSOR.sorry("Invalid enum scope $scope");
        $scope = 'anon';
    }

    my @exports;
    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } else {
            $/.CURSOR.sorry("Unsupported enum trait $t.keys()");
        }
    }

    my @pairs = self.trivial_eval($/, $<term>.ast);
    my $last = -1;
    my ($has_ints, $has_strs);
    for @pairs {
        if $_ !~~ Pair {
            my $key = $_;
            my $value = $last.succ;
            $_ = $key => $value;
        }
        given $last = .value {
            when Int { $has_ints = True; }
            when Str { $has_strs = True; }
            default  { $/.CURSOR.sorry("Enum values must be Int or Str"); }
        }
    }
    if $has_ints && $has_strs {
        $/.CURSOR.sorry("Enum may not contain both Int and Str values");
    }

    my $basetype = $*OFTYPE ?? self.simple_longname($*OFTYPE<longname>) !!
        [ 'MY', $has_strs ?? 'Str' !! 'Int' ];

    if $<name> && $<name>.reduced eq 'longname'&& ($scope ||= 'our') ne 'anon' {
        # Longnamed enum is a kind of type definition

        my $ourpath = Array;
        my $lexvar = self.gensym;
        my $bindlex = False;
        my $r = self.mangle_longname($<longname>[0], True);
        my $name = $r<name>;
        if ($r<path>:exists) && $scope ne 'our' {
            $/.CURSOR.sorry("Enum name $<longname> requires our scope");
            $scope = 'our';
        }

        if $scope eq 'our' {
            $ourpath = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            if !($r<path>:exists) {
                $lexvar  = $name;
                $bindlex = True;
            }
        } elsif $scope eq 'my' {
            $lexvar  = $name;
            $bindlex = True;
        }

        $/.CURSOR.trymop({
            my @ns = $ourpath ?? (@( $*CURLEX<!sub>.find_pkg($ourpath) ), $name) !!
                $*unit.anon_stash;
            $*unit.create_stash([@ns]);
            $*CURLEX<!sub>.add_my_stash($lexvar, [@ns], |mnode($/));
            my $obj  = ::Metamodel::Class.new(:$name);
            $obj.exports = [ [@ns] ];
            $*unit.bind_item([@ns], $obj.xref, |mnode($/));

            $obj.add_super($*unit.get_item($*CURLEX<!sub>.find_pkg(
                ['MY', ($has_strs ?? 'Str' !! 'Int') ~ "BasedEnum"])));
            $obj.add_super($*unit.get_item($*CURLEX<!sub>.find_pkg($basetype)));

            my $nb = ::Metamodel::StaticSub.new(
                transparent=> True,
                unit       => $*unit,
                outerx     => $*CURLEX<!sub>.xref,
                outer_direct => $*CURLEX<!sub>,
                name       => $name,
                cur_pkg    => $*CURLEX<!sub>.cur_pkg,
                class      => 'Method',
                signature  => Sig.simple('self'),
                code       => self.init_constant(
                    self.make_constant($/, 'anon', Any, Any),
                    ::Op::CallMethod.new(name => 'new',
                        receiver => mklex($/, 'EnumMap'), args => [$<term>.ast])));

            $nb.add_my_name('self', noinit => True);
            $*CURLEX<!sub>.create_static_pad;
            $nb.strong_used = True;
            $*CURLEX<!sub>.add_child($nb);
            $*CURLEX<!sub>.add_my_sub($lexvar ~ '!enums', $nb, |mnode($/));
            $obj.add_method('only', 'normal', 'enums', $lexvar ~ '!enums',
                $nb.xref, |mnode($/));
            $obj.close;

            for @pairs {
                self.make_constant_into($/, @ns, .key, rhs =>
                    ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                        args => [ ::Op::StringLiteral.new(text => .key) ]));
            }

            for @pairs {
                self.init_constant(self.make_constant($/, $scope, .key, Any),
                    ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                        args => [ ::Op::StringLiteral.new(text => .key) ]));
            }
        });

        make mklex($/, $lexvar);
    } else {
        make self.init_constant(
            self.make_constant($/, $<name> ?? $scope !! 'anon', ~$<name>, Any),
            ::Op::CallMethod.new(|node($/), name => 'new',
                receiver => mklex($/, 'EnumMap'),
                args => [$<term>.ast])),
    }
}

method open_package_def($, $/ = $*cursor) {
    my %_decl2mclass = (
        package => ::Metamodel::Package,
        class   => ::Metamodel::Class,
        module  => ::Metamodel::Module,
        grammar => ::Metamodel::Grammar,
        role    => ::Metamodel::Role,
    );
    my $sub = $*CURLEX<!sub>;

    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }

    my $scope = $*SCOPE;
    if !$<longname> {
        $scope = 'anon';
    }

    if $scope eq 'supersede' {
        $/.CURSOR.sorry('Supercede is not yet supported');
        $scope = 'our';
    }
    if $scope eq 'has' || $scope eq 'state' {
        $/.CURSOR.sorry("Illogical scope $scope for package block");
        $scope = 'our';
    }

    if $scope eq 'augment' {
        my $r = self.mangle_longname($<longname>[0], True);
        my $name = $r<name>;
        my @augpkg = @( $r<path> // ['MY'] );

        my $pkg = $sub.outer.find_pkg([ @augpkg, $name ]);
        my $so  = $*unit.get_item($pkg);
        my $dso = $*unit.deref($so);

        if $dso.^isa(::Metamodel::Role) {
            $/.CURSOR.panic("Illegal augment of a role");
        }

        my @ah = $so;
        $sub.augment_hack = @ah;
        $sub.body_of = $sub.in_class = $so;
        $sub.cur_pkg = $pkg;
        $sub.augmenting = True;
        $sub.set_name("augment-$dso.name()");
    } else {
        my ($name, $ourpkg);
        my $type = %_decl2mclass{$*PKGDECL};
        if ($*PKGDECL//'role') eq 'role' && $<signature> {
            $sub.signature = $<signature>.ast;
            $type = ::Metamodel::ParametricRole;
        }
        my @ns;
        if $<longname> {
            my $r = self.mangle_longname($<longname>[0], True);
            $name = $r<name>;
            if ($r<path>:exists) && $scope ne 'our' {
                $/.CURSOR.sorry("Block name $<longname> requires our scope");
                $scope = 'our';
            }
            if $scope eq 'our' {
                $ourpkg = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            }
            if $r<path> {
                try @ns = @( $sub.outer.find_pkg([ @($r<path>), $r<name> ]) );
            } elsif $sub.outer.lexicals{$r<name>} {
                try @ns = @( $sub.outer.find_pkg([ 'MY', $r<name> ]) );
            }
            $sub.outervar = ($scope eq 'anon' || ($r<path>:exists))
                ?? self.gensym !! $name;
        } else {
            $sub.outervar = self.gensym;
            $name = 'ANON';
        }

        my $old = @ns ?? $*unit.get_item([@ns]) !! Any;

        if $old && ($old.[0] ne $*unit.name || $*unit.deref($old).closed) {
            $/.CURSOR.panic("Redefinition of class [@ns]");
        }
        my $obj;
        if $old {
            $obj = $*unit.deref($old);
            # we may need to make a new alias
            # XXX we might try looking for a reusable one, changing outervar?
            $/.CURSOR.trymop({
                $sub.outer.add_my_stash($sub.outervar, [@ns], |mnode($/));
            }) unless $sub.outer.lexicals{$sub.outervar};
        } else {
            @ns = $ourpkg ?? (@( $sub.outer.find_pkg($ourpkg) ), $name) !!
                $*unit.anon_stash;

            $*unit.create_stash([@ns]);

            $/.CURSOR.trymop({
                $sub.outer.add_my_stash($sub.outervar, [@ns], |mnode($/));
                $obj = $type.new(:$name);
                $obj.exports = [ [@ns] ];
                $*unit.bind_item([@ns], $obj.xref, |mnode($/));
            });
        }

        $sub.body_of = $sub.in_class = $obj.xref;
        $sub.cur_pkg = [@ns];

        self.process_block_traits($/, $<trait>);
        $sub.set_name($*PKGDECL ~ "-" ~ $obj.name);
    }
}


method type_declarator:subset ($/) {
    my $ourname = Array; my $lexvar = self.gensym; my $name;
    my $scope = $*SCOPE || 'our';
    if $scope && $scope ne 'our' && $scope ne 'my' && $scope ne 'anon' {
        $/.CURSOR.sorry("Invalid subset scope $scope");
        $scope = 'anon';
    }
    if $<longname> {
        $scope ||= 'my';
        my $r = self.mangle_longname($<longname>[0], True);
        $name = $r<name>;
        if ($r<path>:exists) && $scope ne 'our' {
            $/.CURSOR.sorry("Block name $<longname> requires our scope");
            $scope = 'our';
        }
        if $scope eq 'our' {
            $ourname = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            $ourname = [ @$ourname, $name ];
        } elsif $scope eq 'my' {
            $lexvar  = $name;
        }
    } else {
        if ($scope || 'anon') ne 'anon' {
            $/.CURSOR.sorry("Cannot have a non-anon subset with no name");
        }
        $name = 'ANON';
    }

    my $basetype = $*OFTYPE ?? self.simple_longname($*OFTYPE<longname>) !!
        ['MY', 'Any'];
    my @exports;

    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } elsif $t<of> {
            $basetype = $t<of>;
        } else {
            $/.CURSOR.sorry("Unsupported subset trait $t.keys()");
        }
    }

    my $body = self.thunk_sub($<EXPR> ?? $<EXPR>[0].ast !! mklex($/, 'True'));

    my @ns = $ourname ?? @( $*CURLEX<!sub>.find_pkg($ourname) ) !!
        $*unit.anon_stash;

    $/.CURSOR.trymop({
        $*unit.create_stash([@ns]);
        $*CURLEX<!sub>.add_my_stash($lexvar, [@ns], |mnode($/));
        $*CURLEX<!sub>.add_pkg_exports($*unit, $name, [@ns], @exports);
        $*CURLEX<!sub>.create_static_pad;

        $basetype = $*unit.get_item($*CURLEX<!sub>.find_pkg([@$basetype]));
        my $obj = ::Metamodel::Subset.new(:$name, where => $body.xref,
            :$basetype);
        $*unit.bind_item([@ns], $obj.xref, |mnode($/));
        $obj.exports = [ [@ns] ];
    });

    make mklex($/, $lexvar);
}

method add_attribute($/, $name, $sigil, $accessor, $type) {
    my $ns = $*CURLEX<!sub>.body_of;
    $/.CURSOR.sorry("Attribute $name declared outside of any class"),
        return ::Op::StatementList.new unless $ns;
    $/.CURSOR.sorry("Attribute $name declared in an augment"),
        return ::Op::StatementList.new if $*CURLEX<!sub>.augmenting;

    $ns = $*unit.deref($ns);

    if !$ns.^can('add_attribute') {
        $/.CURSOR.sorry("A $ns.WHAT() cannot have attributes");
        return ::Op::StatementList.new
    }

    my $nb = ::Metamodel::StaticSub.new(
        transparent=> True,
        unit       => $*unit,
        outerx     => $*CURLEX<!sub>.xref,
        outer_direct => $*CURLEX<!sub>,
        name       => $name,
        cur_pkg    => $*CURLEX<!sub>.cur_pkg,
        class      => 'Method',
        signature  => Sig.simple('self'),
        code       => ::Op::GetSlot.new(name => $name,
            object => ::Op::Lexical.new(name => 'self')));
    $nb.add_my_name('self', noinit => True);
    $*CURLEX<!sub>.create_static_pad; # for protosub instance
    $nb.strong_used = True;
    $*CURLEX<!sub>.add_child($nb);
    my $at;

    $/.CURSOR.trymop({
        my $ac = self.gensym;
        $*CURLEX<!sub>.add_my_sub($ac, $nb, |mnode($/));
        $at = $ns.add_attribute($name, $sigil, +$accessor, Any, Any, $type,
            |mnode($/));
        $ns.add_method('only', 'private', $name, $ac, $nb.xref,
            |mnode($/));
        if $accessor {
            $ns.add_method('only', 'normal', $name, $ac, $nb.xref,
                |mnode($/));
        }
    });

    $at ?? ::Op::Attribute.new(name => $name, initializer => $at) !!
        ::Op::StatementList.new;
}


method process_block_traits($/, @tr) {
    my $sub = $*CURLEX<!sub>;
    my $pack = $sub.body_of;
    for @tr -> $T {
        my $tr = $T.ast;
        if $pack && ($tr<name>:exists) {
            my ($name, $path) = $tr<name path>;

            $T.CURSOR.sorry("superclass $name declared outside of any class"),
                next unless $sub.body_of;
            $T.CURSOR.sorry("superclass $name declared in an augment"),
                next if $sub.augmenting;
            $T.CURSOR.sorry("cannot declare a superclass in this kind of package"),
                next if !$*unit.deref($pack).^can('add_super');

            $T.CURSOR.trymop({
                $*unit.deref($pack).add_super($*unit.get_item($sub.find_pkg(
                    [ @($path // ['MY']), $name ])));
            });
        } elsif $pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_pkg_exports($*unit, $*unit.deref($pack).name,
                $sub.cur_pkg, @exports);
        } elsif !$pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports($*unit, '&' ~ $sub.name, @exports);
            $sub.strong_used = True;
            $sub.outer.create_static_pad;
            $sub.outer.lexicals-used{$sub.outervar} = True
                if defined $sub.outervar;
            $sub.exports //= [];
            push $sub.exports, [ @($sub.outer.find_pkg(
                ['OUR','EXPORT',$_])), '&' ~ $sub.name ] for @exports;
        } elsif !$pack && $tr<nobinder> {
            $sub.signature = Any;
        } elsif !$pack && grep { defined $tr{$_} }, <looser tighter equiv> {
            my $rel = $tr.keys.[0];
            my $to  = $tr.values.[0];
            $to = $to.inside if $to ~~ ::Op::Paren;
            $to = $to.children[0] if $to ~~ ::Op::StatementList && $to.children == 1;

            my $oprec;
            if $to ~~ ::Op::Lexical {
                $oprec = $T.CURSOR.function_O($to.name);
            } elsif $to ~~ ::Op::StringLiteral && $sub.name ~~ /^(\w+)\:\<.*\>$/ {
                $oprec = $T.CURSOR.cat_O(~$0, $to.text);
            } else {
                $T.CURSOR.sorry("Cannot interpret operator reference");
                next;
            }
            unless $oprec {
                $T.CURSOR.sorry("No precedence available for reference target");
                next;
            }
            my %new = %$oprec;
            $sub.prec_info = %new;
            $sub.prec_info.<prec> ~~ s/\=/<=/ if $rel eq 'looser';
            $sub.prec_info.<prec> ~~ s/\=/>=/ if $rel eq 'tighter';
        } elsif !$pack && $tr<assoc> {
            my $arg = ~self.trivial_eval($T, $tr<assoc>);
            unless $sub.prec_info {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            my @valid = < left right non list unary chain >;
            unless grep $arg, @valid {
                $T.CURSOR.sorry("Invalid associativity $arg");
                next;
            }
            $sub.prec_info.<assoc> = $arg;
        } elsif !$pack && $tr<Niecza::absprec> {
            my $arg = ~self.trivial_eval($T, $tr<Niecza::absprec>);
            unless $sub.prec_info {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            $sub.prec_info.<prec> = $arg;
            $sub.prec_info.<dba> = "like $sub.name()";
        } elsif !$pack && $tr<return_pass> {
            $sub.returnable = False;
        } elsif !$pack && $tr<of> {
        } elsif !$pack && $tr<rw> {
        } elsif !$pack && $tr<unsafe> {
            $sub.unsafe = True;
        } else {
            $T.CURSOR.sorry("Unhandled trait $tr.keys[0] for this context");
        }
    }
}


}

CgOp._register_ops: <
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => [ NieczaPassSimplifier.new ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
}
