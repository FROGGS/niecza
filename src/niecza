use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

$GLOBAL::DEBUG_STD = (%*ENV<NIECZA_STD_DEBUG> ?? -1 !! 0);

augment class Any {
    submethod new(|$) { die "Attempted to instantiate undefined class." }
}

our ($Op, $OpAttribute, $OpBareBlock, $OpBuiltin, $OpCallLike, $OpCallMethod,
     $OpCallSub, $OpCatchyWrapper, $OpCgOp, $OpConditional, $OpConstantDecl,
     $OpContextVar, $OpDoOnceLoop, $OpForLoop, $OpGather, $OpGeneralConst,
     $OpGeneralLoop, $OpGetBlock, $OpGetSlot, $OpHereStub, $OpImmedForLoop,
     $OpIndirectVar, $OpLabelled, $OpLetVar, $OpLexical, $OpMakeCursor, $OpNum,
     $OpParen, $OpRegexBody, $OpRequire, $OpShortCircuit, $OpSimplePair,
     $OpSimpleParcel, $OpStart, $OpStateDecl, $OpStatementList,
     $OpStringLiteral, $OpTemporize, $OpTry, $OpWhatever, $OpWhateverCode,
     $OpWhen, $OpWhileLoop, $OpYada, $OpYouAreHere); #OK
our ($RxOp, $RxOpAlt, $RxOpAny, $RxOpBefore, $RxOpCut, $RxOpConj, $RxOpCutLTM,
     $RxOpCutBrack, $RxOpCutRule, $RxOpConfineLang, $RxOpCapturing,
     $RxOpCClassElem, $RxOpCheckBlock, $RxOpEndpoint, $RxOpListPrim,
     $RxOpNone, $RxOpNotBefore, $RxOpNewline, $RxOpProtoRedis, $RxOpQuantifier,
     $RxOpSubrule, $RxOpString, $RxOpSequence, $RxOpSigspace, $RxOpSeqAlt,
     $RxOpSaveValue, $RxOpStringCap, $RxOpSym, $RxOpStatement, $RxOpSetLang,
     $RxOpTilde, $RxOpVoidBlock, $RxOpVarString, $RxOpZeroWidth,
     $RxOpZeroWidthCCs); #OK

our ($Sig, $SigParameter, $PassSimplifier, $CClass); #OK

our $Actions; $Actions = $Actions but role {
method variable($/) {
    my $sigil =  $<sigil>  ?? ~$<sigil> !! substr(~$/, 0, 1);
    my $twigil = $<twigil> ?? $<twigil><sym> !! '';

    my ($name, $pkg);
    my ($dsosl) = $<desigilname> ?? $<desigilname>.ast !!
        $<sublongname> ?? $<sublongname>.ast !!
        $<longname> ?? self.process_name($<longname>, :defer) !!
        Any;
    if defined($dsosl<ind>) {
        make { term => self.docontext($/, $sigil, $dsosl<ind>) };
        return;
    } elsif defined($dsosl<iname>) {
        make { term => $OpIndirectVar.new(pos=>$/,
            name => mkstringycat($/, $sigil ~ $twigil, $dsosl<iname>)) };
        return;
    } elsif defined $dsosl {
        ($name, $pkg) = $dsosl<name pkg>;
    } elsif $<infixish> {
        make { term => $<infixish>.ast.as_function($/) };
        return;
    } elsif $<special_variable> {
        $name = substr(~$<special_variable>, 1);
    } elsif $<index> {
        make { capid => $<index>.ast, term =>
            self.docontextif($/, $sigil,
                mkcall($/, '&postcircumfix:<[ ]>',
                    $OpLexical.new(name => '$/'),
                    $OpNum.new(value => $<index>.ast)))
        };
        return Nil;
    } elsif $<postcircumfix>[0] {
        if $<postcircumfix>[0].reduced eq 'postcircumfix:sym<< >>' { #XXX fiddly
            make { capid => self.eval_ast_str($/, $<postcircumfix>[0].ast.args[0]) // '', term =>
                self.docontextif($/, $sigil,
                    mkcall($/, '&postcircumfix:<{ }>',
                        $OpLexical.new(name => '$/'),
                        @( $<postcircumfix>[0].ast.args)))
            };
            return;
        } else {
            if $<postcircumfix>[0].ast.args[0] -> $arg {
                make { term => self.docontext($/, $sigil, $arg) };
            } elsif $sigil eq '$' {
                make { term => $OpShortCircuit.new(pos=>$/, kind => '//',
                    args => [ $OpCallMethod.new(name => 'ast',
                                receiver => mklex($/, '$/')),
                              $OpCallMethod.new(name => 'Str',
                                receiver => mklex($/, '$/')) ] ) };
            } elsif $sigil eq any < @ % > {
                make { term => self.docontext($/, $sigil, mklex($/, '$/')) };
            } else {
                make { term => mklex($/, 'Mu') };
                $/.CURSOR.sorry("Missing argument for contextualizer");
            }
            return;
        }
    } else {
        $name = '';
    }

    make {
        sigil => $sigil, twigil => $twigil, name => $name, pkg => $pkg
    };
}
method metachar:qw ($/) {
    my @words;
    $/.CURSOR.trymop({ @words = self.eval_ast($/,$<circumfix>.ast).to_string_list });

    make $RxOpAlt.new(zyg => [ map { $RxOpString.new(text => $_,
            igcase => %*RX<i>, igmark => %*RX<a>) }, @words ], dba => %*RX<dba>);
}
method process_nibble($/, @bits, $prefix?) {
    my @acc;
    for @bits -> $n {
        my $ast = ($n.ast // ~$n);

        if $ast ~~ $CClass {
            $n.CURSOR.sorry("Cannot use a character class in a string");
            $ast = "";
        }

        if $ast !~~ $Op && defined($prefix) && $prefix ne "" {
            my $start_nl = !$n.from || "\r\n".index(
                substr($n.orig, $n.from-1, 1)).defined;
            $ast = $ast.split(/ ^^ [ <?{ $start_nl }> || <?after <[\x0A\x0D]> > ]
                <before \h>[ $prefix || \h+ ]/).join("");
        }

        push @acc, $ast;
    }

    my $post = $/.CURSOR.postprocessor;
    make mkstringycat($/, @acc);

    if $post eq 'null' {
        # already OK
    }
    # actually quotewords is a bit trickier than this...
    elsif $post eq 'words' || $post eq 'quotewords' {
        my $sl = $/.ast;
        if !$sl.^isa($OpStringLiteral) {
            make $OpCallMethod.new(pos=>$/, :name<words-val>, receiver => $sl);
        }
        else {
            my @tok = $sl.text.words;
            if @tok == 1 && @tok[0] eq $sl.text && $post eq 'words' {
                # <1/2> special case...
                make $OpStringLiteral.new(text => @tok[0]);
                make mkcall($/, '&val_nospace', $/.ast)
                    if $*CURLEX<!sub>.lookup_lex('&val_nospace');
            }
            else {
                @tok = map { $OpStringLiteral.new(pos=>$/, text => $_) }, @tok;
                @tok = map { mkcall($/, '&val', $_) }, @tok
                    if $*CURLEX<!sub>.lookup_lex('&val');

                make ((@tok == 1) ?? @tok[0] !! $OpParen.new(pos=>$/,
                    inside => $OpSimpleParcel.new(pos=>$/, items => @tok)));
            }
        }
    }
    elsif $post eq 'path' {
        # TODO could stand to be a lot fancier.
        make $OpCallMethod.new(pos=>$/, receiver => $/.ast, :name<IO>);
    }
    elsif $post eq 'run' {
        make mkcall($/, '&rungather', $/.ast);
    }
    else {
        $/.CURSOR.sorry("Unhandled postprocessor $post");
    }

    $/.ast;
}
method typename($/) {
    state %masks = ':_' => $Sig::ANY_DEF, ':T' => $Sig::UNDEF_ONLY,
        ':U' => $Sig::UNDEF_ONLY, ':D' => $Sig::DEF_ONLY;

    $/.CURSOR.sorry('WHENCE blocks not allowed on declarative type names')
        if $<whence>;

    if $<ident> {
        $/.CURSOR.sorry('::?CLASS syntax NYI');
        make { tmode => 0, type => self.get_Any };
        return;
    }

    my $tmode = 0;
    my $long = $<longname>;
    my ($type) = self.process_name($long);

    if !$type {
        $/.CURSOR.sorry('A type must be provided');
        $type = self.get_Any;
    }

    if $<typename> {
        $/.CURSOR.sorry('Coercive declarations NYI');
    }

    for @( $long<colonpair> ) -> $cp {
        if %masks{$cp} -> $mask {
            $/.CURSOR.sorry("You may only specify one of :_ :D :U :T") if $tmode;
            $tmode +|= $mask;
        }
    }

    make { :$type, :$tmode };
}
method process_block_traits($/, @tr) {
    my $sub = $*CURLEX<!sub>;
    my $pack = $sub.body_of;
    for @tr -> $T {
        my $tr = $T.ast;
        if $pack && $tr<name> {
            my $super = $tr<name>;

            $T.CURSOR.sorry("superclass $super.name() declared outside of any class"),
                next unless $sub.body_of;
            $T.CURSOR.sorry("superclass $super.name() declared in an augment"),
                next if defined $*AUGMENT_BUFFER;
            $T.CURSOR.sorry("cannot declare a superclass in this kind of package"),
                next if !$pack.CAN('add_super');

            $T.CURSOR.trymop({
                $pack.add_super($super);
            });
        } elsif $pack && $tr<does> {
            my $role = $tr<does>;

            $T.CURSOR.sorry("role $role.name() used outside of any class"), next
                unless $sub.body_of;
            $T.CURSOR.sorry("role $role.name() used in an augment"),
                next if defined $*AUGMENT_BUFFER;
            $T.CURSOR.sorry("cannot use a role in this kind of package"),
                next if !$pack.CAN('add_role');

            $T.CURSOR.trymop({
                $pack.add_role($role);
            });
        } elsif $pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports($pack.name, $pack, @exports);
        } elsif !$pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports($sub.outervar, $sub, @exports);
            $sub.set_extend('exported', @exports);
            $sub.outer.create_static_pad;
            $/.CURSOR.mark_used($sub.outervar)
                if defined $sub.outervar;
        } elsif !$pack && $tr<nobinder> {
            $sub.set_signature(Any);
        } elsif !$pack && $tr<pure> {
            $sub.outer.create_static_pad;
            $sub.set_extend('pure', True);
        } elsif !$pack && grep { defined $tr{$_} }, <looser tighter equiv> {
            my $rel = $tr.keys.[0];
            my $to;
            $T.CURSOR.trymop({ $to = self.eval_ast($T, $tr.values.[0]) });
            $to // next;

            my $oprec;
            if $to.to_sub -> $to_sub {
                $oprec = %( $to_sub.get_extend('prec') // () );
            } elsif $sub.name ~~ /^(\w+)\:\<.*\>$/ {
                $T.CURSOR.trymop({
                    $oprec = $T.CURSOR.cat_O(~$0, $to.to_string);
                });
            } else {
                $T.CURSOR.sorry("Cannot interpret operator reference");
                next;
            }
            unless $sub.get_extend('prec') {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            unless $oprec {
                $T.CURSOR.sorry("No precedence available for reference target");
                next;
            }
            if $rel eq 'equiv' {
                $sub.set_extend('prec', $oprec.kv);
            } else {
                my %prec = $sub.get_extend('prec');
                %prec<prec> = $oprec.<prec>;
                %prec<prec> ~~ s/\=/<=/ if $rel eq 'looser';
                %prec<prec> ~~ s/\=/>=/ if $rel eq 'tighter';
                $sub.set_extend('prec', %prec.kv);
            }
        } elsif !$pack && ($tr<assoc> // $tr<uassoc>) {
            my $arg = self.eval_ast_str($T, ($tr<assoc> // $tr<uassoc>)) // '';
            my %prec = $sub.get_extend('prec');
            unless %prec {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            unless $arg eq any < left right non list unary chain > {
                $T.CURSOR.sorry("Invalid associativity $arg");
                next;
            }
            %prec{$tr.keys.[0]} = $arg;
            $sub.set_extend('prec', %prec.kv);
        } elsif !$pack && ($tr<iffy> || $tr<fiddly> || $tr<diffy>) {
            my %prec = $sub.get_extend('prec');
            unless %prec {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            %prec{$tr.keys.[0]} = True;
            $sub.set_extend('prec', %prec.kv);
        } elsif !$pack && $tr<Niecza::absprec> {
            my @arg = (self.eval_ast_str($T, $tr<Niecza::absprec>) // '').words;
            my %prec = $sub.get_extend('prec');
            unless %prec {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            %prec = ();
            %prec<prec> = @arg[0];
            %prec<assoc> = @arg[1] // 'left';
            %prec<uassoc> = @arg[2] // 'non' if %prec<assoc> eq 'unary';
            %prec<dba> = "like $sub.name()";
            $sub.set_extend('prec', %prec.kv);
        } elsif !$pack && $tr<Niecza::builtin> {
            # XXX this is a smidge ugly
            my ($name, @rest) = (self.eval_ast_str($T, $tr<Niecza::builtin>) // "a").words;
            $sub.set_extend('builtin', $name, map +*, @rest);
        } elsif !$pack && $tr<return_pass> {
            $sub.set_return_pass;
        } elsif !$pack && $tr<of> {
        } elsif !$pack && $tr<rw> {
        } elsif !$pack && $tr<unsafe> {
            $sub.set_unsafe;
        } else {
            $T.CURSOR.sorry("Unhandled trait $tr.keys[0] for this context");
        }
    }
}

}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (dotnet)
   -L --language=NAME        # select your setting
   -I --include=DIR          # add a directory to search for modules
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $version = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose" => sub { $verb++ },
    "version|v" => sub { $version = True },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    backend => $backend,
    verbose => $verb,
);

if $version {
    $c.compile_string('say "This is Niecza Perl 6 {$?PERL<version>}"', True);
    exit 0;
}

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp);
}
else {
    my $*repl_outer;
    my $*repl_outer_frame;
    $c.compile_string('$PROCESS::OUTPUT_USED ::= True', !$comp, :repl,
        :evalmode);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, :repl, :evalmode,
                :outer($*repl_outer), :outer_frame($*repl_outer_frame));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
