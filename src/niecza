use Metamodel;
use Op;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use NieczaActions;
use Operator;
use CgOp;

sub node($M) { { line => $M.cursor.lineof($M.to) } }

sub mklet($value, $body) {
    my $var = ::GLOBAL::NieczaActions.gensym;
    ::Op::Let.new(var => $var, to => $value,
        in => $body(::Op::LetVar.new(name => $var)));
}

sub mklex($/, $name) { ::Op::Lexical.new(|node($/), :$name); }

sub mkcall($/, $name, *@positionals) {
    ::Op::CallSub.new(|node($/),
        invocant => ::Op::Lexical.new(|node($/), :$name), :@positionals);
}

sub mktemptopic($/, $item, $expr) {
    mklet(mklex($/, '$_'), -> $old_ {
        ::Op::StatementList.new(|node($/), children => [
            # XXX should be a raw bind
            ::Op::Bind.new(:!readonly, lhs => mklex($/, '$_'), rhs => $item),
            mklet($expr, -> $result {
                ::Op::StatementList.new(children => [
                    # XXX should be a raw bind
                    ::Op::Bind.new(:!readonly, lhs => mklex($/, '$_'),
                        rhs => $old_),
                    $result]) }) ]) });
}

augment class NieczaActions {
method keyspace($/) { }
method terminator:sym<given> ($/) {}
method terminator:sym<when> ($/) {}
method terminator:sym« --> » ($/) {}

method infix:sym<~~> ($/) { make ::Operator::SmartMatch.new }

method sibble($/) {
    my $regex = self.op_for_regex($/, $<left>.ast);
    my $repl;
    if $<infixish> {
        if $<infixish> eq '=' {
            $repl = $<right>.ast;
        } elsif $<infixish>.ast ~~ ::Operator::CompoundAssign {
            $repl = $<infixish>.ast.base.with_args($/,
                mkcall($/, '&prefix:<~>', ::Op::ContextVar.new(name => '$*/')),
                $<right>.ast);
        } else {
            $/.CURSOR.sorry("Unhandled operator in substitution");
            $repl = mklex($/, 'Any');
        }
    } else {
        $repl = $<right>.ast;
    }
    $repl = self.transparent($/, $repl);
    make mkcall($/, '&_substitute', mklex($/, '$_'), $regex, $repl);
}

method quote:s ($/) { make $<pat>.ast }

method statement_control:given ($/) {
    $<xblock>.ast[1].type = 'immed';
    make ::Op::CallSub.new(|node($/), positionals => [ $<xblock>.ast[0] ],
        invocant => self.block_to_closure($/, $<xblock>.ast[1], :once));
}

method statement_control:when ($/) {
    $<xblock>.ast[1].type = 'cond';
    make ::Op::When.new(|node($/), match => $<xblock>.ast[0],
        body => self.block_to_immediate($/, 'loop', $<xblock>.ast[1]));
}

method label($/) { }
method statement($/) {
    if $<label> {
        make ::Op::Labelled.new(|node($/), name => ~$<label><identifier>,
            stmt => $<statement>.ast);
        return Nil;
    }

    make ($<statement_control> ?? $<statement_control>.ast !!
        $<EXPR> ?? $<EXPR>.ast !! ::Op::StatementList.new);

    if $<statement_mod_cond> {
        my ($sym, $exp) = @( $<statement_mod_cond>[0].ast );

        if $sym eq 'if' {
            make ::Op::Conditional.new(|node($/), check => $exp,
                true => $/.ast, false => Any);
        } elsif $sym eq 'unless' {
            make ::Op::Conditional.new(|node($/), check => $exp,
                false => $/.ast, true => Any);
        } elsif $sym eq 'when' {
            make ::Op::Conditional.new(|node($/),
                check => ::Op::CallMethod.new(name => 'ACCEPTS',
                    receiver => $exp, positionals => [ mklex($/, '$_') ]),
                true => $/.ast, false => Any);
        } else {
            $/.CURSOR.sorry("Unhandled statement modifier $sym");
            make ::Op::StatementList.new;
            return Nil;
        }
    }

    if $<statement_mod_loop> {
        my ($sym, $exp) = @( $<statement_mod_loop>[0].ast );

        if $sym eq 'while' {
            make ::Op::WhileLoop.new(|node($/), check => $exp,
                body => $/.ast, until => False, once => False);
        } elsif $sym eq 'until' {
            make ::Op::WhileLoop.new(|node($/), check => $exp,
                body => $/.ast, until => True, once => False);
        } elsif $sym eq 'given' {
            make mktemptopic($/, $exp, $/.ast);
        } elsif $sym eq 'for' {
            # XXX laziness, comprehensions
            my $var = self.gensym;
            make ::Op::ImmedForLoop.new(|node($/), :$var, source => $exp,
                sink => mktemptopic($/, ::Op::LetVar.new(name => $var), $/.ast));
        } else {
            $/.CURSOR.sorry("Unhandled statement modifier $sym");
            make ::Op::StatementList.new;
            return Nil;
        }
    }
}
}

augment class Op {
method cgop_labelled($body, $label) {
    if (defined $.line) {
        CgOp.ann("", $.line, self.code_labelled($body, $label));
    } else {
        self.code_labelled($body, $label);
    }
}

method code_labelled($body, $label) { self.code($body) }

class When is Op {
    has $.match;
    has $.body;
    method zyg() { $.match, $.body }

    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.ternary(CgOp.obj_getbool(CgOp.methodcall(
                $.match.cgop($body), 'ACCEPTS', CgOp.scopedlex('$_'))),
            CgOp.prog(
                CgOp.ehspan(7, '', 0, "start$id", "end$id", "end$id"),
                CgOp.span("start$id", "end$id", 0, CgOp.prog(
                    CgOp.sink($.body.cgop($body)),
                    CgOp.control(6, CgOp.null('frame'), CgOp.int(-1),
                        CgOp.null('str'), CgOp.corelex('Nil'))))),
            CgOp.corelex('Nil'));
    }
}

# These two are created to codegen wrappers in NAMOutput... bad factor
class TopicalHook is Op {
    has $.inner;
    method zyg() { $.inner }

    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.prog(
            CgOp.ehspan(6, '', 0, "start$id", "end$id", "end$id"),
            CgOp.span("start$id", "end$id", 0, $.inner.cgop($body)));
    }
}

class LabelHook is Op {
    has $.inner;
    has $.labels;
    method zyg() { $.inner }

    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.prog(
            map({ CgOp.ehspan(8, $_, 0, "start$id", "end$id", "goto_$_") },
                @$.labels),
            CgOp.span("start$id", "end$id", 0, $.inner.cgop($body)));
    }
}

class Labelled is Op {
    has $.stmt;
    has $.name;
    method zyg() { $.stmt }

    method code($body) {
        CgOp.prog(CgOp.label("goto_$.name"),$.stmt.cgop_labelled($body,$.name));
    }
}
}

augment class Op::WhileLoop { #OK exist
    method code($body) { self.code_labelled($body,'') }
    method code_labelled($body, $l) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.prog(
            CgOp.whileloop(+$.until, +$.once,
                CgOp.obj_getbool($.check.cgop($body)),
                CgOp.prog(
                    CgOp.label("redo$id"),
                    CgOp.sink($.body.cgop($body)),
                    CgOp.label("next$id"),
                    CgOp.ehspan(1, $l, 0, "redo$id", "next$id", "next$id"),
                    CgOp.ehspan(2, $l, 0, "redo$id", "next$id", "last$id"),
                    CgOp.ehspan(3, $l, 0, "redo$id", "next$id", "redo$id"))),
            CgOp.label("last$id"),
            CgOp.corelex('Nil'));
    }
}

augment class Op::ImmedForLoop { #OK exist
    method code($body) { self.code_labelled($body, '') }
    method code_labelled($body, $l) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.rnull(CgOp.letn(
            "!iter$id", CgOp.vvarlist_new_empty,
            $.var, CgOp.null('var'),
            CgOp.vvarlist_push(CgOp.letvar("!iter$id"),
                $.source.cgop($body)),
            CgOp.whileloop(0, 0,
                CgOp.iter_hasflat(CgOp.letvar("!iter$id")),
                CgOp.prog(
                    CgOp.letvar($.var,
                        CgOp.vvarlist_shift(CgOp.letvar("!iter$id"))),
                    CgOp.label("redo$id"),
                    CgOp.sink($.sink.cgop($body)),
                    CgOp.label("next$id"),
                    CgOp.ehspan(1, $l, 0, "redo$id", "next$id", "next$id"),
                    CgOp.ehspan(2, $l, 0, "redo$id", "next$id", "last$id"),
                    CgOp.ehspan(3, $l, 0, "redo$id", "next$id", "redo$id"))),
            CgOp.label("last$id")));
    }
}

augment class Op::Labelled { #OK exist
    method begin() {
        @*opensubs[*-1].add_label($.name);
        for self.zyg { $_.begin } # XXX callsame
    }
}

augment class Operator {
class SmartMatch is Operator {
    method as_function($/) { mklex($/, '&infix:<~~>') }
    method with_args($/, *@args) {
        mktemptopic($/, @args[0], ::Op::CallMethod.new(receiver => @args[1],
            name => 'ACCEPTS', args => [ mklex($/, '$_') ]));
    }
}
}

sub GetOptions(*@pairs, :$permute = True, :onerror($onerror_), :onarg($onarg_)) {
    my @nonopt;
    my $onerror = $onerror_ // sub ($message) {
        note $message;
        exit 1;
    };
    my $onarg = $onarg_ // sub ($arg) {
        push @nonopt, $arg;
        if !$permute {
            push @nonopt, @*ARGS;
            @*ARGS = ();
        }
    };
    my @unpk;
    sub pick_long_option($st) {
        my @cand = grep { chars($_[0]) > 1 &&
            substr($_[0],0,chars($st)) eq $st }, @unpk;
        $onerror.("Ambiguous long option --$st; could be any of {map *[0], @cand}") if @cand > 1;
        $onerror.("No match for long option --$st") if !@cand;
        @cand[0];
    }
    sub pick_short_option($st) {
        my @cand = grep { $_[0] eq $st }, @unpk;
        $onerror.("No match for short option -$st") if !@cand;
        @cand[0];
    }
    for @pairs -> $p {
        my $key = $p.key;
        my $type = '';
        if $key ~~ /<[:=]>s$/ {
            $type = ~$/;
            $key = substr($key, 0, $/.from);
        }
        for $key.split('|') {
            push @unpk, [ $_, $type, $p.value ];
        }
    }

    while @*ARGS {
        my $opt = shift @*ARGS;
        if $opt eq '--' {
            $onarg.(shift @*ARGS) while @*ARGS;
            last;
        }
        elsif substr($opt, 0, 2) eq '--' {
            if $opt ~~ /'='/ {
                my $obl = pick_long_option(substr($opt, 2, $/.from - 2));
                $onerror.("Long option --$obl[0] does not accept an argument")
                    if $obl[1] eq '';
                $obl[2].(substr($opt, $/.to));
            } else {
                my $obl = pick_long_option(substr($opt, 2));
                if $obl[1] eq '=s' {
                    $onerror.("Argument required for long option --$obl[0]")
                        unless @*ARGS;
                    $obl[2].(shift @*ARGS);
                } else {
                    $obl[2].(Str);
                }
            }
        }
        elsif chars($opt) > 1 && substr($opt, 0, 1) eq '-' {
            $opt = substr($opt, 1);
            while $opt ne '' {
                my $obl = pick_short_option(substr($opt, 0, 1));
                $opt = substr($opt, 1);
                if $obl[1] eq '' || $obl[1] eq ':s' && $opt eq '' {
                    $obl[2].(Str);
                }
                elsif $opt ne '' {
                    $obl[2].($opt);
                    $opt = '';
                }
                else {
                    $onerror.("Argument required for short option -$obl[0]")
                        unless @*ARGS;
                    $obl[2].(shift @*ARGS);
                }
            }
        }
        else {
            $onarg.($opt);
        }
    }

    @*ARGS = @nonopt;
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -B --backend=NAME         # select backend (nam, dotnet, clisp)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction, implies -L SAFE
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $safe ?? 'SAFE' !! $lang,
        safemode => $safe,
    ),
    stages => [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        $c.compile_string("say (" ~ $l ~ ").perl", !$comp, $stop);
    }
}
