# vim: ft=perl6
use MONKEY_TYPING;

use STD;
use STDStash;

augment class List {
    method shift() { self!fill(1) ?? self!shift-item !! Any }
}

augment class Regex {
    method ACCEPTS($st) {
        my $i = 0;
        my $str = $st.Str;
        my $mat;
        my $C = Cursor.new($str);
        while !$mat && ($i <= $str.chars) {
            $mat = (self)($C.cursor($i++));
        }
        unitem($mat.head);
    }
}

augment class Hash {
    method hash() { unitem(self) }
}

augment class STD {
    method getdecl() { self } # XXX
    method panic($str) { die "$str at {self.pos}" }
}

augment class STD::P6 {
    token statement {
        :my $*endargs = -1;
        :my $*QSIGIL ::= 0;
        <!before <[\)\]\}]> >
        <!stopper>
        <!before $>

        # this could either be a statement that follows a declaration
        # or a statement that is within the block of a code declaration
        :lang( %*LANG<MAIN> )
        <!!{ $*LASTSTATE = $¢.pos; True  }>

        # <!before $ >

        [
        | <label> <statement>
        | <statement_control>
        | <EXPR>
            :dba('statement end')
            [
            || <?{ (@*MEMOS[$¢.pos]<endstmt> // 0) == 2 }>   # no mod after end-line curly
            ||
                :dba('statement modifier')
                <.ws>
                [
                | <statement_mod_loop>
                    {{
                        my $sp = $<EXPR><statement_prefix>;
                        if $sp and $sp<sym> eq 'do' {
                           my $s = $<statement_mod_loop>[0]<sym>;
                           $¢.obs("do...$s" ,"repeat...$s");
                        }
                    }}
                | <statement_mod_cond>
                    :dba('statement modifier loop')
                    [
                    || <?{ (@*MEMOS[$¢.pos]<endstmt> // 0) == 2 }>
                    || <.ws> <statement_mod_loop>?
                    ]
                ]?
            ]
        | <?before ';'>
        | <?before <stopper> >
        | {} <.panic: "Bogus statement">
        ]

        # Is there more on same line after a block?
        [ <?{ (@*MEMOS[@*MEMOS[$¢.pos]<ws>//$¢.pos]<endargs>//0) == 1 }>
            \h*
            <!before ';' | ')' | ']' | '}' >
            <!infixstopper>
            { $*HIGHWATER = $¢.pos = @*MEMOS[$¢.pos]<ws>//$¢.pos; }
            <.panic: "Strange text after block (missing comma, semicolon, comment marker?)">
        ]?
    }
}

sub infix:<min>($a,$b) { $a > $b ?? $b !! $a }

augment class Cursor {
    our $RED    = "\e[31m";
    our $GREEN  = "\e[32m";
    our $YELLOW = "\e[33m";
    our $CLEAR  = "\e[37m";

    method canonicalize_name($n) {
        my $M;
        my $name = $n;
        if $M = $name ~~ /^(< $ @ % & >)( \^ || \: <!before \:> )(.*)/ {
            $name = $M[0] ~ $M[2];
        }
        if $name.chars >= 2 && substr($name, $name.chars - 2, 2) ~~ / \: < U D _ > / {
            $name = $name.substr(0, $name.chars - 2);
        }
        return $name unless $name ~~ /::/;
        self.panic("Can't canonicalize a run-time name at compile time: $name") if $name ~~ / '::(' /;

        if $M = $name ~~ /^ (< $ @ % & > < ! * = ? : ^ . >?) (.* '::') (.*) $/ {
            $name = $M[1] ~ "<" ~ $M[0] ~ $M[2] ~ ">";
        }
        my $vname;
        if $M = $name ~~ /^(.*) '::<' (.*) '>' $/ {
            $name = $M[0].Str;
            $vname = $M[1].Str;
        }
        my @components;
        while $M = $name ~~ / '::' / {
            push @components, $name.substr(0, $M.to);
            $name = substr($name, $M.to);
        }
        push @components, $name;
        shift(@components) while @components and @components[0] eq '';
        if (defined $vname) {
            @components[+@components - 1] ~= '::' if @components and @components[+@components - 1] !~~ /\:\:$/;
            push(@components, $vname) if defined $vname;
        }
        @components;
    }

    method locmess () {
        my $pos = self.pos;
        my $line = self.lineof($pos);

        if $pos >= chars(self.orig) {
            $line = $line ~ " (EOF)";
        }

        my $pre = substr(self.orig, 0, $pos);
        my $prel = chars($pre) min 40;
        $pre = substr($pre, chars($pre)-$prel, $prel);
        if my $M = ($pre ~~ /^.*\n/) {
            $pre = substr($pre, $M.to);
        }
        $pre = '<BOL>' if $pre eq '';
        my $post = substr(self.orig, $pos, (chars(self.orig)-$pos) min 40);
        if $M = ($post ~~ /\n/) {
            $post = substr($post,0,$M.from);
        }
        $post = '<EOL>' if $post eq '';
        " at " ~ $*FILE<name> ~ " line $line:\n------> " ~ $Cursor::GREEN ~
            $pre ~ $Cursor::YELLOW ~ "\x23CF" ~ $Cursor::RED ~ $post ~
            $Cursor::CLEAR;
    }

    method line {
        self.lineof(self.pos);
    }

    method lineof ($p) {
        return 1 unless defined $p;
        my $line = @*MEMOS[$p]<L>;
        return $line if $line;
        $line = 1; my $pos = 0;
        self.orig ~~ / [ \n { @*MEMOS[$pos++]<L> = $line++ } ||
                         .  { @*MEMOS[$pos++]<L> = $line } ]* /;
        @*MEMOS[$pos++]<L> = $line;
        return @*MEMOS[$p]<L> // 0;
    }

    method SETGOAL { }
    method FAILGOAL ($stop, $name, $startpos) {
        my $s = "'$stop'";
        $s = '"\'"' if $s eq "'''";
        self.panic("Unable to parse $name" ~ $startpos.locmess ~ "\nCouldn't find final $s; gave up");
    }

    method deb($str) { note $str }

    method cursor_fresh($k = self) { Q:CgOp {
        (ns (cursor_fresh (cast cursor (@ {self})) (@ {$k})))
    } }

    method mixin($role) { self.cursor_fresh(self.WHAT but $role) }

    method load_lex($) {
        # NYI
        my $id = "MY:file<NULL.pad>:line(1):pos(0)";
        my $core = STDStash.new('!id' => [$id], '!file' => 'NULL.pad',
            '!line' => 1);
        STDStash.new('CORE' => $core, 'MY:file<NULL.pad>' => $core,
            'SETTING' => $core, $id => $core);
    }

    method mark_sinks(@sl) {
        #NYI
        self
    }
}

{
    my $*SETTINGNAME = 'NULL';
    my @*MEMOS;
    my $*FILE = { name => '(eval)' };
    my @*ACTIVE;
    my $*HIGHWATER = 0;
    my $*HIGHEXPECT = {};
    my $*HIGHMESS = "";
    my $*LASTSTATE = 0;
    my $*IN_PANIC = 0;
    my $*IN_SUPPOSE = 0;
    my $*FATALS = 0;

    my $*LAST_NIBBLE = Match.synthetic(:cursor(Cursor.new("")), :from(0), :to(0), :method(""), :captures());
    my $*LAST_NIBBLE_MULTILINE = $*LAST_NIBBLE;
    my $*GOAL = "(eof)";
    my $*SETTING; my $*CORE; my $*GLOBAL; my $*UNIT; my $*YOU_WERE_HERE;
    my $*CCSTATE; my $*BORG; my %*RX; my $*XACT; my $*VAR; my $*IN_REDUCE;
    STD.parse($*IN.slurp);
}
say "OK";
