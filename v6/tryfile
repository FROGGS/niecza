# vim: ft=perl6
use MONKEY_TYPING;

use STD;
use Stash;
use NAME;

augment class List {
    method shift() { self!fill(1) ?? self!shift-item !! Any }
}

augment class Any {
    method list() { @( self, ) }
}

augment class Stash {
}

augment class NAME {
}

augment class Regex {
    method ACCEPTS($st) {
        my $i = 0;
        my $str = $st.Str;
        my $mat;
        my $C = Cursor.new($str);
        while !$mat && ($i <= $str.chars) {
            ($mat) = (self)($C.cursor($i++));
        }
        $mat ?? unitem($mat) !! Any;
    }
}

augment class Hash {
    method hash() { unitem(self) }
}

augment class STD {
    method panic($str) { die "$str at {self.pos}" }
constant $item_assignment_prec = 'i=';
constant $methodcall_prec = 'y=';
constant $LOOSEST = "a=!"; # XXX preceding line is busted
my %LOOSEST         = (:dba('LOOSEST')         , :prec<a=!>);
my %terminator      = (:dba('terminator')      , :prec<a=>, :assoc<list>);
method EXPR ($preclvl?) {
    my $preclim = $preclvl ?? $preclvl.<prec> // $LOOSEST !! $LOOSEST;
    my $*LEFTSIGIL = '';        # XXX P6
    my $*PRECLIM = $preclim;
    my @termstack;
    my @opstack;
    my $termish = 'termish';

    sub _top(@a) { @a[ @a.elems - 1 ] }

    my $state;
    my $here;

    sub reduce() {
        self.deb("entering reduce, termstack == ", +@termstack, " opstack == ", +@opstack) if $DEBUG::EXPR;
        my $op = pop @opstack;
        my $sym = $op<sym>;
        my $assoc = $op<O><assoc> // 'unary';
        if $assoc eq 'chain' {
            self.deb("reducing chain") if $DEBUG::EXPR;
            my @chain;
            push @chain, pop(@termstack);
            push @chain, $op;
            while @opstack {
                last if $op<O><prec> ne _top(@opstack)<O><prec>;
                push @chain, pop(@termstack);
                push @chain, pop(@opstack);
            }
            push @chain, pop(@termstack);
            my $endpos = @chain[0].to;
            @chain = reverse @chain if (+@chain) > 1;
            my $startpos = @chain[0].from;
            my $i = True;
            my @caplist;
            for @chain -> $c {
                push @caplist, ($i ?? 'term' !! 'op') => $c;
                $i = !$i;
            }
            push @termstack, Match.synthetic(
                :captures(@caplist, :_arity<CHAIN>, :chain(@chain)),
                :method<CHAIN>,
                :cursor(self),
                :from($startpos),
                :to($endpos));
        }
        elsif $assoc eq 'list' {
            self.deb("reducing list") if $DEBUG::EXPR;
            my @list;
            my @delims = $op;
            push @list, pop(@termstack);
            while @opstack {
                self.deb($sym ~ " vs " ~ _top(@opstack)<sym>) if $DEBUG::EXPR;
                last if $sym ne _top(@opstack)<sym>;
                if @termstack and defined @termstack[0] {
                    push @list, pop(@termstack);
                }
                else {
                    self.worry("Missing term in " ~ $sym ~ " list");
                }
                push @delims, pop(@opstack);
            }
            if @termstack and defined @termstack[0] {
                push @list, pop(@termstack);
            }
            else {
                self.worry("Missing final term in '" ~ $sym ~ "' list");
            }
            my $endpos = @list[0].to;
            @list = reverse @list if (+@list) > 1;
            my $startpos = @list[0].from;
            @delims = reverse @delims if (+@delims) > 1;
            my @caps;
            if @list {
                push @caps, (elem => @list[0]) if @list[0];
                my $i = 0;
                while $i < (+@delims)-1 {
                    my $d = @delims[$i];
                    my $l = @list[$i+1];
                    push @caps, (delim => $d);
                    push @caps, (elem => $l) if $l;  # nullterm?
                    $i++;
                }
            }
            push @termstack, Match.synthetic(
                :method<LIST>, :cursor(self),
                :from($startpos), :to($endpos),
                :captures(@caps, :_arity<LIST>, :delims(@delims),
                    :list(@list), :O($op<O>), :sym($sym)));
        }
        elsif $assoc eq 'unary' {
            self.deb("reducing") if $DEBUG::EXPR;
            self.deb("Termstack size: ", +@termstack) if $DEBUG::EXPR;

            my $arg = pop @termstack;
            if $arg.from < $op.from { # postfix
                push @termstack, Match.synthetic(
                    :cursor(self), :to($op.to), :from($arg.from),
                    :captures(arg => $arg, op => $op, _arity => 'UNARY'),
                    :method<POSTFIX>);
            }
            elsif $arg.to > $op.to {   # prefix
                push @termstack, Match.synthetic(
                    :cursor(self), :to($arg.to), :from($op.from),
                    :captures(op => $op, arg => $arg, _arity => 'UNARY'),
                    :method<PREFIX>);
            }
        }
        else {
            self.deb("reducing") if $DEBUG::EXPR;
            self.deb("Termstack size: ", +@termstack) if $DEBUG::EXPR;

            my $right = pop @termstack;
            my $left = pop @termstack;

            push @termstack, Match.synthetic(
                :to($right.to), :from($left.from), :cursor(self),
                :captures(:left($left), :infix($op), :right($right),
                    :_arity<BINARY>), :method<INFIX>);

#           self.deb(_top(@termstack).dump) if $DEBUG::EXPR;
            my $ck;
            if $ck = $op<O><_reducecheck> {
                _top(@termstack) = $ck(_top(@termstack));
            }
        }
    }

    sub termstate() {
        $here.deb("Looking for a term") if $DEBUG::EXPR;
        $here.deb("Top of opstack is ", _top(@opstack).dump) if $DEBUG::EXPR;
        $*LEFTSIGIL = _top(@opstack)<O><prec> gt $item_assignment_prec
            ?? '@' !! '';     # XXX P6
        my ($term) =
            ($termish eq 'termish') ?? $here.termish !!
            ($termish eq 'nulltermish') ?? $here.nulltermish !!
            ($termish eq 'statement') ?? $here.statement !!
            ($termish eq 'dottyopish') ?? $here.dottyopish !!
            die "weird value of $termish";

        if not $term {
            $here.deb("Didn't find it") if $DEBUG::EXPR;
            $here.panic("Bogus term") if (+@opstack) > 1;
            return 2;
        }
        $here.deb("Found term to {$term.to}") if $DEBUG::EXPR;
        $here = $here.cursor($term.to);
        $termish = 'termish';
        my @PRE = @( $term<PRE> // [] );
        my @POST = reverse @( $term<POST> // [] );

        # interleave prefix and postfix, pretend they're infixish
        # note that we push loose stuff onto opstack before tight stuff
        while @PRE and @POST {
            my $postO = @POST[0]<O>;
            my $preO = @PRE[0]<O>;
            if $postO<prec> lt $preO<prec> {
                push @opstack, shift @POST;
            }
            elsif $postO<prec> gt $preO<prec> {
                push @opstack, shift @PRE;
            }
            elsif $postO<uassoc> eq 'left' {
                push @opstack, shift @POST;
            }
            elsif $postO<uassoc> eq 'right' {
                push @opstack, shift @PRE;
            }
            else {
                $here.sorry('"' ~ @PRE[0]<sym> ~ '" and "' ~ @POST[0]<sym> ~ '" are not associative');
            }
        }
        push @opstack, @PRE,@POST;

        push @termstack, $term<term>;
        $here.deb("after push: " ~ (+@termstack)) if $DEBUG::EXPR;

        say "methodcall break" if $preclim eq $methodcall_prec; # in interpolation, probably   # XXX P6
        $state = &infixstate;
        return 0;
    }

    # std bug sees infixstate as unused
    sub infixstate() { #OK
        $here.deb("Looking for an infix") if $DEBUG::EXPR;
        return 1 if (@*MEMOS[$here.pos]<endstmt> // 0) == 2;  # XXX P6
        my ($ws) = $here.ws;
        $here = $here.cursor($ws.to);
        my ($infix) = $here.infixish;
        return 1 unless $infix;

        my $inO = $infix<O>;
        my $inprec = $inO<prec>;
        if not defined $inprec {
            die "No prec given in infix!";
        }

        if $inprec le $preclim {
            if $preclim ne $LOOSEST {
                my $dba = $*prevlevel.<dba>;
                my $h = $*HIGHEXPECT;
                %$h = ();
                $h.{"an infix operator with precedence tighter than $dba"} = 1;
            }
            return 1;
        }

        $here = $here.cursor($infix.to);
        ($ws,) = $here.ws;
        $here = $here.cursor($ws.to);

        # substitute precedence for listops
        $inO<prec> = $inO<sub> if $inO<sub>;

        # Does new infix (or terminator) force any reductions?
        while _top(@opstack)<O><prec> gt $inprec {
            reduce;
        }

        # Not much point in reducing the sentinels...
        return 1 if $inprec lt $LOOSEST;

        if $infix<fake> {
            push @opstack, $infix;
            reduce();
            return 0;  # not really an infix, so keep trying
        }

        # Equal precedence, so use associativity to decide.
        if _top(@opstack)<O><prec> eq $inprec {
            my $assoc = 1;
            my $atype = $inO<assoc>;
            if $atype eq 'non'   { $assoc = 0; }
            elsif $atype eq 'left'  { reduce() }   # reduce immediately
            elsif $atype eq 'right' { }            # just shift
            elsif $atype eq 'chain' { }            # just shift
            elsif $atype eq 'unary' { }            # just shift
            elsif $atype eq 'list'  {
                $assoc = 0 unless $infix<sym> eq _top(@opstack)<sym>;
            }
            else { $here.panic('Unknown associativity "' ~ $_ ~ '" for "' ~ $infix<sym> ~ '"') }
            if not $assoc {
               $here.sorry('"' ~ _top(@opstack)<sym> ~ '" and "' ~ $infix.Str ~ '" are non-associative and require parens');
            }
        }

        $termish = $inO<nextterm> if $inO<nextterm>;
        push @opstack, $infix;              # The Shift
        $state = &termstate;
        return 0;
    }

    push @opstack, { 'O' => %terminator, 'sym' => '' };         # (just a sentinel value)
    self.deb(@opstack.dump) if $DEBUG::EXPR;

    $here = self;
    self.deb("In EXPR, at {$here.pos}") if $DEBUG::EXPR;

    my $stop = 0;
    $state = &termstate;
    until $stop {
        $here.deb("At {$here.pos}, {@opstack.dump}; {@termstack.dump}") if $DEBUG::EXPR;
        $stop = $state();
    }
    $here.deb("Stop code $stop") if $DEBUG::EXPR;
    return () if $stop == 2;
    reduce() while +@opstack > 1;
    $here.deb("After final reduction, ", @termstack.dump, @opstack.dump) if $DEBUG::EXPR;

    if @termstack {
        +@termstack == 1 or $here.panic("Internal operator parser error, termstack == " ~ (+@termstack));
        return @( Match.synthetic(:to($here.pos), :from(self.pos),
                :cursor(self), :method<EXPR>,
                :captures( root => @termstack[0] )), );
    }
    return ();
}
}

augment class STD::P6 {
}

sub infix:<min>($a,$b) { $a > $b ?? $b !! $a }

augment class Cursor {
    our $RED    = "\e[31m";
    our $GREEN  = "\e[32m";
    our $YELLOW = "\e[33m";
    our $CLEAR  = "\e[37m";

    method canonicalize_name($n) {
        my $M;
        my $name = $n;
        if $M = $name ~~ /^(< $ @ % & >)( \^ || \: <!before \:> )(.*)/ {
            $name = $M[0] ~ $M[2];
        }
        if $name.chars >= 2 && substr($name, $name.chars - 2, 2) ~~ / \: < U D _ > / {
            $name = $name.substr(0, $name.chars - 2);
        }
        return $name unless $name ~~ /::/;
        self.panic("Can't canonicalize a run-time name at compile time: $name") if $name ~~ / '::(' /;

        if $M = $name ~~ /^ (< $ @ % & > < ! * = ? : ^ . >?) (.* '::') (.*) $/ {
            $name = $M[1] ~ "<" ~ $M[0] ~ $M[2] ~ ">";
        }
        my $vname;
        if $M = $name ~~ /^(.*) '::<' (.*) '>' $/ {
            $name = $M[0].Str;
            $vname = $M[1].Str;
        }
        my @components;
        while $M = $name ~~ / '::' / {
            push @components, $name.substr(0, $M.to);
            $name = substr($name, $M.to);
        }
        push @components, $name;
        shift(@components) while @components and @components[0] eq '';
        if (defined $vname) {
            @components[+@components - 1] ~= '::' if @components and @components[+@components - 1] !~~ /\:\:$/;
            push(@components, $vname) if defined $vname;
        }
        @components;
    }

    method locmess () {
        my $pos = self.pos;
        my $line = self.lineof($pos);

        if $pos >= chars(self.orig) {
            $line = $line ~ " (EOF)";
        }

        my $pre = substr(self.orig, 0, $pos);
        my $prel = chars($pre) min 40;
        $pre = substr($pre, chars($pre)-$prel, $prel);
        if my $M = ($pre ~~ /^.*\n/) {
            $pre = substr($pre, $M.to);
        }
        $pre = '<BOL>' if $pre eq '';
        my $post = substr(self.orig, $pos, (chars(self.orig)-$pos) min 40);
        if $M = ($post ~~ /\n/) {
            $post = substr($post,0,$M.from);
        }
        $post = '<EOL>' if $post eq '';
        " at " ~ $*FILE<name> ~ " line $line:\n------> " ~ $Cursor::GREEN ~
            $pre ~ $Cursor::YELLOW ~ "\x23CF" ~ $Cursor::RED ~ $post ~
            $Cursor::CLEAR;
    }

    method line {
        self.lineof(self.pos);
    }

    method lineof ($p) {
        return 1 unless defined $p;
        my $line = @*MEMOS[$p]<L>;
        return $line if $line;
        $line = 1; my $pos = 0;
        self.orig ~~ / [ \n { @*MEMOS[$pos++]<L> = $line++ } ||
                         .  { @*MEMOS[$pos++]<L> = $line } ]* /;
        @*MEMOS[$pos++]<L> = $line;
        return @*MEMOS[$p]<L> // 0;
    }

    method SETGOAL { }
    method FAILGOAL ($stop, $name, $startpos) {
        my $s = "'$stop'";
        $s = '"\'"' if $s eq "'''";
        self.panic("Unable to parse $name" ~ $startpos.locmess ~ "\nCouldn't find final $s; gave up");
    }

    method deb(*@str) { note @str }

    method cursor_fresh($k = self) { Q:CgOp {
        (ns (cursor_fresh (cast cursor (@ {self})) (@ {$k})))
    } }

    method mixin($role) { self.cursor_fresh(self.WHAT but $role) }

    method load_lex($) {
        # NYI
        my $id = "MY:file<NULL.pad>:line(1):pos(0)";
        my $core = Stash.new('!id' => [$id], '!file' => 'NULL.pad',
            '!line' => 1);
        Stash.new('CORE' => $core, 'MY:file<NULL.pad>' => $core,
            'SETTING' => $core, $id => $core);
    }

    method mark_sinks(@sl) {
        #NYI
        self
    }
}

{
    my $*SETTINGNAME = 'NULL';
    my @*MEMOS;
    my $*FILE = { name => '(eval)' };
    my @*ACTIVE;
    my $*HIGHWATER = 0;
    my $*HIGHEXPECT = {};
    my $*HIGHMESS = "";
    my $*LASTSTATE = 0;
    my $*IN_PANIC = 0;
    my $*IN_SUPPOSE = 0;
    my $*FATALS = 0;

    $STD::DEBUG::EXPR = True;
    $STD::DEBUG::symtab = True;

    my $*LAST_NIBBLE = Match.synthetic(:cursor(Cursor.new("")), :from(0), :to(0), :method(""), :captures());
    my $*LAST_NIBBLE_MULTILINE = $*LAST_NIBBLE;
    my $*GOAL = "(eof)";
    my $*SETTING; my $*CORE; my $*GLOBAL; my $*UNIT; my $*YOU_WERE_HERE;
    my $*CCSTATE; my $*BORG; my %*RX; my $*XACT; my $*VAR; my $*IN_REDUCE;
    STD.parse($*IN.slurp);
}
say "OK";
