use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use JSYNC;
use Metamodel;
use NAMOutput;
use NieczaActions;
use NieczaBackendClisp;
use NieczaBackendDotnet;
use NieczaBackendHoopl;
use NieczaBackendNAM;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

augment grammar STD {
my package DEBUG { our constant symtab = 3; }
method trymop($f) { $f() }
method explain_mystery() {
    my %post_types;
    my %unk_types;
    my %unk_routines;
    my $m = '';
    for keys(%*MYSTERY) {
        my $p = %*MYSTERY{$_}.<lex>;
        if self.is_name($_, $p) {
            # types may not be post-declared
            %post_types{$_} = %*MYSTERY{$_};
            next;
        }

        next if self.is_known($_, $p) or self.is_known('&' ~ $_, $p);

        # just a guess, but good enough to improve error reporting
        if $_ lt 'a' {
            %unk_types{$_} = %*MYSTERY{$_};
        }
        else {
            %unk_routines{$_} = %*MYSTERY{$_};
        }
    }
    if %post_types {
        my @tmp = sort keys(%post_types);
        $m ~= "Illegally post-declared type" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %post_types{$_}.<line> ~ "\n";
        }
    }
    if %unk_types {
        my @tmp = sort keys(%unk_types);
        $m ~= "Undeclared name" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %unk_types{$_}.<line> ~ "\n";
        }
    }
    if %unk_routines {
        my @tmp = sort keys(%unk_routines);
        $m ~= "Undeclared routine" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %unk_routines{$_}.<line> ~ "\n";
        }
    }
    self.sorry($m) if $m;

    for $*unit.stubbed_stashes {
        next if .key.closed || .key.WHAT === ::GLOBAL::Metamodel::Package;
        .value.sorry("Package was stubbed but not defined");
    }

    self;
}
method is_name($longname, $curlex = $*CURLEX) {
    my $deb = $*DEBUG +& DEBUG::symtab;
    self.deb("is_name $longname") if $deb;
    if defined($longname.index("::(")) {
        self.deb("computed name gets a free pass") if $deb;
        return True;
    }
    my @parts = $longname.split('::');
    shift @parts if @parts[0] eq '';
    pop @parts if @parts && @parts[*-1] eq ''; # doesn't change ref validity

    @parts[*-1] = $/ ~ @parts[*-1] if @parts && @parts[0] ~~ s/^(\W\W?)//;

    self.deb("reparsed: @parts.perl()") if $deb;
    return False if !@parts;

    my $pkg;

    if @parts[0] eq 'OUR' {
        $pkg = $*unit.deref($curlex<!sub>.cur_pkg);
        shift @parts;
    } elsif @parts[0] eq 'PROCESS' or @parts[0] eq 'GLOBAL' {
        $pkg = $*unit.abs_pkg(shift @parts);
    } elsif @parts[0] eq 'MY' {
        return False if @parts == 1;
        my $lexical = self.lookup_lex(@parts[1], $curlex);
        unless defined $lexical {
            self.deb("Lexical @parts[1] not found") if $deb;
            return False;
        }
        if $lexical ~~ ::Metamodel::Lexical::Stash {
            shift @parts; shift @parts;
            $pkg = $*unit.deref($lexical.pkg);
        }
        else {
            return @parts == 2;
        }
    } else {
        my $lexical = self.lookup_lex(@parts[0], $curlex);
        if !defined $lexical {
            return False if @parts == 1; # $x doesn't mean GLOBAL
            $pkg = $*unit.abs_pkg('GLOBAL');
        } elsif $lexical ~~ ::Metamodel::Lexical::Stash {
            $pkg = $*unit.deref($lexical.pkg);
            shift @parts;
        } else {
            return @parts == 1;
        }
    }

    for @parts {
        return False if !$pkg || !$*unit.ns.exists($pkg.who, $_);
        $pkg = $*unit.ns.get($pkg.who, $_);
        $pkg = $pkg && $*unit.deref($pkg);
    }

    return True;
}
}

augment class NieczaActions {
method blast($/) {
    if $<block> {
        make $<block>.ast;
    } else {
        make self.thunk_sub($<statement>.ast.statement_level);
    }
}

method install_sub($/, $sub, :$multiness is copy, :$scope is copy, :$class,
        :$path, :$name is copy, :$method_type is copy, :$contextual is copy) {

    $multiness ||= 'only';
    $path := Any if $name ~~ Op; #Hack

    if !$scope {
        if !defined($name) {
            $scope = 'anon';
        } elsif defined($path) {
            $scope = 'our';
        } elsif defined($method_type) {
            $scope = 'has';
        } else {
            $scope = 'my';
        }
    }

    if $scope ne 'my' && $scope ne 'our' && $scope ne 'anon' && $scope ne 'has' {
        $/.CURSOR.sorry("Illegal scope $scope for subroutine");
        $scope = 'anon';
    }

    if $scope eq 'has' && !defined($method_type) {
        $/.CURSOR.sorry('has scope-type is only valid for methods');
        $scope = 'anon';
    }

    if $scope ne 'anon' && !defined($name) {
        $/.CURSOR.sorry("Scope $scope requires a name");
        $scope = 'anon';
    }

    if $scope ne 'our' && defined($path) {
        $/.CURSOR.sorry("Double-colon-qualified subs must be our");
        $scope = 'our';
    }

    if $scope eq 'anon' && $multiness ne 'only' {
        $/.CURSOR.sorry("Multi routines must have a name");
        $multiness = 'only';
    }

    if $contextual && (defined($method_type) || $scope ne 'my') {
        $/.CURSOR.sorry("Context-named routines must by purely my-scoped");
        $contextual = False;
    }

    $method_type = Str if $scope eq 'anon';

    my $method_targ = $method_type && $sub.outer.body_of;
    if $method_targ {
        $method_targ = $*unit.deref($method_targ);
    } elsif defined($method_type) {
        $/.CURSOR.sorry("Methods must be used in some kind of package");
        $method_type = Str;
    }

    if $method_targ && !$method_targ.^can('add_method') {
        $/.CURSOR.sorry("A {$method_targ.WHAT} cannot have methods added");
        $method_type = Str;
        $method_targ = Any;
    }

    if $name ~~ Op && (!defined($method_type) || $scope ne 'has' ||
            $method_targ !~~ ::Metamodel::ParametricRole) {
        $/.CURSOR.sorry("Computed names are only implemented for parametric roles");
        $name = "placeholder";
    }

    my $bindlex = $scope eq 'my' || ($scope eq 'our' && !$path);

    $sub.set_name(($name ~~ Op) ?? '::($name)' !!
        defined($method_type) ?? $method_targ.name ~ "." ~ $name !!
        ($name // 'ANON'));
    $sub.class = $class;
    $sub.returnable = True;

    (sub () {
        my $std = $/.CURSOR;
        if $sub.name ~~ /^(\w+)\:\<(.*)\>$/ {
            my %new = %( $std.default_O(~$0, ~$1) );
            $sub.prec_info = %new;
        }
    }).();

    my Str $symbol;
    $/.CURSOR.trymop({
        if $bindlex && $class eq 'Regex' {
            $symbol = '&' ~ $name;
            my $proto = $symbol;
            $proto ~~ s/\:.*//;
            $sub.outer.add_dispatcher($proto, |mnode($/))
                if $multiness ne 'only' && !$sub.outer.lexicals.{$proto};
            $symbol ~= ":(!proto)" if $multiness eq 'proto';
        } elsif $bindlex {
            $symbol = '&' ~ $name;
            $/.CURSOR.check_categorical($symbol);
            if $multiness ne 'only' && !$sub.outer.lexicals.{$symbol} {
                $sub.outer.add_dispatcher($symbol, |mnode($/))
            }

            given $multiness {
                when 'multi' { $symbol ~= ":({ self.gensym })"; }
                when 'proto' { $symbol ~= ":(!proto)"; }
                default {
                    $/.CURSOR.check_categorical($symbol);
                }
            }
        } else {
            $symbol = self.gensym;
        }

        $sub.outervar = $symbol;
        $sub.methodof = defined($method_type) ?? $method_targ.xref !! Any;
        $sub.outer.add_my_sub($symbol, $sub, |mnode($/));

        if $multiness ne 'only' || $scope eq 'our' || $method_type {
            $sub.outer.lexicals-used{$symbol} = True;
        }

        if defined($method_type) || $scope eq 'our' {
            $sub.strong_used = True;
            $sub.outer.create_static_pad;
        }

        if defined($method_type) {
            if $sub.outer.augment_hack {
                push $sub.outer.augment_hack,
                    [ $multiness, $method_type, $name, $symbol, $sub.xref ];
            } else {
                $method_targ.add_method($multiness, $method_type, $name,
                    $symbol, $sub.xref, |mnode($/));
            }
        }

        if $scope eq 'our' {
            $sub.outer.bind_our_name($path, "&$name", $sub.xref);
        }
    });
}

method methodop($/) {
    if $<longname> {
        my $c = self.mangle_longname($<longname>);
        my $package;
        $/.CURSOR.trymop({
            $package = $*CURLEX<!sub>.compile_get_pkg(@($c<path>)).xref;
        }) if $c<path>;
        make ::Operator::Method.new(name => $c<name>, :$package);
    } elsif $<quote> {
        make ::Operator::Method.new(name => $<quote>.ast);
    } elsif $<variable> {
        make ::Operator::Function.new(function =>
            self.do_variable_reference($/, $<variable>.ast));
    }

    $/.ast.args = $<args>[0].ast[0] if $<args>[0];
    $/.ast.args = $<arglist>[0].ast if $<arglist>[0];
}
method do_new_package($/, :$sub = $*CURLEX<!sub>, :$scope!, :$path!,
        :$name!, :$class!, :$exports) {

    $scope := $scope || 'our';
    if $scope ne 'our' && $scope ne 'my' && $scope ne 'anon' {
        $/.CURSOR.sorry("Invalid packageoid scope $scope");
        $scope := 'anon';
    }

    if defined($path) && $scope ne 'our' {
        $/.CURSOR.sorry("Pathed definitions require our scope");
        $scope := 'our';
    }

    if !$name {
        $scope := 'anon';
        $name  := 'ANON';
        $path  := Any;
    }

    my $npkg;
    my $lexname;
    $/.CURSOR.trymop({
        my $old;
        if $scope ne 'anon' && !$path && $sub.lexicals.{$name} -> $l {
            die "Cannot resume definition - $name not a packageoid"
                unless $l ~~ ::Metamodel::Lexical::Stash;
            $old = $*unit.deref($l.pkg);
        } elsif defined $path {
            my $ppkg;
            try $ppkg = $sub.compile_get_pkg(@$path);
            my $xr = $ppkg && $*unit.get($ppkg, $name);
            $old = $xr && $*unit.deref($xr);
        }

        my $lexed_already;

        if $old && $old.WHAT === $class && !$old.closed {
            $npkg = $old;
            $lexed_already = True;
        } elsif $scope eq 'our' {
            my $ppkg = $sub.compile_get_pkg($path ?? @$path !! 'OUR', :auto);
            $npkg = $class.new(:$name, who => $ppkg.who ~ '::' ~ $name);
            $*unit.bind($ppkg, $name, $npkg.xref, |mnode($/));
        } else {
            my $id = $*unit.anon_stash;
            $npkg = $class.new(:$name, who => "::$id");
            $*unit.bind($*unit.abs_pkg(), $id, $npkg.xref, |mnode($/));
        }

        $lexname = (!$lexed_already && $scope ne 'anon' && !defined($path))
            ?? $name !! self.gensym;

        $sub.add_my_stash($lexname, $npkg.xref, |mnode($/));
        $sub.add_exports($name, $npkg.xref, $exports) if $exports;
    });

    $lexname, $npkg
}

method signature($/) {
    if $<type_constraint> {
        # ignore for now
    }

    if $<param_var> {
        my $sig = Sig.new(params => [ ::Sig::Parameter.new(
                name => ~$<param_var>, |$<param_var>.ast,
                full_parcel => True) ]);
        $*CURLEX<!sub>.signature = $sig if $*SIGNUM;
        make $sig;
        return;
    }

    my @p = map *.ast, @( $<parameter> );
    my @ps = @( $<param_sep> );
    my $ign = False;
    loop (my $i = 0; $i < @p; $i++) {
        @p[$i].multi_ignored = $ign;
        if $i >= @ps {
        } elsif defined @ps[$i].index(':') {
            $/.CURSOR.sorry('Only the first parameter may be invocant') if $i;
            $*CURLEX<!sub>.add_my_name('self', :noinit, |mnode($/));
            @p[$i].invocant = True;
        } elsif defined @ps[$i].index(';;') {
            $ign = True;
        } elsif !defined @ps[$i].index(',') {
            $/.CURSOR.sorry("Parameter separator @ps[$i] NYI");
        }
    }

    state %mlike = (:Method, :Submethod, :Regex);
    if $*SIGNUM && %mlike{$*CURLEX<!sub>.class} && (!@p || !@p[0].invocant) {
        $*CURLEX<!sub>.add_my_name('self', :noinit, |mnode($/));
        unshift @p, ::Sig::Parameter.new(name => 'self', :invocant);
    }

    for @p {
        if !defined(.tclass) && $*SIGNUM {
            if .invocant && $*CURLEX<!sub>.methodof {
                my $cl = $*unit.deref($*CURLEX<!sub>.methodof);
                # XXX type checking against roles NYI
                if $cl !~~ ::Metamodel::Role &&
                        $cl !~~ ::Metamodel::ParametricRole {
                    .tclass = $cl.xref;
                }
            } elsif !$*CURLEX<!sub>.returnable {
                .tclass = $*CURLEX<!sub>.compile_get_pkg('Mu').xref;
            }
        }
    }

    my $sig = Sig.new(params => @p);
    $*CURLEX<!sub>.signature = $sig if $*SIGNUM;
    make $sig;
}

method type_declarator:enum ($/) {
    my $scope = $*SCOPE || 'our';

    my @exports;
    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } else {
            $/.CURSOR.sorry("Unsupported enum trait $t.keys()");
        }
    }

    my @pairs = self.trivial_eval($/, $<term>.ast);
    my $last = -1;
    my ($has_ints, $has_strs);
    for @pairs {
        if $_ !~~ Pair {
            my $key = $_;
            my $value = $last.succ;
            $_ = $key => $value;
        }
        given $last = .value {
            when Int { $has_ints = True; }
            when Str { $has_strs = True; }
            default  { $/.CURSOR.sorry("Enum values must be Int or Str"); }
        }
    }
    if $has_ints && $has_strs {
        $/.CURSOR.sorry("Enum may not contain both Int and Str values");
    }

    my $basetype = $*OFTYPE ?? self.simple_longname($*OFTYPE<longname>) !!
        [$has_strs ?? 'Str' !! 'Int'];
    my $kindtype = $has_strs ?? 'StrBasedEnum' !! 'IntBasedEnum';

    if $<name> && $<name>.reduced eq 'longname' && $scope ne 'anon' {
        # Longnamed enum is a kind of type definition

        my $r = self.mangle_longname($<name>, True);

        my ($lexvar, $obj);
        $/.CURSOR.trymop({
            ($lexvar, $obj) = self.do_new_package($/, :$scope,
                class => ::Metamodel::Class, name => $r<name>,
                path => $r<path>, :@exports);

            $obj.add_super($*CURLEX<!sub>.compile_get_pkg($kindtype).xref);
            $obj.add_super($*CURLEX<!sub>.compile_get_pkg(@$basetype).xref);

            my $nb = ::Metamodel::StaticSub.new(
                transparent=> True,
                unit       => $*unit,
                outerx     => $*CURLEX<!sub>.xref,
                outer_direct => $*CURLEX<!sub>,
                name       => $r<name> ~ '.enums',
                cur_pkg    => $*CURLEX<!sub>.cur_pkg,
                class      => 'Method',
                signature  => Sig.simple('self'),
                code       => self.init_constant(
                    self.make_constant($/, 'anon', Any),
                    ::Op::CallMethod.new(name => 'new',
                        receiver => mklex($/, 'EnumMap'), args => [$<term>.ast])));

            my $nbvar = self.gensym;
            $nb.add_my_name('self', noinit => True);
            $*CURLEX<!sub>.create_static_pad;
            $nb.strong_used = True;
            $*CURLEX<!sub>.add_child($nb);
            $*CURLEX<!sub>.add_my_sub($nbvar, $nb, |mnode($/));
            $obj.add_method('only', 'normal', 'enums', $nbvar,
                $nb.xref, |mnode($/));
            $obj.close;

            for @pairs {
                self.make_constant_into($/, $obj, .key, rhs =>
                    ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                        args => [ ::Op::StringLiteral.new(text => .key) ]));
            }

            for @pairs {
                self.init_constant(self.make_constant($/, $scope, .key),
                    ::Op::CallSub.new(invocant => mklex($/, $lexvar),
                        args => [ ::Op::StringLiteral.new(text => .key) ]));
            }
        });

        make mklex($/, $lexvar);
    } else {
        make self.init_constant(
            self.make_constant($/, $<name> ?? $scope !! 'anon', ~$<name>),
            ::Op::CallMethod.new(|node($/), name => 'new',
                receiver => mklex($/, 'EnumMap'),
                args => [$<term>.ast])),
    }
}

method make_constant($/, $scope, $name) {
    $scope := $scope || 'our';

    my $slot = ($scope eq 'my' || $scope eq 'our') ?? $name !! self.gensym;

    $/.CURSOR.trymop({
        $/.CURSOR.check_categorical($slot);
        if $scope eq 'our' {
            $*CURLEX<!sub>.add_common_name($slot, $*CURLEX<!sub>.cur_pkg,
                $name, |mnode($/));
        } else {
            $*CURLEX<!sub>.add_hint($slot, |mnode($/));
        }
    });

    ::Op::ConstantDecl.new(|node($/), name => $slot, init => False);
}

method make_constant_into($/, $pkg, $name, $rhs) {
    my $slot = self.gensym;
    $/.CURSOR.trymop({
        $*CURLEX<!sub>.add_common_name($slot, $pkg.xref, $name, |mnode($/));
    });
    self.init_constant(::Op::ConstantDecl.new(|node($/), name => $slot,
        init => False), $rhs);
}

method type_declarator:constant ($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    my $name  = ~($<identifier> // $<variable> // self.gensym);

    make self.make_constant($/, $*SCOPE, $name);
}

method simple_longname($/) {
    my $r = self.mangle_longname($/);
    [ @( $r<path> // [] ), $r<name> ]
}

method package_var($/, $slot, $name, $path, :$list, :$hash) {
    $/.CURSOR.trymop({
        $/.CURSOR.check_categorical($slot);
        $*CURLEX<!sub>.add_common_name($slot,
            $*CURLEX<!sub>.compile_get_pkg(@$path, :auto).xref,
            $name, |mnode($/));
        $*CURLEX<!sub>.lexicals-used{$slot} = True;
    });
    ::Op::PackageVar.new(|node($/), :$slot, :$name, :$path, :$list, :$hash);
}

method open_package_def($, $/ = $*cursor) {
    state %_decl2mclass = (
        package => ::Metamodel::Package,
        class   => ::Metamodel::Class,
        module  => ::Metamodel::Module,
        grammar => ::Metamodel::Grammar,
        role    => ::Metamodel::Role,
    );
    my $sub = $*CURLEX<!sub>;

    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }

    my $r = $<longname> && self.mangle_longname($<longname>[0], True);

    if $*SCOPE eq 'augment' && $r {
        $/.CURSOR.trymop({
            my $obj = $sub.outer.compile_get_pkg(@( $r<path> // [] ), $r<name>, :auto);

            if $obj.^isa(::Metamodel::Role) {
                die "Illegal augment of a role";
            }

            $sub.augment_hack = [ $obj.xref ];
            $sub.body_of = $sub.in_class = $sub.cur_pkg = $obj.xref;
            $sub.augmenting = True;
            $sub.set_name("augment-$obj.name()");
        });
    } else {
        my $type = %_decl2mclass{$*PKGDECL};
        if ($*PKGDECL//'role') eq 'role' && $<signature> {
            $sub.signature = $<signature>.ast;
            $type = ::Metamodel::ParametricRole;
        }

        $/.CURSOR.trymop({
            my ($lexvar, $obj) = self.do_new_package($/, sub => $sub.outer,
                class => $type, name => $r<name>, path => $r<path>,
                scope => $*SCOPE);

            $sub.outervar = $lexvar;
            $sub.body_of = $sub.in_class = $sub.cur_pkg = $obj.xref;

            self.process_block_traits($/, $<trait>);
            $sub.set_name($*PKGDECL ~ "-" ~ $obj.name);
        });
    }
}

method package_def ($/) {
    my $sub = $*CURLEX<!sub>;

    my $bodyvar = self.gensym;
    $sub.outer.add_my_sub($bodyvar, $sub);
    $sub.code = ($<blockoid> // $<statementlist>).ast;

    if $sub.augmenting {
        my $ah = $sub.augment_hack;
        $sub.augment_hack = Any;

        my $ph = ::Metamodel::StaticSub.new(
            unit       => $*unit,
            outerx     => $sub.xref,
            outer_direct => $*CURLEX<!sub>,
            cur_pkg    => $sub.cur_pkg,
            name       => 'ANON',
            is_phaser  => 0,
            augment_hack => $ah,
            class      => 'Code',
            code       => ::Op::StatementList.new(children => []),
            run_once   => $sub.run_once);
        $sub.create_static_pad;
        $sub.add_child($ph);

        make ::Op::CallSub.new(|node($/), invocant => mklex($/, $bodyvar));
    }
    else {
        my $obj = $*unit.deref($sub.body_of);

        if $<stub> {
            push $*unit.stubbed_stashes, ($obj => $/.CURSOR);

            make mklex($/, $*CURLEX<!sub>.outervar);
        }
        else {
            $/.CURSOR.trymop({ $obj.close; });

            if $obj ~~ ::Metamodel::ParametricRole {
                $sub.parametric_role_hack = $obj.xref;
                $sub.add_my_name('*params', :noinit);
                $sub.create_static_pad;

                make mklex($/, $*CURLEX<!sub>.outervar);
            } else {
                make ::Op::StatementList.new(|node($/), children => [
                    ::Op::CallSub.new(invocant => mklex($/, $bodyvar)),
                    ::Op::Lexical.new(name => $*CURLEX<!sub>.outervar) ]);
            }
        }
    }
}



method parameter($/) {
    my $rw = False;
    my $copy = False;
    my $sorry;
    my $slurpy = False;
    my $slurpycap = False;
    my $optional = False;
    my $rwt = False;
    my $type;

    if $<type_constraint> {
        my $t = self.simple_longname($<type_constraint>[0]<typename><longname>);
        $type = $*CURLEX<!sub>.compile_get_pkg(@$t).xref;
    }

    for @( $<trait> ) -> $trait {
        if $trait.ast<rw> { $rw = True }
        elsif $trait.ast<copy> { $copy = True }
        elsif $trait.ast<parcel> { $rwt = True }
        elsif $trait.ast<readonly> { $rw = False }
        else {
            $trait.CURSOR.sorry('Unhandled trait ' ~ $trait.ast.keys.[0]);
        }
    }

    if $<post_constraint> > 0 {
        $/.sorry('Parameter post constraints NYI');
        make ::Sig::Parameter.new;
        return Nil;
    }

    my $default = $<default_value> ?? $<default_value>[0].ast !! Any;
    $*unit.deref($default).set_name("$/ init") if $default;

    my $tag = $<quant> ~ ':' ~ $<kind>;
    if    $tag eq '**:*' { $sorry = "Slice parameters NYI" }
    elsif $tag eq '*:*'  { $slurpy = True }
    elsif $tag eq '|:*'  { $slurpycap = True }
    elsif $tag eq '\\:!' { $rwt = True }
    elsif $tag eq '\\:?' { $rwt = True; $optional = True }
    elsif $tag eq ':!'   { }
    elsif $tag eq ':*'   { $optional = True }
    elsif $tag eq ':?'   { $optional = True }
    elsif $tag eq '?:?'  { $optional = True }
    elsif $tag eq '!:!'  { }
    elsif $tag eq '!:?'  { $optional = True }
    elsif $tag eq '!:*'  { }
    else                 { $sorry = "Confusing parameters ($tag)" }
    if $sorry { $/.CURSOR.sorry($sorry); }
    my $p = $<param_var> // $<named_param>;

    if defined $p.ast<slot> {
        # TODO: type constraint here
    }

    make ::Sig::Parameter.new(name => ~$/, mdefault => $default,
        :$optional, :$slurpy, :$rw, tclass => $type,
        :$slurpycap, rwtrans => $rwt, is_copy => $copy, |$p.ast);
}

method type_declarator:subset ($/) {
    my $r = $<longname> && self.mangle_longname($<longname>[0], True);

    my $basetype = $*OFTYPE ?? self.simple_longname($*OFTYPE<longname>) !!
        ['Any'];
    my @exports;

    for map *.ast, @$<trait> -> $t {
        if $t<export> {
            push @exports, @( $t<export> );
        } elsif $t<of> {
            $basetype = $t<of>;
        } else {
            $/.CURSOR.sorry("Unsupported subset trait $t.keys()");
        }
    }

    my $body = self.thunk_sub($<EXPR> ?? $<EXPR>[0].ast !! mklex($/, 'True'));

    my ($lexvar, $obj) = "Any";

    $/.CURSOR.trymop({
        ($lexvar, $obj) = self.do_new_package($/, scope => $*SCOPE,
            name => $r<name>, path => $r<path>, class => ::Metamodel::Subset,
            :@exports);

        $*CURLEX<!sub>.create_static_pad;

        $obj.basetype = $*CURLEX<!sub>.compile_get_pkg(@$basetype).xref;
        $obj.where = $body.xref;
    });

    make mklex($/, $lexvar);
}

method add_attribute($/, $name, $sigil, $accessor, $type) {
    my $ns = $*CURLEX<!sub>.body_of;
    $/.CURSOR.sorry("Attribute $name declared outside of any class"),
        return ::Op::StatementList.new unless $ns;
    $/.CURSOR.sorry("Attribute $name declared in an augment"),
        return ::Op::StatementList.new if $*CURLEX<!sub>.augmenting;

    $ns = $*unit.deref($ns);

    if !$ns.^can('add_attribute') {
        $/.CURSOR.sorry("A $ns.WHAT() cannot have attributes");
        return ::Op::StatementList.new
    }

    my $nb = ::Metamodel::StaticSub.new(
        transparent=> True,
        unit       => $*unit,
        outerx     => $*CURLEX<!sub>.xref,
        outer_direct => $*CURLEX<!sub>,
        name       => $name,
        cur_pkg    => $*CURLEX<!sub>.cur_pkg,
        class      => 'Method',
        signature  => Sig.simple('self'),
        code       => ::Op::GetSlot.new(name => $name,
            object => ::Op::Lexical.new(name => 'self')));
    $nb.add_my_name('self', noinit => True);
    $*CURLEX<!sub>.create_static_pad; # for protosub instance
    $nb.strong_used = True;
    $*CURLEX<!sub>.add_child($nb);
    my $at;

    $/.CURSOR.trymop({
        my $ac = self.gensym;
        $*CURLEX<!sub>.add_my_sub($ac, $nb, |mnode($/));
        $at = $ns.add_attribute($name, $sigil, +$accessor, Any, Any, $type,
            |mnode($/));
        $ns.add_method('only', 'private', $name, $ac, $nb.xref,
            |mnode($/));
        if $accessor {
            $ns.add_method('only', 'normal', $name, $ac, $nb.xref,
                |mnode($/));
        }
    });

    $at ?? ::Op::Attribute.new(name => $name, initializer => $at) !!
        ::Op::StatementList.new;
}

method variable_declarator($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    for @$<trait> -> $t {
        if $t.ast<rw> {
        } else {
            $/.CURSOR.sorry("Trait $t.ast.keys.[0] not available on variables");
        }
    }
    if $<post_constraint> || $<postcircumfix> || $<semilist> {
        $/.CURSOR.sorry("Postconstraints, and shapes on variable declarators NYI");
    }

    my $scope = $*SCOPE // 'my';

    if $scope eq 'augment' || $scope eq 'supersede' {
        $/.CURSOR.sorry("Illogical scope $scope for simple variable");
    }

    my $typeconstraint;
    if $*OFTYPE {
        $typeconstraint = self.simple_longname($*OFTYPE<longname>);
        $/.CURSOR.sorry("Common variables are not unique definitions and may not have types") if $scope eq 'our';
    }

    my $v = $<variable>.ast;
    my $t = $v<twigil>;
    my $list = $v<sigil> eq '@';
    my $hash = $v<sigil> eq '%';
    if ($t && defined "?=~^:".index($t)) {
        $/.CURSOR.sorry("Variables with the $t twigil cannot be declared " ~
            "using $scope; they are created " ~
            ($t eq '?' ?? "using 'constant'." !!
             $t eq '=' ?? "by parsing POD blocks." !!
             $t eq '~' ?? "by 'slang' definitions." !!
             "automatically as parameters to the current block."));
    }

    if $scope ne 'has' && ($t eq '.' || $t eq '!') {
        $/.CURSOR.sorry("Twigil $t is only valid on attribute definitions ('has').");
    }

    if defined $v<rest> {
        $/.CURSOR.sorry(":: syntax is only valid when referencing variables, not when defining them.");
    }

    my $name = $v<sigil> ~ $v<twigil> ~ $v<name>;
    # otherwise identical to my
    my $slot = ($scope eq 'anon') ?? self.gensym !! $name;
    my $res_tc = $typeconstraint ??
        $*CURLEX<!sub>.compile_get_pkg(@$typeconstraint).xref !! Any;

    if $scope eq 'has' {
        make self.add_attribute($/, $v<name>, $v<sigil>, $t eq '.', $res_tc);
    } elsif $scope eq 'state' {
        $/.CURSOR.trymop({
            $/.CURSOR.check_categorical($slot);
            $*CURLEX<!sub>.add_state_name($slot, self.gensym, :$list,
                :$hash, typeconstraint => $res_tc, |mnode($/));
        });
        make ::Op::Lexical.new(|node($/), name => $slot, :$list, :$hash,
            :state_decl);
    } elsif $scope eq 'our' {
        make self.package_var($/, $slot, $slot, ['OUR'], :$list, :$hash);
    } else {
        $/.CURSOR.trymop({
            $/.CURSOR.check_categorical($slot);
            $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash,
                typeconstraint => $res_tc, |mnode($/));
        });
        make ::Op::Lexical.new(|node($/), name => $slot, :$list, :$hash);
    }
}

method do_variable_reference($M, $v) {
    if $v<term> {
        return $v<term>;
    }

    my $tw = $v<twigil>;
    my $sl = $v<sigil> ~ $tw ~ $v<name>;
    my $list = $v<sigil> eq '@';
    my $hash = $v<sigil> eq '%';

    if defined($v<rest>) && $tw ~~ /<[*=~?^:]>/ {
        $M.CURSOR.sorry("Twigil $tw cannot be used with qualified names");
        return ::Op::StatementList.new;
    }

    if $tw eq '!' {
        my $pclass;
        if $v<rest> {
            $pclass = $*CURLEX<!sub>.compile_get_pkg(@($v<rest>)).xref;
        } elsif $*CURLEX<!sub>.in_class -> $c {
            $pclass = $c;
        } else {
            $M.CURSOR.sorry("Cannot resolve class for private method");
        }
        self.docontext($M, $v<sigil>, ::Op::CallMethod.new(|node($M),
            name => $v<name>, private => True, receiver => mklex($M, 'self'),
            :$pclass));
    }
    elsif $tw eq '.' {
        if defined $v<rest> {
            $M.CURSOR.sorry('$.Foo::bar syntax NYI');
            return ::Op::StatementList.new;
        }

        self.docontext($M, $v<sigil>, ::Op::CallMethod.new(|node($M),
            name => $v<name>, receiver => mklex($M, 'self')));
    }
    # no twigil in lex name for these
    elsif $tw eq '^' || $tw eq ':' {
        mklex($M, $v<sigil> ~ $v<name>, :$hash, :$list);
    }
    elsif $tw eq '*' {
        ::Op::ContextVar.new(|node($M), name => $sl);
    }
    elsif $tw eq '' || $tw eq '?' {
        if defined($v<rest>) {
            self.package_var($M, self.gensym, $sl, $v<rest>,
                hash => ($v<sigil> eq '%'), list => ($v<sigil> eq '@'))
        } elsif $tw eq '?' && $sl eq '$?POSITION' {
            mkcall($M, '&infix:<..^>',
                ::Op::Num.new(|node($M), value => [10, ~$M.from]),
                ::Op::Num.new(|node($M), value => [10, ~$M.to]));
        } elsif $tw eq '?' && $sl eq '$?LINE' {
            ::Op::Num.new(|node($M), value => [10, ~$M.cursor.lineof($M.from)]);
        } elsif $tw eq '?' && $sl eq '&?BLOCK' {
            $*CURLEX<!sub>.noninlinable;
            ::Op::GetBlock.new(|node($M))
        } elsif $tw eq '?' && $sl eq '&?ROUTINE' {
            $*CURLEX<!sub>.noninlinable;
            ::Op::GetBlock.new(|node($M), :routine)
        } else {
            mklex($M, $sl, :$hash, :$list);
        }
    }
    else {
        $M.CURSOR.sorry("Unhandled reference twigil $tw");
    }
}

method process_block_traits($/, @tr) {
    my $sub = $*CURLEX<!sub>;
    my $pack = $sub.body_of;
    for @tr -> $T {
        my $tr = $T.ast;
        if $pack && ($tr<name>:exists) {
            my ($name, $path) = $tr<name path>;

            $T.CURSOR.sorry("superclass $name declared outside of any class"),
                next unless $sub.body_of;
            $T.CURSOR.sorry("superclass $name declared in an augment"),
                next if $sub.augmenting;
            $T.CURSOR.sorry("cannot declare a superclass in this kind of package"),
                next if !$*unit.deref($pack).^can('add_super');

            $T.CURSOR.trymop({
                $*unit.deref($pack).add_super($sub.compile_get_pkg(
                    @($path // []), $name).xref);
            });
        } elsif $pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports($*unit.deref($pack).name, $pack, @exports);
        } elsif !$pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports('&'~$sub.name, $sub.xref, @exports);
            $sub.strong_used = True;
            $sub.outer.create_static_pad;
            $sub.outer.lexicals-used{$sub.outervar} = True
                if defined $sub.outervar;
        } elsif !$pack && $tr<nobinder> {
            $sub.signature = Any;
        } elsif !$pack && grep { defined $tr{$_} }, <looser tighter equiv> {
            my $rel = $tr.keys.[0];
            my $to  = $tr.values.[0];
            $to = $to.inside if $to ~~ ::Op::Paren;
            $to = $to.children[0] if $to ~~ ::Op::StatementList && $to.children == 1;

            my $oprec;
            if $to ~~ ::Op::Lexical {
                $oprec = $T.CURSOR.function_O($to.name);
            } elsif $to ~~ ::Op::StringLiteral && $sub.name ~~ /^(\w+)\:\<.*\>$/ {
                $oprec = $T.CURSOR.cat_O(~$0, $to.text);
            } else {
                $T.CURSOR.sorry("Cannot interpret operator reference");
                next;
            }
            unless $oprec {
                $T.CURSOR.sorry("No precedence available for reference target");
                next;
            }
            my %new = %$oprec;
            $sub.prec_info = %new;
            $sub.prec_info.<prec> ~~ s/\=/<=/ if $rel eq 'looser';
            $sub.prec_info.<prec> ~~ s/\=/>=/ if $rel eq 'tighter';
        } elsif !$pack && $tr<assoc> {
            my $arg = ~self.trivial_eval($T, $tr<assoc>);
            unless $sub.prec_info {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            my @valid = < left right non list unary chain >;
            unless grep $arg, @valid {
                $T.CURSOR.sorry("Invalid associativity $arg");
                next;
            }
            $sub.prec_info.<assoc> = $arg;
        } elsif !$pack && $tr<Niecza::absprec> {
            my $arg = ~self.trivial_eval($T, $tr<Niecza::absprec>);
            unless $sub.prec_info {
                $T.CURSOR.sorry("Target does not seem to be an operator");
                next;
            }
            $sub.prec_info.<prec> = $arg;
            $sub.prec_info.<dba> = "like $sub.name()";
        } elsif !$pack && $tr<return_pass> {
            $sub.returnable = False;
        } elsif !$pack && $tr<of> {
        } elsif !$pack && $tr<rw> {
        } elsif !$pack && $tr<unsafe> {
            $sub.unsafe = True;
        } else {
            $T.CURSOR.sorry("Unhandled trait $tr.keys[0] for this context");
        }
    }
}

method statement_control:use ($/) {
    make ::Op::StatementList.new;
    return if $<version>; # just ignore these

    my $name = $<module_name>.ast<name>;
    my $args = $<arglist> ?? $<arglist>.ast !! [];

    if defined $<module_name>.ast.<args> {
        $/.CURSOR.sorry("'use' of an instantiated role not yet understood");
        return;
    }

    if $args {
        $/.CURSOR.sorry("'use' with arguments NYI");
        return;
    }

    if ($name eq 'MONKEY_TYPING' || $name eq 'fatal' || $name eq 'lib') {
        return;
    }

    my $u2 = $*unit.need_unit($name);

    my $module = $u2.mainline.compile_get_pkg($name.split('::'));
    my $exp;
    try $exp = $*unit.get_pkg($module, 'EXPORT', 'DEFAULT');

    # in the :: case, $module will usually be visible via GLOBAL
    if !defined($name.index('::')) {
        $*CURLEX<!sub>.add_my_stash($name, $module.xref);
    }

    return unless $exp;

    my $h = $/.CURSOR;
    for $*unit.list_stash($exp) -> $tup {
        my $uname = $tup.key;
        my $obj   = $tup.value && $*unit.deref($tup.value);

        if !$obj || $obj ~~ ::Metamodel::StaticSub {
            $*CURLEX<!sub>.add_common_name($uname, $exp.xref, $uname);
        } else {
            $*CURLEX<!sub>.add_my_stash($uname, $obj.xref);
        }
        $h.check_categorical($uname);
        $h = $h.cursor_fresh(%*LANG<MAIN>);
    }
}

}

CgOp._register_ops: <
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => [ NieczaPassSimplifier.new ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
}
