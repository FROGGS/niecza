use Metamodel;
use Op;
use RxOp;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaBackendHoopl;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;
use OptRxSimple;
use STD;
use Sig;

augment class NieczaActions {
sub qpvalue($ast) {
    if $ast.^isa(::Op::SimpleParcel) {
        join " ", map &qpvalue, @( $ast.items )
    } elsif $ast.^isa(::Op::StringLiteral) {
        $ast.text;
    } elsif $ast.^isa(::Op::Paren) {
        qpvalue($ast.inside);
    } else {
        "XXX"
    }
}

method colonpair($/) {
    my $n;
    if !$<v>.^isa(Match) {
        $n = ":" ~ ($<v> ?? '' !! '!') ~ $<k>;
    } else {
        $n = ":" ~ $<k> ~ "<" ~ qpvalue($<v>.ast) ~ ">";
    }
    my $tv = $<v>.^isa(Match) ?? $<v>.ast !!
        ::Op::Lexical.new(name => $<v> ?? 'True' !! 'False');

    if $tv ~~ Str {
        if substr($<v>,1,1) eq '<' {
            $tv = ::Op::CallMethod.new(name => 'at-key',
                receiver => ::Op::ContextVar.new(name => '$*/'),
                args => [::Op::StringLiteral.new(text => ~$<k>)]);
        } else {
            $tv = self.do_variable_reference($/,
                { sigil => ~$<v><sigil>,
                    twigil => ($<v><twigil> ?? ~$<v><twigil>[0] !! ''),
                    name => $<k> });
        }
    }

    make { ext => $n, term => ::Op::SimplePair.new(key => $<k>, value => $tv) };
}

sub mkstringycat($/, *@strings) {
    my @a;
    for @strings -> $s {
        my $i = ($s !~~ Op) ?? ::Op::StringLiteral.new(|node($/),
            text => $s) !! $s;

        # this *might* belong in an optimization pass
        if @a && @a[*-1] ~~ ::Op::StringLiteral &&
                $i ~~ ::Op::StringLiteral {
            @a[*-1] = ::Op::StringLiteral.new(|node($/),
                text => (@a[*-1].text ~ $i.text));
        } else {
            push @a, $i;
        }
    }
    if @a == 0 {
        return ::Op::StringLiteral.new(|node($/), text => "");
    } elsif  @a == 1 {
        return (@a[0] ~~ ::Op::StringLiteral) ?? @a[0] !!
            mkcall($/, '&prefix:<~>', @a[0]);
    } else {
        return mkcall($/, '&infix:<~>', @a);
    }
}
method process_nibble($/, @bits, $prefix?) {
    my @acc;
    for @bits -> $n {
        my $ast = $n.ast;

        if $ast ~~ CClass {
            $n.CURSOR.sorry("Cannot use a character class in a string");
            $ast = "";
        }

        if $ast !~~ Op && defined($prefix) && $prefix ne "" {
            $ast = $ast.split(/^^<before \h>[ $prefix || \h+ ]/).join("");
        }

        push @acc, $ast;
    }

    my $post = $/.CURSOR.postprocessor;
    make mkstringycat($/, @acc);

    if $post eq 'null' {
        # already OK
    }
    # actually quotewords is a bit trickier than this...
    elsif $post eq 'words' || $post eq 'quotewords' {
        my $sl = $/.ast;
        if !$sl.^isa(::Op::StringLiteral) {
            make ::Op::CallMethod.new(|node($/), :name<words>, receiver => $sl);
        }
        else {
            my @tok = $sl.text.words;
            @tok = map { ::Op::StringLiteral.new(|node($/), text => $_) }, @tok;

            make ((@tok == 1) ?? @tok[0] !! ::Op::Paren.new(|node($/),
                inside => ::Op::SimpleParcel.new(|node($/), items => @tok)));
        }
    }
    elsif $post eq 'path' {
        # TODO could stand to be a lot fancier.
        make ::Op::CallMethod(|node($/), receiver => $/.ast, :name<IO>);
    }
    elsif $post eq 'run' {
        make mkcall($/, 'rungather', $/.ast);
    }
    else {
        $/.CURSOR.sorry("Unhandled postprocessor $post");
    }

    $/.ast;
}
method simple_longname($/) {
    my $r = self.mangle_longname($/);
    ($r<path>:exists) ?? [ @($r<path>), $r<name> ] !! [ 'MY', $r<name> ];
}
}

augment class Op::ForLoop { #OK exist
    method statement_level() {
        my $var = [ map { ::GLOBAL::NieczaActions.gensym },
            0 ..^ +$.sink.body.signature.params ];
        $.sink.once = True;
        ::Op::ImmedForLoop.new(source => $.source, var => $var,
            sink => ::Op::CallSub.new(invocant => $.sink,
                positionals => [ map { ::Op::LetVar.new(name => $_) }, @$var]));
    }
}

augment class Op::ImmedForLoop { #OK exist
    method code_labelled($body, $l) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.rnull(CgOp.letn(
            "!iter$id", CgOp.vvarlist_new_empty,
            (map { $_, CgOp.null('var') }, @$.var),
            CgOp.vvarlist_push(CgOp.letvar("!iter$id"),
                $.source.cgop($body)),
            CgOp.whileloop(0, 0,
                CgOp.iter_hasflat(CgOp.letvar("!iter$id")),
                CgOp.prog(
                    (map { CgOp.letvar($_,
                        CgOp.vvarlist_shift(CgOp.letvar("!iter$id")))},@$.var),
                    CgOp.sink(CgOp.xspan("redo$id", "next$id", 0,
                        $.sink.cgop($body),
                        1, $l, "next$id",
                        2, $l, "last$id",
                        3, $l, "redo$id")))),
            CgOp.label("last$id")));
    }
}

augment class CgOp {
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $stages;
if $bcnd eq 'clisp' {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassSimplifier.new,
    ];
} elsif $bcnd eq 'hoopl' {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassSimplifier.new,
    ];
} else {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ];
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => $stages,
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        $c.compile_string("say (" ~ $l ~ ").perl", !$comp, $stop);
    }
}
