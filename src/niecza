use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

# augment class RxOp {
# method oplift() {
#     say "oplift: {self.typename}";
#     my $i = 0;
#     map { say $i++; .oplift }, @$!zyg
# }
# }

# RxOp::VarString.param NO LONGER USED

augment class RxOp::Tilde {
    method code($body) {
        my @code;
        my $fail = self.label;
        my $pass = self.label;

        $body.add_my_name('$*GOAL') unless $body.has_lexical('$*GOAL');

        push @code, CgOp.rxcall("PushGoal", CgOp.callframe, CgOp.str($!closer));
        push @code, $.zyg[0].code($body);
        push @code, CgOp.rxpushb("TILDE", $fail);
        push @code, CgOp.rxbprim('Exact', CgOp.str($!closer));
        push @code, CgOp.goto($pass);
        push @code, CgOp.label($fail);
        push @code, CgOp.sink(CgOp.methodcall(CgOp.newscalar(
                CgOp.rxcall("MakeCursor")), 'FAILGOAL',
            CgOp.string_var($!closer), CgOp.string_var($!dba),
            CgOp.box('Num', CgOp.cast('num', CgOp.rxgetquant))));
        push @code, CgOp.label($pass);
        push @code, CgOp.rxcall("PopGoal", CgOp.callframe);

        @code;
    }
}

augment class Op::RegexBody {
    method code($body) {
        my @mcaps;
        my $*in_quant = False;
        my $u = $.rxop.used_caps;
        for keys $u {
            push @mcaps, $_ if $u{$_} >= 2;
        }
        my @pre = map { CgOp.sink($_.cgop($body)) }, @$.pre;
        my @core = $.rxop.code($body);
        unshift @pre, CgOp.scopedlex('$*GOAL',
            CgOp.context_get('$*GOAL', 1)) if $body.has_lexical('$*GOAL');

        CgOp.prog(
            @pre,
            CgOp.rxinit(CgOp.str($.name),
                    CgOp.cast('cursor', CgOp.fetch(CgOp.scopedlex('self'))),
                    +$.passcut),
            CgOp.rxpushcapture(CgOp.null('var'), @mcaps),
            @core,
            ($.canback ?? CgOp.rxend !! CgOp.rxfinalend),
            CgOp.label('backtrack'),
            CgOp.rxbacktrack,
            CgOp.null('var'));
    }
}

class RxOp::StringCap is RxOp::Capturing {
    # zyg * 1

    method clone(:$captures) {
        self.WHAT.new(zyg => $.zyg, :$captures);
    }

    method code($body) { #OK not used
        my @code;

        push @code, CgOp.pushcut("CAP");
        push @code, CgOp.rxsetquant(CgOp.rxgetpos);
        push @code, $.zyg[0].code($body);
        push @code, CgOp.rxpushcapture(CgOp.rxcall("StringCapture"), @$.captures);
        push @code, CgOp.popcut;

        @code;
    }

    method lad() { $.zyg[0].lad }
}
class RxOp::ListPrim is RxOp {
    has Str $.name; # used for LTM cheatery
    has Str $.type;
    has $.ops = die "RxOp::Variable.ops required"; # Op

    method ctxopzyg() { $!ops, 1 }
    method opzyg() { $!ops }

    method code($body) {
        my $bt = self.label;

        my @code;
        push @code, CgOp.rxcall("InitCursorList",
            CgOp.rxlprim($!type, $!ops.cgop($body)));
        push @code, CgOp.label($bt);
        push @code, CgOp.rxincorpshift([], $bt);
        @code;
    }

    method lad() { $!type eq 'scalar_var' ?? ['Param', $!name] !! ['Imp'] }
}

augment class NieczaActions {
method assertion:sym<{ }> ($/) {
    $/.CURSOR.trymop({
        $<embeddedblock>.ast.add_my_name('$¢', :noinit, |mnode($/));
        $<embeddedblock>.ast.set_signature(Sig.simple('$¢'));
    });

    make ::RxOp::ListPrim.new(type => 'scalar_asn', ops => self.inliney_call($/,
        $<embeddedblock>.ast, ::Op::MakeCursor.new(|node($/))));
}

method assertion:sym<?> ($/) {
    if $<assertion> {
        make $<assertion>.reduced eq 'assertion:sym<{ }>' ??
            ::RxOp::CheckBlock.new(block => $<assertion>.ast.ops, :!negate) !!
            ::RxOp::Before.new(zyg => [self.decapturize($/)]);
    } else {
        make ::RxOp::Sequence.new;
    }
}

method assertion:sym<!> ($/) {
    if $<assertion> {
        make $<assertion>.reduced eq 'assertion:sym<{ }>' ??
            ::RxOp::CheckBlock.new(block => $<assertion>.ast.ops, :negate) !!
            ::RxOp::NotBefore.new(zyg => [self.decapturize($/)]);
    } else {
        make ::RxOp::None.new;
    }
}

method assertion:variable ($/) {
    given substr($/,0,1) {
        when '&' {
            make ::RxOp::Subrule.new(|node($/), regex =>
                ::Op::CallSub.new(|node($/), invocant => $<variable>.ast,
                    positionals => [ ::Op::MakeCursor.new(|node($/)) ]));
        }
        when '$' {
            make ::RxOp::ListPrim.new(type => 'scalar_asn',
                ops => self.rxembed($/, $<variable>.ast, True));
        }
        when '@' {
            make ::RxOp::ListPrim.new(type => 'list_asn',
                ops => self.rxembed($/, $<variable>.ast, True));
        }
        default {
            make ::RxOp::None.new;
            $/.CURSOR.sorry("Sigil $_ is not allowed for regex assertions");
        }
    }
}
method rxcapturize($M, $name, $rxop is copy) { #OK not used
    if !$rxop.^isa(::RxOp::Capturing) {
        # $<foo>=[...]
        $rxop = ::RxOp::StringCap.new(zyg => [$rxop]);
    }

    # $<foo>=(...)
    # XXX might not quite be right
    if +$rxop.captures == 1 && $rxop.captures.[0] ~~ /^\d+$/ {
        return $rxop.clone(captures => [$name]);
    }

    return $rxop.clone(captures => [ $name, @( $rxop.captures ) ]);
}
method quantified_atom($/) { # :: RxOp
    my $atom = $<atom>.ast;
    my $q    = $<quantifier> ?? $<quantifier>.ast !! Any;

    return Nil unless $atom;

    if %*RX<r> {
        # no quantifier at all?  treat it as :
        $q //= { mod => '' };
        # quantifier without explicit :? / :! gets :
        $q<mod> //= '';
    }

    if defined $q<min> {
        my @z = $atom;
        if $<separator> {
            if $q<sep>:exists {
                $/.CURSOR.sorry("Cannot use two separators in one quantified_atom");
            }
            for %( $<separator>.ast ) { $q{.key} = .value }
        }
        push @z, $q<sep> if defined $q<sep>;
        # parsing quirk, x #`(1) ** #`(2) y, the 1* position is counted
        # as $<normspace> but the 2* is parsed by the quantifier
        if ($q<general> || @z[1]) && %*RX<s> && ($q<space> || $<normspace>) {
            if @z[1] {
                @z[1] = ::RxOp::Sequence.new(zyg => [
                    ::RxOp::Sigspace.new, @z[1], ::RxOp::Sigspace.new]);
            } else {
                push @z, ::RxOp::Sigspace.new;
            }
        }
        $atom = ::RxOp::Quantifier.new(min => $q<min>, max => $q<max>,
            nonlisty => $q<nonlisty>, closure => $q<closure>,
            opsep => $q<opsep>, zyg => [@z],
            minimal => ($q<mod> && $q<mod> eq '?'));
    }

    if defined($q<mod>) && $q<mod> eq '' {
        $atom = ::RxOp::Cut.new(zyg => [$atom]);
    }

    if defined $q<tilde> {
        my ($closer, $inner) = @( $q<tilde> );
        $closer = $closer.zyg[0] if $closer.^isa(::RxOp::Cut) &&
            $closer.zyg[0].^isa(::RxOp::String);
        if !$closer.^isa(::RxOp::String) {
            $/.CURSOR.sorry("Non-literal closers for ~ NYI");
            make ::RxOp::None.new;
            return;
        }
        $atom = ::RxOp::Sequence.new(zyg => [$atom,
            ::RxOp::Tilde.new(closer => $closer.text, dba => %*RX<dba>,
                zyg => [$inner])]);
    }

    make $atom;
}
method op_for_regex($/, $rxop) {
    my @lift = $rxop.oplift;
    my $ltm = ::GLOBAL::OptRxSimple.run_lad($rxop.lad);
    my ($orxop, $mb) = ::GLOBAL::OptRxSimple.run($rxop);
    my $sub = self.thunk_sub(::Op::RegexBody.new(|node($/),
            canback => $mb, pre => @lift, rxop => $orxop),
        class => 'Regex', params => ['self'], :$ltm);
    $sub.add_my_name('$/');
    self.block_expr($/, $sub);
}
method metachar:var ($/) {
    sub _isnum { $_ ~~ /^\d+$/ }
    if $<binding> {
        my $a = $<binding><quantified_atom>.ast.uncut;
        my $cid = $<variable>.ast.<capid>;

        if !defined $cid {
            $/.CURSOR.sorry("Non-Match bindings NYI");
            make ::RxOp::Sequence.new;
            return Nil;
        }

        if $a.^isa(::RxOp::VoidBlock) {
            make ::RxOp::SaveValue.new(capid => $cid, block => $a.block);
            return Nil;
        }

        if _isnum($cid) {
            %*RX<paren> = $cid + 1;
        }

        make self.rxcapturize($/, $cid, $a);
        return;
    }

    my $kind = 'scalar_var';
    given substr($<variable>,0,1) {
        when '$' { $kind = 'scalar_var'; }
        when '@' { $kind = 'list_var'; }
        default  {
            $/.CURSOR.sorry('Only $ and @ variables may be used in regexes for now');
        }
    }
    make ::RxOp::ListPrim.new(name => ~$<variable>, type => $kind,
        ops => self.rxembed($/,
            self.do_variable_reference($/, $<variable>.ast), True));
}
method circumfix:sigil ($/) {
    # XXX duplicates logic in variable
    if $<semilist>.ast.elems == 0 {
        if $<sigil> eq '$' {
            make ::Op::ShortCircuit.new(|node($/), kind => '//',
                args => [ ::Op::CallMethod.new(name => 'ast',
                            receiver => mklex($/, '$/')),
                          ::Op::CallMethod.new(name => 'Str',
                            receiver => mklex($/, '$/')) ] );
        } elsif $<sigil> eq any < @ % > {
            make self.docontext($/, ~$<sigil>, mklex($/, '$/'));
        } else {
            make mklex($/, 'Mu');
            $/.CURSOR.sorry("Missing argument for contextualizer");
        }
        return;
    }
    self.circumfix:sym<( )>($/);
    make self.docontext($/, ~$<sigil>, $/.ast);
}

method variable($/) {
    my $sigil =  $<sigil>  ?? ~$<sigil> !! substr(~$/, 0, 1);
    my $twigil = $<twigil> ?? $<twigil>[0]<sym> !! '';

    my ($name, $pkg);
    my ($dsosl) = $<desigilname> ?? $<desigilname>.ast !!
        $<sublongname> ?? $<sublongname>.ast !!
        $<longname> ?? self.process_name($<longname>, :defer) !!
        Any;
    if defined($dsosl<ind>) {
        make { term => self.docontext($/, $sigil, $dsosl<ind>) };
        return;
    } elsif defined($dsosl<iname>) {
        make { term => ::Op::IndirectVar.new(|node($/),
            name => mkstringycat($/, $sigil ~ $twigil, $dsosl<iname>)) };
        return;
    } elsif defined $dsosl {
        ($name, $pkg) = $dsosl<name pkg>;
    } elsif $<infixish> {
        make { term => $<infixish>.ast.as_function($/) };
        return;
    } elsif $<special_variable> {
        $name = substr(~$<special_variable>, 1);
    } elsif $<index> {
        make { capid => $<index>.ast, term =>
            mkcall($/, '&postcircumfix:<[ ]>',
                ::Op::Lexical.new(name => '$/'),
                ::Op::Num.new(value => $<index>.ast))
        };
        return Nil;
    } elsif $<postcircumfix> {
        if $<postcircumfix>[0].reduced eq 'postcircumfix:sym<< >>' { #XXX fiddly
            make { capid => $<postcircumfix>[0].ast.args[0].text, term =>
                mkcall($/, '&postcircumfix:<{ }>',
                    ::Op::Lexical.new(name => '$/'),
                    @( $<postcircumfix>[0].ast.args))
            };
            return;
        } else {
            if $<postcircumfix>[0].ast.args[0] -> $arg {
                make { term => self.docontext($/, $sigil, $arg) };
            } elsif $sigil eq '$' {
                make { term => ::Op::ShortCircuit.new(|node($/), kind => '//',
                    args => [ ::Op::CallMethod.new(name => 'ast',
                                receiver => mklex($/, '$/')),
                              ::Op::CallMethod.new(name => 'Str',
                                receiver => mklex($/, '$/')) ] ) };
            } elsif $sigil eq any < @ % > {
                make { term => self.docontext($/, $sigil, mklex($/, '$/')) };
            } else {
                make { term => mklex($/, 'Mu') };
                $/.CURSOR.sorry("Missing argument for contextualizer");
            }
            return;
        }
    } else {
        $name = '';
    }

    make {
        sigil => $sigil, twigil => $twigil, name => $name, pkg => $pkg
    };
}
}

augment class RxOp::Quantifier {
    method lad() {
        return [ 'Imp' ] if $!minimal || $!closure;

        my $mode = 0;
        $mode += 1 if $!min <= 0;
        $mode += 2 if ($!max // Inf) > 1;
        $mode += 4 if $!opsep;

        [ 'Quant', $mode, map *.lad, @.zyg ];
    }
}

CgOp._register_ops: < who sc_root sc_indir temporize _addmethod _invalidate
    rxlprim
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (dotnet)
   -L --language=NAME        # select your setting
   -I --include=DIR          # add a directory to search for modules
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp);
}
else {
    my $*repl_outer;
    my $*repl_outer_frame;
    $c.compile_string('$PROCESS::OUTPUT_USED ::= True', !$comp, :repl,
        :evalmode);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, :repl, :evalmode,
                :outer($*repl_outer), :outer_frame($*repl_outer_frame));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
