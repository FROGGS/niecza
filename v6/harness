use Metamodel;
use Op;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use NieczaActions;
use Metamodel;
use CClass;
use Sig;
use OptRxSimple;

augment class Metamodel::Namespace {
}
augment class NieczaActions {
sub node($M) { { file => $*FILE<name>, line => $M.cursor.lineof($M.to) } }
method regex_infix:sym<|> ($ ) {}
method regex_infix:sym<||> ($ ) {}
method regex_infix:sym<&> ($ ) {}
method regex_infix:sym<&&> ($ ) {}
method do_variable_reference($M, $v) {
    if $v<term> {
        return $v<term>;
    }

    my $tw = $v<twigil>;
    my $sl = $v<sigil> ~ $tw ~ $v<name>;

    if defined($v<rest>) && $tw ~~ /<[*=~?^:]>/ {
        $M.CURSOR.sorry("Twigil $tw cannot be used with qualified names");
        return ::Op::StatementList.new;
    }

    if $tw eq '!' {
        ::Op::CallMethod.new(|node($M), name => $v<name>, private => True,
            receiver => ::Op::Lexical.new(name => 'self'), ppath => $v<rest>);
    }
    elsif $tw eq '.' {
        if defined $v<rest> {
            $M.CURSOR.sorry('$.Foo::bar syntax NYI');
            return ::Op::StatementList.new;
        }

        ::Op::CallMethod.new(|node($M), name => $v<name>,
            receiver => ::Op::Lexical.new(name => 'self'));
    }
    # no twigil in lex name for these
    elsif $tw eq '^' || $tw eq ':' {
        ::Op::Lexical.new(|node($M), name => $v<sigil> ~ $v<name>);
    }
    elsif $tw eq '*' {
        ::Op::ContextVar.new(|node($M), name => $sl);
    }
    elsif $tw eq '' || $tw eq '?' {
        if defined($v<rest>) {
            ::Op::PackageVar.new(path => $M<rest>, name => $sl,
                slot => self.gensym, |node($M));
        } else {
            ::Op::Lexical.new(|node($M), name => $sl);
        }
    }
    else {
        $M.CURSOR.sorry("Unhandled reference twigil $tw");
    }
}
}

# XXX mega hack.
my class Instant {
    has $.val;
    method to-posix() { $!val }
}

my class IO {
    has $.path; # Str

    method Str() { $.path }
    method IO() { self }

    method slurp() { slurp $.path }
    method spew($text) { spew $.path, $text }

    method combine(*@paths) {
        die "Sorry, paths do not form a monoid." unless @paths;
        my $acc = @paths.shift.IO;
        for @paths { $acc = $acc.append($_) }
        $acc
    }

    method f() { Q:CgOp { (box Bool (rawscall System.IO.File.Exists (obj_getstr {$!path}))) } }
    method d() { Q:CgOp { (box Bool (rawscall System.IO.Directory.Exists (obj_getstr {$!path}))) } }
    method e() { self.f || self.d }
    method relative($base) { $base.IO.append(self) }
    method append($sub) { Q:CgOp { (box Str (rawscall System.IO.Path.Combine (obj_getstr {self}) (obj_getstr {$sub}))) }.IO }
    method but-extension($ext) { Q:CgOp { (box Str (rawscall System.IO.Path.ChangeExtension (obj_getstr {self}) (obj_getstr {$ext}))) }.IO }
    method realpath() { Q:CgOp { (box Str (rawscall System.IO.Path.GetFullPath (obj_getstr {self}))) }.IO }
    method modified() { Instant.new(val => Q:CgOp { (rawscall Builtins,Kernel.GetModTime (obj_getstr {self})) }) }
}

augment class Metamodel::StaticSub {
    method find_lex($name) {
        say "Looking for $name in $.name";
        my $l = $.lexicals{$name};
        if $l {
            return $l.^isa(::Metamodel::Lexical::Alias) ??
                self.find_lex($l.to) !! $l;
        }
        return ($.outer ?? $.outer.find_lex($name) !! ::Metamodel::Lexical);
    }
}

augment class Str {
    method IO() { IO.new(path => self) }
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => ["../lib", "."],
    ),
    frontend => NieczaFrontendSTD.new(
        lang => 'CORE',
        safemode => False,
    ),
    stages => [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ],
    backend => NieczaBackendNAM.new(
        obj_dir => 'obj',
    ),
    verbose => True,
);

#$c.compile_module("SAFE");
$c.compile_module("CORE");
$c.compile_string("say 'Hello, world'", False);
