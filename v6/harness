use Metamodel;
use Op;
use Body;
use Unit;
use Begin;
use JSYNC;
use NAMOutput;
use STD;
use Stash;
use NAME;
use NieczaGrammar;
use NieczaActions;

use MONKEY_TYPING;
augment class Match {
    method CURSOR() { Q:CgOp { (ns (rawscall Builtins,Kernel.MatchToCursor (@ {self}))) } }
    method cursor() { Q:CgOp { (ns (rawscall Builtins,Kernel.MatchToCursor (@ {self}))) } }
    method reduced() { Q:CgOp { (ns (rawscall Builtins,Kernel.MatchToReduced (@ {self}))) } }
}

augment class NieczaActions {
sub node($M) { { file => $*FILE<name>, line => $M.cursor.lineof($M.to) } }
sub mkcall($/, $name, *@positionals) {
    ::Op::CallSub.new(|node($/),
        invocant => ::Op::Lexical.new(|node($/), :$name), :@positionals);
}
    method alpha($/) { }
my %_decl2class = (
    package => ::Op::PackageDef,
    class   => ::Op::ClassDef,
    module  => ::Op::ModuleDef,
    grammar => ::Op::GrammarDef,
    role    => ::Op::RoleDef,
);

method package_def ($/) {
    make ::Op::StatementList.new;
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
        return Nil;
    }
    my $scope = $*SCOPE;
    if !$<longname> {
        $scope = 'anon';
    }
    if $scope eq 'supersede' {
        $/.CURSOR.sorry('Supercede is not yet supported');
        return Nil;
    }
    if $scope eq 'has' || $scope eq 'state' {
        $/.CURSOR.sorry("Illogical scope $scope for package block");
        return Nil;
    }

    my ($name, $outervar, @augpkg);

    if $scope eq 'augment' {
        my $r = self.mangle_longname($<longname>[0]);
        $name = $r<name>;
        @augpkg = @( $r<path> // ['MY'] );
    } else {
        $name = $<longname> ??
            self.unqual_longname($<longname>[0],
                "Qualified package definitions NYI", True) !! 'ANON';
        $outervar = $scope ne 'anon' ?? $name !! self.gensym;
    }

    my $optype = %_decl2class{$*PKGDECL};
    my $blocktype = $*PKGDECL;
    my $bodyvar = self.gensym;
    # currently always install into the local stash
    my $ourpkg = ($scope eq 'our') ?? [ 'OUR::' ] !! Any;

    if $scope eq 'augment' {
        my $stmts = $<statementlist> // $<blockoid>;
        $stmts = $stmts.ast;
        my $cbody = self.sl_to_block($blocktype, $stmts, subname => "augment-" ~ ($name // 'ANON'));

        make ::Op::Augment.new(
            |node($/),
            pkg     => [@augpkg],
            name    => $name,
            bodyvar => $bodyvar,
            body    => $cbody);
    } elsif !$*DECLARAND<stub> {
        my $stmts = $<statementlist> // $<blockoid>;
        my @export;

        $stmts = ::Op::StatementList.new(children =>
            [ self.process_package_traits($/, @export, $<trait>), $stmts.ast ]);

        my $cbody = self.sl_to_block($blocktype, $stmts,
            subname => ($*PKGDECL ~ '-' ~ ($name // 'ANON')));
        make $optype.new(
            |node($/),
            signature => ($blocktype eq 'role' && $<signature> ??
                $<signature>[0].ast !! Any),
            name    => $name,
            var     => $outervar,
            exports => @export,
            bodyvar => $bodyvar,
            ourpkg  => $ourpkg,
            body    => $cbody);
    } else {
        make $optype.new(
            |node($/),
            name    => $name,
            var     => $outervar,
            ourpkg  => $ourpkg,
            stub    => True);
    }
}

method mod_internal:p6adv ($/) {
    my ($k, $v) = $<quotepair><k v>;

    if !$v.^isa(Match) {
        $/.CURSOR.sorry(":$k requires an expression argument");
        make ::RxOp::None.new;
        return Nil;
    }
    $v = $v[0].ast;

    if $k eq 'lang' {
        make ::RxOp::SetLang.new(expr => self.rxembed($/, $v, True));
    } elsif $k eq 'dba' {
        while True {
            if $v.^isa(::Op::Paren) { $v = $v.inside; redo }
            if $v.^isa(::Op::StatementList) && +$v.children == 1
                { $v = $v.children.[0]; redo }
            last;
        }
        if !$v.^isa(::Op::StringLiteral) {
            $/.CURSOR.sorry(":dba requires a literal string");
            make ::RxOp::None.new;
            return Nil;
        }
        %*RX<dba> = $v.text;
    }
}
method nibbler($/) {
    sub iscclass($cur) {
        my $*CCSTATE = '';
        my $ok = False;
        # XXX XXX
        try { $cur.ccstate(".."); $ok = True };
        $ok
    }
    if $/.CURSOR.^isa(::STD::Regex) {
        make $<EXPR>.ast;
    } elsif $/.CURSOR.^isa(::NieczaGrammar::CgOp) {
        if $*SAFEMODE {
            $/.CURSOR.sorry('Q:CgOp not allowed in safe mode');
            make ::Op::StatementList.new;
            return Nil;
        }
        make ::Op::CgOp.new(|node($/), optree => $<cgexp>.ast);
    } elsif iscclass($/) {
        make self.process_tribble($<nibbles>);
    } else {
        make self.process_nibble($/, $<nibbles>);
    }
}

method term:value ($/) { make $<value>.ast }

method term:name ($/) {
    my ($id, $path) = self.mangle_longname($<longname>).<name path>;

    if $<args> {
        $/.CURSOR.sorry("Unsupported form of term:name");
        make ::Op::StatementList.new;
        return Nil;
    }

    if defined $path {
        make ::Op::PackageVar.new(|node($/), name => $id,
            slot => self.gensym, path => $path);
    } else {
        make ::Op::Lexical.new(|node($/), name => $id);
    }

    if $<postcircumfix> {
        make mkcall($/, '&_param_role_inst', $/.ast,
            @( $<postcircumfix>[0].ast<args> ));
    }
}
my %_nowhatever = (map { ($_ => True) }, ('&infix:<,>', '&infix:<..>',
    '&infix:<...>', '&infix:<=>', '&infix:<xx>'));
method whatever_precheck($op, *@args) {
    return ([], @args) if %_nowhatever{$op};
    my @vars;
    for @args {
        my $a = $_;
        die "invalid undef here" if !$a;
        if $a.^isa(::Op::Whatever) {
            push @vars, $a.slot;
            $a = ::Op::Lexical.new(name => $a.slot);
        } elsif $a.^isa(::Op::WhateverCode) {
            push @vars, @( $a.vars );
            $a = $a.ops;
        }
    }
    $( @vars ), @args;
}

method mangle_longname($/, $clean?) {
    my @ns = @( $<name>.ast<names> );
    my $n = pop @ns;

    if !$clean {
        for @( $<colonpair> ) {
            $n ~= $_.ast<ext> // (
                $_.CURSOR.sorry("Invalid colonpair for name extension");
                "";
            )
        }
    }

    my @path = ($<name>.ast.<dc> || @ns) ?? (path => @ns) !! ();
    { name => $n, @path };
}
}

augment class Match {
    method trim_heredoc () { self } # NYI
}

augment class STD {
method lineof ($p) {
    return 1 unless defined $p;
    my $line = @*LINEMEMOS[$p];
    return $line if $line;
    $line = 1; my $pos = 0;
    my $lm = @*LINEMEMOS;
    self.orig ~~ / :r [ \n { $lm[$pos++] = $line++ } ||
                        .  { $lm[$pos++] = $line } ]* /;
    $lm[$pos++] = $line;
    return $lm[$p] // 0;
}

    our $ALL;
method lookup_dynvar($name) { Any } # NYI
method check_old_cclass($text) { } # NYI
method do_use($module,$args) {
    self.do_need($module);
    self.do_import($module,$args);
    self;
}

method do_need($mo) {
    my $module = $mo.Str;
    my $topsym;
    try { $topsym = self.sys_load_modinfo($module); }
    if !$topsym {
        self.panic("Could not load $module");
    }
    self.add_my_name($module);
    $*DECLARAND<really> = $topsym;
    self;
}

method sys_load_modinfo($module) {
    # TODO: Implement compile-on-demand.  Requires some kind of modtime API.
    from-jsync(slurp($module ~ ".syml"));
}

method load_lex($setting) {
    if $setting eq 'NULL' {
        my $id = "MY:file<NULL.pad>:line(1):pos(0)";
        my $core = Stash.new('!id' => [$id], '!file' => 'NULL.pad',
            '!line' => 1);
        return Stash.new('CORE' => $core, 'MY:file<NULL.pad>' => $core,
            'SETTING' => $core, $id => $core);
    }

    return Stash.new(%( from-jsync(slurp($setting ~ ".syml")) ));
}
}

augment class Cursor {
    our $RED    = "\e[31m";
    our $GREEN  = "\e[32m";
    our $YELLOW = "\e[33m";
    our $CLEAR  = "\e[37m";
}

my $source = slurp("RUN.pl");

my $*SETTINGNAME = 'NULL';
my @*MEMOS;
my @*LINEMEMOS;
my $*FILE = { name => "RUN.pl" };
my @*ACTIVE;
my $*HIGHWATER = 0;
my $*HIGHEXPECT = {};
my $*HIGHMESS = "";
my $*LASTSTATE = 0;
my $*IN_PANIC = 0;
my $*IN_SUPPOSE = 0;
my $*FATALS = 0;

$DEBUG::EXPR = False;
$STD::DEBUG::EXPR = False;
$STD::DEBUG::symtab = False;

my $*LAST_NIBBLE = 0;
my $*LAST_NIBBLE_START = 0;
my $*LAST_NIBBLE_MULTILINE = 0;
my $*LAST_NIBBLE_MULTILINE_START = 0;
my $*GOAL = "(eof)";
my $*UNITNAME = "CORE";
my $*SAFEMODE = False;
my $*SETTING; my $*CORE; my $*GLOBAL; my $*UNIT; my $*YOU_WERE_HERE;
my $*CCSTATE; my $*BORG; my %*RX; my $*XACT; my $*VAR; my $*IN_REDUCE;

my $ast = NieczaGrammar.parse($source, actions => NieczaActions).ast;

my %*units;
my $mm = $ast.begin;
my $nstr = NAMOutput.run($mm);

spew "../obj/RUN.nam", $nstr;
