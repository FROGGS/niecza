use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

# augment class RxOp {
# method oplift() {
#     say "oplift: {self.typename}";
#     my $i = 0;
#     map { say $i++; .oplift }, @$!zyg
# }
# }

class RxOp::Newline is RxOp {
    method code($) { CgOp.rxbprim('Newline') }
    method lad() {
        ['Any', [ ['Str', "\x0D\x0A"],
                  [ 'CC', @( $CClass::VSpace.terms ) ] ] ]
    }
}

augment class NieczaActions {
our $CCTrace = %*ENV<NIECZA_CC_TRACE> // False;

# UTS18 specifies a rule for "pulling up" negations in character classes,
# so we have to delay the negation, it seems; [0] = neg [1] = RxOp

method negate_cc($exp) { [ !$exp[0], $exp[1] ] }
method void_cc() { [False, ::RxOp::CClassElem.new(cc => $CClass::Empty)] }
method cclass_cc($cc) { [False, ::RxOp::CClassElem.new(:$cc)] }
method neg_cclass_cc($cc) { [True, ::RxOp::CClassElem.new(:$cc)] }
method string_cc($str) {
    $str.codes == 1 ?? self.cclass_cc(CClass.enum($str)) !!
        [False, ::RxOp::String.new(text => $str)];
}

# TODO: implement this more directly
method xor_cc($lhs, $rhs) {
    self.or_cc(self.and_cc($lhs, self.negate_cc($rhs)),
               self.and_cc(self.negate_cc($lhs), $rhs));
}

method and_cc($lhs, $rhs) {
    self.negate_cc(self.or_cc(self.negate_cc($lhs), self.negate_cc($rhs)));
}

method or_cc($lhs, $rhs) {
    say "or($lhs[1].typename(), $rhs[1].typename())" if $CCTrace;
    my $ccl = $lhs[1] ~~ ::RxOp::CClassElem;
    my $ccr = $rhs[1] ~~ ::RxOp::CClassElem;
    if $lhs[0] {
        if $rhs[0] {
            $ccl && $ccr ??
                self.neg_cclass_cc($lhs[1].cc.minus($rhs[1].cc.negate)) !!
                [ True, ::RxOp::Conj.new(zyg => [ $lhs[1], $rhs[1] ]) ];
        } else { # !L | R = !(L & !R)
            $ccl && $ccr ??
                self.neg_cclass_cc($lhs[1].cc.minus($rhs[1].cc)) !!
                [ True, ::RxOp::Sequence.new(zyg => [
                    ::RxOp::NotBefore.new(zyg => [ $rhs[1] ]), $lhs[1] ]) ];
        }
    } else {
        if $rhs[0] {
            self.or_cc($rhs, $lhs);
        } else {
            $ccl && $ccr ??
                self.cclass_cc($lhs[1].cc.plus($rhs[1].cc)) !!
                [ False, ::RxOp::Alt.new(dba => 'character class',
                    zyg => [$lhs[1], $rhs[1]]) ];
        }
    }
}

method cc_to_rxop($z) {
    say "do_cc $z[1].typename()" if $CCTrace;
    return $z[0] ?? ::RxOp::Sequence.new(zyg => [
        ::RxOp::NotBefore.new(zyg => [$z[1]]), ::RxOp::Any.new]) !! $z[1];
}

method assertion:sym<:> ($/) { make self.cc_to_rxop($<cclass_expr>.ast) }
method assertion:sym<[> ($/) { make self.cc_to_rxop($<cclass_expr>.ast) }
method assertion:sym<-> ($/) { make self.cc_to_rxop($<cclass_expr>.ast) }
method assertion:sym<+> ($/) { make self.cc_to_rxop($<cclass_expr>.ast) }

method cclass_expr($/) {
    my @ops = @$<op>;
    my @zyg = map *.ast, @$<cclass_union>;
    for @ops -> $op {
        my $z1 = shift @zyg;
        my $z2 = shift @zyg;
        unshift @zyg, ($op eq '^') ?? self.xor_cc($z1,$z2) !! self.or_cc($z1,$z2);
    }
    say "cclass_expr @zyg[0][1].typename()" if $CCTrace;
    make @zyg[0];
}

method cclass_union($/) {
    my ($a, @zyg) = map *.ast, @$<cclass_add>;
    for @zyg { $a = self.and_cc($a, $_) }
    say "cclass_union $a[1].typename()" if $CCTrace;
    make $a;
}

method cclass_add($/) {
    my ($a, @zyg) = map *.ast, @$<cclass_elem>;
    if $<sign> eq '-' { $a = self.negate_cc($a) }
    for @$<op> {
        $a = ($_ eq '+') ?? self.or_cc($a, shift(@zyg))
                         !! self.and_cc($a, self.negate_cc(shift(@zyg)));
    }
    say "cclass_add $a[1].typename()" if $CCTrace;
    make $a;
}

method cclass_elem:name ($/) {
    make (substr($<name>,0,10) eq 'INTERNAL::') ??
        self.cclass_cc(CClass.internal(substr($<name>,10))) !!
        [False, ::RxOp::Subrule.new(captures => [], method => ~$<name>)];

    say ":name $<name> $/.ast[1].typename()" if $CCTrace;
}

method cclass_elem:sym<[ ]> ($/) {
    make $<nibble>.ast;
    say ":[] $/.ast[1].typename()" if $CCTrace;
}

method cclass_elem:sym<( )> ($/) {
    make $<cclass_expr>.ast;
}

method cclass_elem:property ($/) {
    # $<colonpair>
    $/.CURSOR.sorry("Character property database NYI");
    make self.void_cc;
}

method cclass_elem:quote ($/) {
    if ! $<quote>.ast.^isa(::Op::StringLiteral) {
        make ::RxOp::VarString.new(ops => self.rxembed($/, $<quote>.ast, True));
        return;
    }
    if !%*RX<i> && !%*RX<a> {
        make self.string_cc($<quote>.ast.text);
        return;
    }
    make [False, ::RxOp::String.new(text => $<quote>.ast.text,
        igcase => %*RX<i>, igmark => %*RX<a>)];
}

method post_backslash($/) {
    # XXX confine $/ resetting
    sub _isupper { $_ ~~ /^<[ A .. Z ]>$/ }
    sub _islower { $_ ~~ /^<[ a .. z ]>$/ }
    if $/.ast.^isa(CClass) {
        make self.cclass_cc($/.ast);
    }
    if _isupper($/) && _islower($<sym>) {
        if $/.ast.^isa(Str) {
            make self.string_cc($/.ast);
        }
        make self.negate_cc($/.ast);
    }
}
method backslash:x ($/) {
    if $<hexint> {
        make chr($<hexint>.ast);
    } else {
        make (join "", map *.&chr, @( $<hexints>.ast ));
    }
    self.post_backslash($/);
}
method backslash:o ($/) {
    if $<octint> {
        make chr($<octint>.ast);
    } else {
        make (join "", map *.&chr, @( $<octints>.ast ));
    }
    self.post_backslash($/);
}
method backslash:sym<\\> ($/) { make ~$<text> }
method backslash:stopper ($/) { make ~$<text> }
method backslash:unspace ($/) { make "" }
method backslash:misc ($/) { make ($<text> // ~$<litchar>) }
# XXX h, v, s, needs spec clarification
method backslash:sym<0> ($/) { make "\0" }
method backslash:a ($/) { make "\a"; self.post_backslash($/) }
method backslash:b ($/) { make "\b"; self.post_backslash($/) }
method backslash:d ($/) { make $CClass::Digit; self.post_backslash($/) }
method backslash:e ($/) { make "\e"; self.post_backslash($/) }
method backslash:f ($/) { make "\f"; self.post_backslash($/) }
method backslash:h ($/) { make $CClass::HSpace; self.post_backslash($/) }
method backslash:n ($/) {
    if $/.CURSOR.can('backslash:d') {
        # HACK - only use this form when we're looking for regexy stuff
        make [False, ::RxOp::Newline.new];
        self.post_backslash($/)
    } else {
        make "\n";
    }
}
method backslash:r ($/) { make "\r"; self.post_backslash($/) }
method backslash:s ($/) { make $CClass::Space; self.post_backslash($/) }
method backslash:t ($/) { make "\t"; self.post_backslash($/) }
method backslash:v ($/) { make $CClass::VSpace; self.post_backslash($/) }
method backslash:w ($/) { make $CClass::Word; self.post_backslash($/) }
my class RangeSymbol { };
method escape:sym<..> ($/) { make RangeSymbol }
method process_tribble(@bits) {
    my @cstack;
    my @mstack;
    for @bits -> $b {
        if $b.ast.^isa(Str) {
            next if $b.ast eq "";
        }
        push @mstack, $b.CURSOR;
        push @cstack, $b.ast;
        if @cstack >= 2 && @cstack[*-2] ~~ RangeSymbol {
            if @cstack == 2 {
                @mstack[0].sorry(".. requires a left endpoint");
                return self.void_cc;
            }
            for 1, 3 -> $i {
                if (@cstack[*-$i] !~~ Str) || (@cstack[*-$i].codes != 1) {
                    @mstack[*-$i].sorry(".. endpoint must be a single character");
                    return self.void_cc;
                }
            }
            my $new = [False, ::RxOp::CClassElem.new(cc =>
                CClass.range(@cstack[*-3], @cstack[*-1]))];
            pop(@cstack); pop(@cstack); pop(@cstack); push(@cstack, $new);
            pop(@mstack); pop(@mstack);
        }
    }
    if @cstack && @cstack[*-1] ~~ RangeSymbol {
        @mstack[*-1].sorry(".. requires a right endpoint");
        return self.void_cc;
    }
    my $retcc = self.void_cc;
    for @cstack {
        $retcc = self.or_cc($retcc, ($_ ~~ Str) ?? self.string_cc($_) !! $_);
    }
    $retcc;
}
method metachar:sym<\\> ($/) {
    my $cc = $<backslash>.ast;
    make ($cc.^isa(Str) ??
        ::RxOp::String.new(text => $cc,
            igcase => %*RX<i>, igmark => %*RX<a>) !!
        self.cc_to_rxop($cc));
}
}

class Operator::Replicate is Operator {
    method as_function($/) { mklex($/, '&infix:<xx>') }
    method with_args($/, *@args) {
        mkcall($/, '&_doreplicate', ::GLOBAL::NieczaActions.block_expr($/,
            ::GLOBAL::NieczaActions.thunk_sub(@args[0])), @args[1]);
    }
}

augment grammar STD {
method explain_mystery($nested?) {
    my %post_types;
    my %unk_types;
    my %unk_routines;
    my $m = '';
    for keys(%*MYSTERY) {
        my $p = %*MYSTERY{$_}.<lex>;
        if self.is_name($_, $p) {
            # types may not be post-declared
            %post_types{$_} = %*MYSTERY{$_};
            next;
        }

        next if self.is_known($_, $p) or self.is_known('&' ~ $_, $p);

        # just a guess, but good enough to improve error reporting
        if $_ lt 'a' {
            %unk_types{$_} = %*MYSTERY{$_};
        }
        else {
            %unk_routines{$_} = %*MYSTERY{$_};
        }
    }
    if %post_types {
        my @tmp = sort keys(%post_types);
        $m ~= "Illegally post-declared type" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %post_types{$_}.<line> ~ "\n";
        }
    }
    if %unk_types {
        my @tmp = sort keys(%unk_types);
        $m ~= "Undeclared name" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %unk_types{$_}.<line> ~ "\n";
        }
    }
    if %unk_routines {
        my @tmp = sort keys(%unk_routines);
        $m ~= "Undeclared routine" ~ ('s' x (@tmp != 1)) ~ ":\n";
        for @tmp {
            $m ~= "\t'$_' used at line " ~ %unk_routines{$_}.<line> ~ "\n";
        }
    }
    self.sorry($m) if $m;

    unless $nested {
        for $*unit.stubbed_stashes -> $pos, $type {
            next if $type.closed || $type.kind eq 'package';
            self.cursor($pos).sorry("Package was stubbed but not defined");
        }
    }

    self;
}
method nibbler() {
    my @nibbles;
    my $from = self.pos;
    my $len = self.orig.chars;
    my $to = $from;

    loop {
        my $here = self.cursor($to);
        last if head($here.stopper);

        if head($here.starter) -> $starter {
            push @nibbles, Match.synthetic(:cursor(self), :$from, :$to,
                :method<Str>, :captures()) if $from != $to;

            my $nibbler = head(self.cursor($starter.to).nibbler) or return;
            my $stopper = head(self.cursor($nibbler.to).stopper) or return;

            $from = $to = $stopper.to;
            push @nibbles, $starter;
            push @nibbles, @( $nibbler<nibbles> );
            push @nibbles, $stopper;
        }
        elsif head($here.escape) -> $escape {
            push @nibbles, Match.synthetic(:cursor(self), :$from, :$to,
                :method<Str>, :captures()) if $from != $to;

            $from = $to = $escape.to;
            push @nibbles, $escape;
        }
        elsif $to < $len {
            $to++;
        }
        else { # at end, and not stopper
            return;
        }
    }

    push @nibbles, Match.synthetic(:cursor(self), :$from, :$to,
        :method<Str>, :captures()) if $from != $to || !@nibbles;

    $*LAST_NIBBLE = $to;
    $*LAST_NIBBLE_START = self.pos;
    if defined substr(self.orig, self.pos, $to - self.pos).index("\n") {
        $*LAST_NIBBLE_MULTILINE = $to;
        $*LAST_NIBBLE_MULTILINE_START = self.pos;
    }

    Match.synthetic(:cursor(self), from => self.pos, :$to, :method<nibbler>,
        :captures(nibbles => @nibbles))
}
}

augment class RxOp::Sym {
    method clone(:$captures) {
        self.WHAT.new(text => $!text, igcase => $!igcase, igmark => $!igmark,
            endsym => $!endsym, :$captures);
    }
}

augment class NieczaActions {
method infix:sym<xx> ($/) { make ::Operator::Replicate.new }
method statement_prefix:BEGIN ($/) {
    # MAJOR HACK - allows test code like BEGIN { @*INC.push: ... } to work
    repeat while False {
        my $c = ($<blast><statement> || $<blast><block><blockoid>).ast;

        last unless $c ~~ Op::StatementList;
        last unless $c.children == 1;
        my $d = $c.children.[0];
        last unless $d ~~ Op::CallMethod;
        last unless $d.receiver ~~ Op::ContextVar;
        last unless $d.receiver.name eq '@*INC';
        last if $d.private || $d.ismeta;
        last unless $d.name eq any <push unshift>;
        last unless +$d.getargs == 1;
        last unless defined my $str = self.trivial_eval($/, $d.getargs.[0]);
        @*INC."$d.name()"($str);
        make ::Op::StatementList.new;
        return;
    }

    $*CURLEX<!sub>.create_static_pad;
    my $con = self.make_constant($/, 'anon', 'BEGIN');
    $<blast>.ast.run_BEGIN($con.name);
    $con.init = True;
    make $con;
}
method init_constant($con, $rhs) {
    my $body = self.thunk_sub($rhs, name => "$con.name() init");
    $body.outer.create_static_pad;
    $body.run_BEGIN($con.name);
    $con.init = True;
    $con;
}
method blockoid($/) {
    # XXX horrible cheat, but my data structures aren't up to the task of
    # $::UNIT being a class body &c.
    if $/ eq '{YOU_ARE_HERE}' {
        $*unit.set_bottom($*CURLEX<!sub>);
        $*CURLEX<!sub>.create_static_pad;
        $*CURLEX<!sub>.noninlinable;

        loop (my $l = $*CURLEX<!sub>; $l; $l.=outer) {
            # this isn't *quite* right, as it will cause declaring
            # anything more in the same scope to fail.
            # ... and we have to be careful not to mark anon_0 used
            # or installing this very block will fail!
            substr($_,0,4) ne 'anon' and $/.CURSOR.mark_used($_)
                for $l.lex_names;
        }

        make ::Op::YouAreHere.new(|node($/), unitname => $*UNITNAME);
    } else {
        make $<statementlist>.ast;
    }
}
}

CgOp._register_ops: < who sc_root sc_indir temporize _addmethod _invalidate
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (dotnet)
   -L --language=NAME        # select your setting
   -I --include=DIR          # add a directory to search for modules
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp);
}
else {
    my $*repl_outer;
    my $*repl_outer_frame;
    $c.compile_string('$PROCESS::OUTPUT_USED ::= True', !$comp, :repl,
        :evalmode);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, :repl, :evalmode,
                :outer($*repl_outer), :outer_frame($*repl_outer_frame));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
