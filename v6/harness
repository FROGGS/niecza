use Metamodel;
use Op;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use CgOp;
use NieczaActions;
use Metamodel;
use CClass;
use Sig;
use OptRxSimple;
use RxOp;
use STD;

augment class RxOp {
method check()  { for @$!zyg { $_.check } }
method used_caps() {
    # XXX Hash.push
    my %r;
    for @$!zyg -> $k {
        for $k.used_caps.pairs -> $p {
            %r{$p.key} = (%r{$p.key} // 0) + $p.value;
        }
    }
    %r;
}
}

augment class Op::Lexical { #OK exist
    method code_bvalue($ , $ro, $rhscg) {
        CgOp.prog(
            CgOp.scopedlex($.name, CgOp.newboundvar(+?$ro, +(?($.list || $.hash)), $rhscg)),
            CgOp.scopedlex($.name));
    }
}

augment class Op::PackageVar { #OK exist
    method code_bvalue($ , $ro, $rhscg) {
        CgOp.prog(
            CgOp.scopedlex($.slot,
                CgOp.newboundvar(+?$ro, +(?($.list || $.hash)), $rhscg)),
            CgOp.scopedlex($.slot));
    }
}

augment class RxOp::Capturing { #OK exist
    method check() {
        for @$.captures -> $c is rw {
            if !defined($c) {
                $c = $*paren++;
            } elsif $c ~~ /^<[ 0..9 ]>+$/ {
                $*paren = $c + 1;
            }
        }
        for @$.zyg { $_.check }
    }
}

augment class STD {
method is_name ($n, $curlex = $*CURLEX) {
    my $name = $n;
    self.deb("is_name $name") if $DEBUG::symtab;

    my $curpkg = $*CURPKG;
    return True if $name ~~ /\:\:\(/;
    my @components = self.canonicalize_name($name);
    if +@components > 1 {
        return True if @components[0] eq 'COMPILING::';
        return True if @components[0] eq 'CALLER::';
        return True if @components[0] eq 'CONTEXT::';
        if $curpkg = self.find_top_pkg(@components[0]) {
            self.deb("Found lexical package ", @components[0]) if $DEBUG::symtab;
            shift @components;
        }
        else {
            self.deb("Looking for GLOBAL::<$name>") if $DEBUG::symtab;
            $curpkg = $*GLOBAL;
        }
        while +@components > 1 {
            my $pkg = shift @components;
            $curpkg = $curpkg.{$pkg};
            return False unless defined $curpkg;
            if $curpkg ~~ List {
                my $outlexid = $curpkg.[0] // return False;
                $curpkg = $STD::ALL.{$outlexid} // return False;
            }
            self.deb("Found $pkg okay") if $DEBUG::symtab;
        }
    }
    $name = shift(@components)//'';
    self.deb("Looking for $name") if $DEBUG::symtab;
    return True if $name eq '';
    my $lex = $curlex;
    while $lex {
        self.deb("Looking in ", $lex.id) if $DEBUG::symtab;
        if $lex.{$name} {
            self.deb("Found $name in ", $lex.id) if $DEBUG::symtab;
            $lex.{$name}<used> = 1;
            return True;
        }
        my $oid = $lex.<OUTER::>[0] || last;
        $lex = $STD::ALL.{$oid};
    }
    return True if $curpkg.{$name};
    return True if $*GLOBAL.{$name};
    self.deb("$name not found") if $DEBUG::symtab;
    return False;
}
}

augment class CClass {
sub infix:<+&>($x, $y) { Q:CgOp { (rawscall Builtins,Kernel.NumAnd {$x} {$y}) } }
sub prefix:<< +^ >>($x) { Q:CgOp { (rawscall Builtins,Kernel.NumCompl {$x}) } }
sub _binop($func, $alr, $blr) {
    my $bl = ($blr ~~ CClass) ?? $blr.terms !! CClass.range($blr, $blr).terms;
    my $al = $alr.terms;
    my ($alix, $alcur) = (0, 0);
    my ($blix, $blcur) = (0, 0);
    my @o;
    my $pos = 0;
    my $ocur = $func(0, 0);
    if $ocur != 0 {
        push @o, 0, $ocur;
    }

    while $pos != 10_000_000 {
        my $ata = $alix < @$al && $al[$alix] == $pos;
        my $atb = $blix < @$bl && $bl[$blix] == $pos;

        if $ata {
            $alcur = $al[$alix+1];
            $alix = $alix + 2;
        }

        if $atb {
            $blcur = $bl[$blix+1];
            $blix = $blix + 2;
        }

        my $onew = $func($alcur, $blcur);
        if $onew != $ocur {
            push @o, $pos, $onew;
            $ocur = $onew;
        }

        my $toa = $alix < @$al ?? $al[$alix] !! 10_000_000;
        my $tob = $blix < @$bl ?? $bl[$blix] !! 10_000_000;

        $pos = $toa < $tob ?? $toa !! $tob;
    }

    CClass.new(terms => @o);
}
method minus($other) { _binop({ $^a +& +^$^b }, self, $other); }
}

augment class Metamodel::ParametricRole { #OK exist
    method add_method($kind, $name, $var, $body) { #OK not used
        push $.methods, ::Metamodel::Method.new(:$name, :$body, :$var, :$kind);
    }
}

augment class NieczaActions {
sub node($M) { { line => $M.cursor.lineof($M.to) } }

sub mkcall($/, $name, *@positionals) {
    ::Op::CallSub.new(|node($/),
        invocant => ::Op::Lexical.new(|node($/), :$name), :@positionals);
}
my %_nowhatever = (map { ($_ => True) }, ('&infix:<,>', '&infix:<..>',
    '&infix:<...>', '&infix:<=>', '&infix:<xx>'));
method whatever_precheck($op, *@args) {
    return ([], @args) if %_nowhatever{$op};
    my @vars;
    my @args_ = @args;
    for @args_ -> $a is rw {
        die "invalid undef here" if !$a;
        if $a.^isa(::Op::Whatever) {
            push @vars, $a.slot;
            $a = ::Op::Lexical.new(name => $a.slot);
        } elsif $a.^isa(::Op::WhateverCode) {
            push @vars, @( $a.vars );
            $a = $a.ops;
        }
    }
    $( @vars ), @args_;
}
my %loose2tight = (
    '&&' => '&&', '||' => '||', '//' => '//', 'andthen' => 'andthen',
    'orelse' => '//', 'and' => '&&', 'or' => '||',
);

sub _isinfix($out is rw, $str) {
    $str ~~ /'&infix:<'(.*)'>'/ && ($out = $0; True)
}

method INFIX($/) {
    my $fn = $<infix>.ast;
    my $s = $fn.^isa(::Op::Lexical) ?? $fn.name !!
        ($fn.^isa(::Op::CallSub) && $fn.invocant.^isa(::Op::Lexical)) ??
            $fn.invocant.name !! '';
    my ($st,$lhs,$rhs) = self.whatever_precheck($s, $<left>.ast, $<right>.ast);
    my $n;

    if $s eq '&infix:<?? !!>' { # XXX macro
        make ::Op::Conditional.new(|node($/), check => $lhs,
            true => $<infix><infix><EXPR>.ast, false => $rhs);
    } elsif $s eq '&infix:<:=>' {
        make ::Op::Bind.new(|node($/), :!readonly, :$lhs, :$rhs);
    } elsif $s eq '&infix:<::=>' {
        make ::Op::Bind.new(|node($/), :readonly, :$lhs, :$rhs);
    } elsif $s eq '&infix:<,>' {
        #XXX STD buglet causes , in setting to be parsed as left assoc
        my @r;
        push @r, $lhs.^isa(::Op::SimpleParcel) ?? @( $lhs.items ) !! $lhs;
        push @r, $rhs.^isa(::Op::SimpleParcel) ?? @( $rhs.items ) !! $rhs;
        make ::Op::SimpleParcel.new(|node($/), items => @r);
    } elsif $s eq '&assignop' && $fn.positionals[0].^isa(::Op::Lexical) &&
            _isinfix($n, $fn.positionals[0].name) && %loose2tight{$n} {
        make ::Op::ShortCircuitAssign.new(|node($/),
            kind => %loose2tight{$n}, :$lhs, :$rhs);
    } else {
        make ::Op::CallSub.new(|node($/), invocant => $fn,
            positionals => [ $lhs, $rhs ]);

        if $s eq '&infix:<=>' {
            # Assignments to has and state declarators are rewritten into
            # an appropriate phaser
            if $lhs.^isa(::Op::Lexical) && $lhs.state_decl {
                my $cv = self.gensym;
                make ::Op::StatementList.new(|node($/), children => [
                    ::Op::Start.new(condvar => $cv, body => $/.ast),
                    ::Op::Lexical.new(name => $lhs.name)]);
            }
            elsif $lhs.^isa(::Op::Attribute) && !$lhs.initializer {
                $lhs.initializer = self.sl_to_block('bare', $rhs,
                    subname => $lhs.name ~ " init");
                make $lhs;
            }
            elsif $lhs.^isa(::Op::ConstantDecl) && !$lhs.init {
                $lhs.init = $rhs;
                make $lhs;
            }
        }
    }
    make self.whatever_postcheck($/, $st, $/.ast);
}
method get_op_sym($M) {
    if $M.reduced eq '::($name)' { # XXX STD miscompilation
        return ~$M;
    } elsif $M.reduced ~~ /\:sym\<(.*)\>/ {
        return ~$0;
    } elsif $M.reduced ~~ /\:(\w+)/ {
        return ~$0;
    } elsif $M.reduced eq 'PRE' {
        return self.get_op_sym($M<prefix>); # TODO: replace with better metaop
    } else {
        die "Cannot extract operator symbol ($M) ($M.reduced())";
    }
}
method encapsulate_regex($/, $rxop, :$goal, :$passcut = False,
        :$passcap = False) {
    my @lift = $rxop.oplift;
    my $lad = $rxop.lad;
    my ($nrxop, $mb) = OptRxSimple.run($rxop);
    # XXX do this in the signature so it won't be affected by transparent
    my @parm = ::Sig::Parameter.new(slot => 'self', name => 'self', readonly => True);
    if defined $goal {
        push @parm, ::Sig::Parameter.new(slot => '$*GOAL', name => '$*GOAL',
            readonly => True, positional => False, optional => True);
        unshift @lift, ::Op::Bind.new(|node($/), readonly => True,
            lhs => ::Op::Lexical.new(name => '$*GOAL'),
            rhs => ::Op::StringLiteral.new(text => $goal));
    }
    my $subop = self.transparent($/,
        ::Op::RegexBody.new(canback => $mb, pre => @lift, :$passcut, :$passcap,
            rxop => $nrxop), ltm => $lad, class => 'Regex', type => 'regex',
        sig => Sig.new(params => @parm));
    $subop = ::Op::CallSub.new(|node($/), invocant => $subop,
        positionals => [ ::Op::MakeCursor.new(|node($/)) ]);
    ::RxOp::Subrule.new(regex => $subop, :$passcap, _passcapzyg => $nrxop,
        _passcapltm => $lad);
}
method mod_internal:p6adv ($/) {
    my ($k, $v) = $<quotepair><k v>;

    if !$v.^isa(List) {
        $/.CURSOR.sorry(":$k requires an expression argument");
        make ::RxOp::None.new;
        return Nil;
    }
    $v = $v[0].ast;

    if $k eq 'lang' {
        make ::RxOp::SetLang.new(expr => self.rxembed($/, $v, True));
    } elsif $k eq 'dba' {
        while True {
            if $v.^isa(::Op::Paren) { $v = $v.inside; redo }
            if $v.^isa(::Op::StatementList) && +$v.children == 1
                { $v = $v.children.[0]; redo }
            last;
        }
        if !$v.^isa(::Op::StringLiteral) {
            $/.CURSOR.sorry(":dba requires a literal string");
            make ::RxOp::None.new;
            return Nil;
        }
        %*RX<dba> = $v.text;
    }
}
method variable($/) {
    my $sigil =  $<sigil>  ?? ~$<sigil> !! substr(~$/, 0, 1);
    my $twigil = $<twigil> ?? $<twigil>[0]<sym> !! '';

    my ($name, $rest);
    my $dsosl = $<desigilname> ?? $<desigilname>.ast !!
        $<sublongname> ?? $<sublongname>.ast !!
        Any;
    if defined($dsosl) && defined($dsosl<ind>) {
        make { term => self.docontext($/, $sigil, $dsosl<ind>) };
        return Nil;
    } elsif defined $dsosl {
        ($name, $rest) = $dsosl<name path>;
    } elsif $<name> {
        # Both these cases are marked XXX in STD.  I agree.  What are they for?
        if $<name>[0].ast<dc> {
            $/.CURSOR.sorry("*ONE* pair of leading colons SHALL BE ENOUGH");
            make { term => ::Op::StatementList.new };
            return Nil;
        }
        if substr(~$/,0,3) eq '$::' {
            $rest = $<name>[0].ast.<names>;
            $name = pop $rest;
        } else {
            if $<name>[0].ast<names> > 1 {
                $/.CURSOR.sorry("Nonsensical attempt to qualify a self-declared named parameter detected");
                make { term => ::Op::StatementList.new };
                return Nil;
            }
            $name = $<name>[0].ast<names>[0];
            $twigil = ':';
        }
    } elsif $<special_variable> {
        $name = substr(~$<special_variable>, 1);
        $twigil = '*' if $name eq '/' or $name eq '!';
    } elsif $<index> {
        make { capid => $<index>.ast, term =>
            ::Op::CallMethod.new(|node($/), name => 'at-pos',
                receiver => ::Op::ContextVar.new(name => '$*/'),
                positionals => [ ::Op::Num.new(value => $<index>.ast) ])
        };
        return Nil;
    } elsif $<postcircumfix> {
        if $<postcircumfix>[0].reduced eq 'postcircumfix:sym<< >>' { #XXX fiddly
            make { capid => $<postcircumfix>[0].ast<args>[0].text, term =>
                ::Op::CallMethod.new(|node($/), name => 'at-key',
                    receiver    => ::Op::ContextVar.new(name => '$*/'),
                    positionals => $<postcircumfix>[0].ast<args>)
            };
            return Nil;
        } else {
            $/.CURSOR.sorry("Contextualizer variables NYI");
            make { term => ::Op::StatementList.new };
            return Nil;
        }
    } else {
        $/.CURSOR.sorry("Non-simple variables NYI");
        make { term => ::Op::StatementList.new };
        return Nil;
    }

    make {
        sigil => $sigil, twigil => $twigil, name => $name, rest => $rest
    };
}
method regex_block($/) {
    if $<onlystar> {
        return Nil;
    }
    if $<quotepair> {
        $/.CURSOR.sorry('Regex adverbs NYI');
    }
    make $<nibble>.ast;
}
method process_tribble(@bits) {
    my @cstack;
    my @mstack;
    for @bits -> $b {
        if $b.ast.^isa(Str) {
            next if $b.ast eq "";
            if chars($b.ast) > 1 {
                $b.CURSOR.sorry("Cannot use >1 character strings as cclass elements");
                return $CClass::Empty;
            }
        }
        push @mstack, $b.CURSOR;
        push @cstack, $b.ast;
        if @cstack >= 2 && @cstack[*-2].typename eq 'RangeSymbol' {
            if @cstack == 2 {
                @mstack[0].sorry(".. requires a left endpoint");
                return $CClass::Empty;
            }
            for 1, 3 -> $i {
                if @cstack[*-$i] !~~ Str {
                    @mstack[*-$i].sorry(".. endpoint must be a single character");
                    return $CClass::Empty;
                }
            }
            my $new = CClass.range(@cstack[*-3], @cstack[*-1]);
            pop(@cstack); pop(@cstack); pop(@cstack); push(@cstack, $new);
            pop(@mstack); pop(@mstack);
        }
    }
    if @cstack && @cstack[*-1].typename eq 'RangeSymbol' {
        @mstack[*-1].sorry(".. requires a right endpoint");
        return $CClass::Empty;
    }
    my $ret = $CClass::Empty;
    for @cstack { $ret = $ret.plus($_) }
    $ret;
}
method quantifier:sym<**> ($/) {
    # XXX can't handle normspace well since it's not labelled 1*/2*
    my $h =
        $1 ?? { min => +~$0, max => +~$1[0] } !!
        ($0 && defined($/.index('..'))) ?? { min => +~$0 } !!
        $0 ?? { min => +~$0, max => +~$0 } !!
        $<embeddedblock> ?? { min => 0, cond => $<embeddedblock>.ast } !!
        { min => 1, sep => $<quantified_atom>.ast };
    $h<mod> = $<quantmod>.ast;
    make $h;
}
method nibbler($/) {
    sub iscclass($cur) {
        my $*CCSTATE = '';
        my $ok = False;
        # XXX XXX
        try { $cur.ccstate(".."); $ok = True };
        $ok
    }
    if $/.CURSOR.^isa(::STD::Regex) {
        make $<EXPR>.ast;
    } elsif $/.CURSOR.^isa(::NieczaGrammar::CgOp) {
        if $*SAFEMODE {
            $/.CURSOR.sorry('Q:CgOp not allowed in safe mode');
            make ::Op::StatementList.new;
            return Nil;
        }
        make ::Op::CgOp.new(|node($/), optree => $<cgexp>.ast);
    } elsif iscclass($/.CURSOR) {
        make self.process_tribble($<nibbles>);
    } else {
        make self.process_nibble($/, $<nibbles>);
    }
}
sub qpvalue($ast) {
    if $ast.^isa(::Op::SimpleParcel) {
        join " ", map &qpvalue, @( $ast.items )
    } elsif $ast.^isa(::Op::StringLiteral) {
        $ast.text;
    } else {
        "XXX"
    }
}
method colonpair($/) {
    my $n;
    if !$<v>.^isa(Match) {
        $n = ":" ~ ($<v> ?? '' !! '!') ~ $<k>;
    } else {
        $n = ":" ~ $<k> ~ "<" ~ qpvalue($<v>.ast) ~ ">";
    }
    my $tv = $<v>.^isa(Match) ?? $<v>.ast !!
        ::Op::Lexical.new(name => $<v> ?? 'True' !! 'False');

    if $tv ~~ Str {
        if substr($<v>,1,1) eq '<' {
            $tv = ::Op::CallMethod.new(name => 'at-key',
                receiver => ::Op::ContextVar.new(name => '$*/'),
                args => [::Op::StringLiteral.new(text => ~$<k>)]);
        } else {
            $tv = self.do_variable_reference($/,
                { sigil => ~$<v><sigil>,
                    twigil => ($<v><twigil> ?? ~$<v><twigil>[0] !! ''),
                    name => $<k> });
        }
    }

    make { ext => $n, term => ::Op::SimplePair.new(key => $<k>, value => $tv) };
}
method POSTFIX($/) {
    my ($st, $arg) = self.whatever_precheck('', $<arg>.ast);
    if $<op><colonpair> {
        if $arg.^isa(::Op::CallLike) {
            make $arg.adverb($<op><colonpair>.ast<term>);
            make self.whatever_postcheck($/, $st, $/.ast);
        } else {
            $/.CURSOR.sorry("You can't adverb that");
            make ::Op::StatementList.new;
        }
        return Nil;
    }
    my $op = $<op>.ast;
    if $op<postfix> {
        make mkcall($/, "\&postfix:<{$op<postfix>}>", $arg);
    } elsif $op<postcircumfix> {
        make mkcall($/, "\&postcircumfix:<{$op<postcircumfix>}>", $arg,
            @( $op<args> ));
    } elsif $op<name> && ($op<name> eq 'HOW' || $op<name> eq 'WHAT') {
        if $op<args> {
            $/.CURSOR.sorry("Interrogative operator {$op<name>} does not take arguments");
            make ::Op::StatementList.new;
            return Nil;
        }
        make ::Op::Interrogative.new(|node($/), receiver => $arg,
            name => $op<name>);
    } elsif $op<metamethod> {
        make ::Op::CallMethod.new(|node($/),
            receiver => $arg,
            ismeta => True,
            name => $op<metamethod>,
            args => $op<args> // []);
    } elsif $op<name> {
        if $op<path> && !$op<private> {
            $/.CURSOR.sorry("Qualified references to non-private methods NYI");
        }
        make ::Op::CallMethod.new(|node($/),
            receiver => $arg,
            private  => $op<private>,
            ppath    => $op<path>,
            name     => $op<name>,
            args     => $op<args> // []);
    } elsif $op<quote> {
        make ::Op::CallMethod.new(|node($/),
            receiver => $arg,
            private  => $op<private>,
            name     => $op<quote>,
            args     => $op<args> // []);
    } elsif $op<ref> { # $obj.&foo
        make ::Op::CallSub.new(|node($/),
            invocant => $op<ref>,
            args     => [ $arg, @( $op<args> // [] ) ]);
    } elsif $op<postcall> {
        if $op<postcall> > 1 {
            $/.CURSOR.sorry("Slicels NYI");
            make ::Op::StatementList.new;
            return Nil;
        }
        make ::Op::CallSub.new(|node($/),
            invocant => $arg,
            args => ($op<postcall>[0] // []));
    } else {
        $/.CURSOR.sorry("Unhandled postop type");
        make ::Op::StatementList.new;
    }
    make self.whatever_postcheck($/, $st, $/.ast);
}
}

augment class RxOp::Alt { #OK exist
    method rxsimp($cut) {
        my @lads = map { ::GLOBAL::OptRxSimple.run_lad($_.lad) }, @$.zyg;
        my @kids = map *.rxsimp($cut), @$.zyg;
        ::RxOp::Alt.new(
            optimized_lads => @lads,
            dba  => $.dba,
            zyg  => @kids);
    }
}

augment class Metamodel::Namespace { #OK exist
    method !lookup_common($used, @path_) {
        my $cursor = $.root;
        my @path = @path_;
        while @path > 1 {
            my $k = shift @path;
            if ($cursor{$k} && $cursor{$k}[0] eq 'graft') {
                ($cursor, $used) = self!lookup_common([], [ @($cursor{$k}[1]), '' ]);
                next;
            }

            $cursor{$k} //= ['var',Any,Any];
            if !defined $cursor{$k}[2] {
                $.log.push(['pkg',[@$used, $k]]);
                $cursor{$k}[2] = {};
            }
            $cursor = $cursor{$k}[2];
            push @$used, $k;
        }
        @($cursor, $used, @path);
    }
    method bind_item($path, $item) {
        my ($c,$u,$n) = self!lookup_common([], $path); #OK not used
        my $i = $c{$n} //= ['var',Any,Any];
        if $i[0] ne 'var' || $i[1] && $i[1][0] {
            die "Collision installing pkg $path";
        }
        $i[1] = $item;
    }
}

augment class Op::Use { #OK exist
    method begin() {
        my $name = $.unit;
        my $u2 = $*unit.need_unit($.unit);

        my @can = @( $u2.mainline.find_pkg(['MY', $name.split('::')]) );
        my @exp = (@can, 'EXPORT', 'DEFAULT');

        # XXX I am not sure how need binding should work in the :: case
        if $name !~~ /"::"/ {
            @*opensubs[*-1].lexicals{$name} =
                ::Metamodel::Lexical::Stash.new(path => @can);
        }

        for $*unit.list_stash(@exp) -> $tup {
            my $uname = $tup[0];
            my $lex;
            if $tup[1] eq 'var' {
                if $tup[2] && !$tup[2][0] {
                    $lex = ::Metamodel::Lexical::Common.new(path => @exp, name => $uname);
                } elsif $tup[2] {
                    $lex = ::Metamodel::Lexical::Stash.new(path => [@exp, $uname]);
                }
            } elsif $tup[1] eq 'graft' {
                $lex = ::Metamodel::Lexical::Stash.new(path => $tup[2]);
            } else {
                die "weird return";
            }

            @*opensubs[*-1].lexicals{$uname} = $lex;
        }
    }
}
augment class CgOp {
    method construct_lad(*@trees) { CgOp._cgop('ladconstruct', [@trees]) }
}

# XXX mega hack.
my class Instant {
    has $.val;
    method to-posix() { $!val }
}

my class IO {
    has $.path; # Str

    method Str() { $.path }
    method IO() { self }

    method slurp() { slurp $.path }
    method spew($text) { spew $.path, $text }

    method combine(*@paths) {
        die "Sorry, paths do not form a monoid." unless @paths;
        my $acc = @paths.shift.IO;
        for @paths { $acc = $acc.append($_) }
        $acc
    }

    method f() { Q:CgOp { (box Bool (rawscall System.IO.File.Exists (obj_getstr {$!path}))) } }
    method d() { Q:CgOp { (box Bool (rawscall System.IO.Directory.Exists (obj_getstr {$!path}))) } }
    method e() { self.f || self.d }
    method relative($base) { $base.IO.append(self) }
    method append($sub) { Q:CgOp { (box Str (rawscall System.IO.Path.Combine (obj_getstr {self}) (obj_getstr {$sub}))) }.IO }
    method but-extension($ext) { Q:CgOp { (box Str (rawscall System.IO.Path.ChangeExtension (obj_getstr {self}) (obj_getstr {$ext}))) }.IO }
    method realpath() { Q:CgOp { (box Str (rawscall System.IO.Path.GetFullPath (obj_getstr {self}))) }.IO }
    method modified() { Instant.new(val => Q:CgOp { (rawscall Builtins,Kernel.GetModTime (obj_getstr {self})) }) }
}

augment class Str {
    method Numeric() {
        Q:CgOp { (box Num (rawscall System.Double.Parse (obj_getstr {self}))) }
    }
    method IO() { IO.new(path => self) }
}

sub GetOptions(*@pairs, :$permute = True, :onerror($onerror_), :onarg($onarg_)) {
    my @nonopt;
    my $onerror = $onerror_ // sub ($message) {
        note $message;
        exit 1;
    };
    my $onarg = $onarg_ // sub ($arg) {
        push @nonopt, $arg;
        if !$permute {
            push @nonopt, @*ARGS;
            @*ARGS = ();
        }
    };
    my @unpk;
    sub pick_long_option($st) {
        my @cand = grep { chars($_[0]) > 1 &&
            substr($_[0],0,chars($st)) eq $st }, @unpk;
        $onerror.("Ambiguous long option --$st; could be any of {map *[0], @cand}") if @cand > 1;
        $onerror.("No match for long option --$st") if !@cand;
        @cand[0];
    }
    sub pick_short_option($st) {
        my @cand = grep { $_[0] eq $st }, @unpk;
        $onerror.("No match for short option -$st") if !@cand;
        @cand[0];
    }
    for @pairs -> $p {
        my $key = $p.key;
        my $type = '';
        if $key ~~ /<[:=]>s$/ {
            $type = ~$/;
            $key = substr($key, 0, $/.from);
        }
        for $key.split('|') {
            push @unpk, [ $_, $type, $p.value ];
        }
    }

    while @*ARGS {
        my $opt = shift @*ARGS;
        if $opt eq '--' {
            $onarg.(shift @*ARGS) while @*ARGS;
            last;
        }
        elsif substr($opt, 0, 2) eq '--' {
            if $opt ~~ /'='/ {
                my $obl = pick_long_option(substr($opt, 2, $/.from - 2));
                $onerror.("Long option --$obl[0] does not accept an argument")
                    if $obl[1] eq '';
                $obl[2].(substr($opt, $/.to));
            } else {
                my $obl = pick_long_option(substr($opt, 2));
                if $obl[1] eq '=s' {
                    $onerror.("Argument required for long option --$obl[0]")
                        unless @*ARGS;
                    $obl[2].(shift @*ARGS);
                } else {
                    $obl[2].(Str);
                }
            }
        }
        elsif chars($opt) > 1 && substr($opt, 0, 1) eq '-' {
            $opt = substr($opt, 1);
            while $opt ne '' {
                my $obl = pick_short_option(substr($opt, 0, 1));
                $opt = substr($opt, 1);
                if $obl[1] eq '' || $obl[1] eq ':s' && $opt eq '' {
                    $obl[2].(Str);
                }
                elsif $opt ne '' {
                    $obl[2].($opt);
                    $opt = '';
                }
                else {
                    $onerror.("Argument required for short option -$obl[0]")
                        unless @*ARGS;
                    $obl[2].(shift @*ARGS);
                }
            }
        }
        else {
            $onarg.($opt);
        }
    }

    @*ARGS = @nonopt;
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -B --backend=NAME         # select backend (nam, dotnet, clisp)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction, implies -L SAFE
      --help                 # display this message

backend options:
      --aot                  # run ahead-of-time compiler (mono)
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = False;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "verbose|v" => sub { $verb = True },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $safe ?? 'SAFE' !! $lang,
        safemode => $safe,
    ),
    stages => [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        $c.compile_string($l, !$comp, $stop);
    }
}
