# vim: ft=perl6
use MONKEY_TYPING;

use STD;
use Stash;
use NAME;
use JSYNC;

sub _subst($M is rw, $text is rw, $regex, $repl) {
    $text = $text.Str;
    $M = ($text ~~ $regex);
    if $M {
        $text = $text.substr(0, $M.from) ~
            (($repl ~~ Str) ?? $repl !! $repl()) ~
                $text.substr($M.to, $text.chars - $M.to);
    }
    ?$M;
}

augment class Cool {
    method lc() { Q:CgOp { (box Str (str_tolower (unbox str (@ {self.Str})))) }}
    method uc() { Q:CgOp { (box Str (str_toupper (unbox str (@ {self.Str})))) }}
}

sub lc($s) { $s.Str.lc }
sub uc($s) { $s.Str.uc }

augment class List {
}

augment class Mu {
}

augment class Cool {
}

augment class Any {
}

augment class Stash {
    method iterator () { self.list.iterator }
}

augment class NAME {
}

augment class Regex {
}

augment class Match {
    method trim_heredoc () { self } # NYI
}

augment class Hash {
}

augment class STD {
    our $ALL;
method do_use($module,$args) {
    self.do_need($module);
    self.do_import($module,$args);
    self;
}

method do_need($mo) {
    my $module = $mo.Str;
    my $topsym;
    try { $topsym = self.sys_load_modinfo($module); }
    if !$topsym {
        self.panic("Could not load $module");
    }
    self.add_my_name($module);
    $*DECLARAND<really> = $topsym;
    self;
}

method sys_load_modinfo($module) {
    # TODO: Implement compile-on-demand.  Requires some kind of modtime API.
    from-jsync(slurp($module ~ ".syml"));
}

my %term            = (:dba('term')            , :prec<z=>);
my %methodcall      = (:dba('methodcall')      , :prec<y=>, :assoc<unary>, :uassoc<left>, :fiddly, :!pure);
my %autoincrement   = (:dba('autoincrement')   , :prec<x=>, :assoc<unary>, :uassoc<non>, :!pure);
my %exponentiation  = (:dba('exponentiation')  , :prec<w=>, :assoc<right>, :pure);
my %symbolic_unary  = (:dba('symbolic unary')  , :prec<v=>, :assoc<unary>, :uassoc<left>, :pure);
my %multiplicative  = (:dba('multiplicative')  , :prec<u=>, :assoc<left>, :pure);
my %additive        = (:dba('additive')        , :prec<t=>, :assoc<left>, :pure);
my %replication     = (:dba('replication')     , :prec<s=>, :assoc<left>, :pure);
my %concatenation   = (:dba('concatenation')   , :prec<r=>, :assoc<list>, :pure);
my %junctive_and    = (:dba('junctive and')    , :prec<q=>, :assoc<list>, :pure);
my %junctive_or     = (:dba('junctive or')     , :prec<p=>, :assoc<list>, :pure);
my %named_unary     = (:dba('named unary')     , :prec<o=>, :assoc<unary>, :uassoc<left>, :pure);
my %structural      = (:dba('structural infix'), :prec<n=>, :assoc<non>, :diffy);
my %chaining        = (:dba('chaining')        , :prec<m=>, :assoc<chain>, :diffy, :iffy, :pure);
my %tight_and       = (:dba('tight and')       , :prec<l=>, :assoc<list>);
my %tight_or        = (:dba('tight or')        , :prec<k=>, :assoc<list>);
my %conditional     = (:dba('conditional')     , :prec<j=>, :assoc<right>, :fiddly);
my %item_assignment = (:dba('item assignment') , :prec<i=>, :assoc<right>, :!pure);
my %list_assignment = (:dba('list assignment') , :prec<i=>, :assoc<right>, :sub<e=>, :fiddly, :!pure);
my %loose_unary     = (:dba('loose unary')     , :prec<h=>, :assoc<unary>, :uassoc<left>, :pure);
my %comma           = (:dba('comma')           , :prec<g=>, :assoc<list>, :nextterm<nulltermish>, :fiddly, :pure);
my %list_infix      = (:dba('list infix')      , :prec<f=>, :assoc<list>, :pure);
my %list_prefix     = (:dba('list prefix')     , :prec<e=>, :assoc<unary>, :uassoc<left>);
my %loose_and       = (:dba('loose and')       , :prec<d=>, :assoc<list>);
my %loose_or        = (:dba('loose or')        , :prec<c=>, :assoc<list>);
my %sequencer       = (:dba('sequencer')       , :prec<b=>, :assoc<list>, :nextterm<statement>, :fiddly);
my %LOOSEST         = (:dba('LOOSEST')         , :prec<a=!>);
my %terminator      = (:dba('terminator')      , :prec<a=>, :assoc<list>);
role sym_categorical2[$name,$sym,$O] {
    token ::($name) () { $sym $<O>={$O} }
}
role bracket_categorical2[$name,$sym1,$sym2,$O] {
    token ::($name) () { :my $*GOAL = $sym2; $sym1 {}:s [ :lang($¢.unbalanced($sym2)) <semilist> ] [ $sym2 || <.FAILGOAL($sym2, $name, self.pos)> ] $<O>={$O} }
}
method add_categorical($name) {
    # Signature extension, not categorical
    if $name ~~ /^\w+\:\(/ {
        self.add_my_name($name);
        return self;
    }
    my $M = ($name ~~ /^(\w+)\: <?[ \< \« ]> /);
    return self unless $M;
    my $cat = $M[0];
    my $sym = substr($name, $M.to+1, $name.chars-$M.to-2);

    my $O;

    if $cat eq 'infix'            { $O = %additive }
    elsif $cat eq 'prefix'        {
        $O = ($sym ~~ /^\W/) ?? %symbolic_unary !! %named_unary
    }
    elsif $cat eq 'postfix'       { $O = %methodcall }
    elsif $cat eq 'circumfix'     { $O = %term }
    elsif $cat eq 'postcircumfix' { $O = %methodcall }
    elsif $cat eq 'term'          { $O = %term }
    else {
        self.sorry("Cannot extend category:$name with subs");
        return self;
    }

    # XXX to do this right requires .comb and .trans
    if $M = ($sym ~~ /\s+/) {
        my $sym1 = $sym.substr(0, $M.from);
        my $sym2 = $sym.substr($M.to, $sym.chars - $M.to);
        my $cname = $cat ~ ":<$sym1 $sym2>";
        %*LANG<MAIN> = self.WHAT but OUR::bracket_categorical2[$cname, $sym1, $sym2, $O];
    } else {
        my $cname = $cat ~ ":<$sym>";
        %*LANG<MAIN> = self.WHAT but OUR::sym_categorical2[$cname, $sym, $O];
    }
    self.cursor_fresh(%*LANG<MAIN>);
}
method load_lex($setting) {
    if $setting eq 'NULL' {
        my $id = "MY:file<NULL.pad>:line(1):pos(0)";
        my $core = Stash.new('!id' => [$id], '!file' => 'NULL.pad',
            '!line' => 1);
        return Stash.new('CORE' => $core, 'MY:file<NULL.pad>' => $core,
            'SETTING' => $core, $id => $core);
    }

    return Stash.new(%( from-jsync(slurp($setting ~ ".syml")) ));
}
method gettrait($traitname,$param) {
    my $text;
    my $M;
    if @$param {
        $text = $param.[0].Str;
        _subst($M, $text, /^\<(.*)\>$/, { $M[0] }) or
            _subst($M, $text, /^\((.*)\)$/, { $M[0] });
    }
    if ($traitname eq 'export') {
        if (defined $text) {
            while _subst($M, $text, /\:/, "") { }
        }
        else {
            $text = 'DEFAULT';
        }
        self.set_export($text);
        $text;
    }
    elsif (defined $text) {
        $text;
    }
    else {
        1;
    }
}
method find_stash ($n, $crlex = $*CURLEX) {
    my $name = $n;
    my $curlex = $crlex;
    self.deb("find_stash $name") if $DEBUG::symtab;

    return Any if $name ~~ /\:\:\(/;
    my @components = self.canonicalize_name($name);
    if +@components > 1 {
        return Any if @components[0] eq 'COMPILING::';
        return Any if @components[0] eq 'CALLER::';
        return Any if @components[0] eq 'CONTEXT::';
        if $curlex = self.find_top_pkg(@components[0]) {
            self.deb("Found lexical package ", @components[0]) if $DEBUG::symtab;
            shift @components;
        }
        else {
            self.deb("Looking for GLOBAL::<$name>") if $DEBUG::symtab;
            $curlex = $*GLOBAL;
        }
        while +@components > 1 {
            my $lex = shift @components;
            $curlex = $curlex.{$lex};
            return Any unless $curlex;
            try {
                my $outlexid = $curlex.[0];
                return Any unless $outlexid;
                $curlex = $ALL.{$outlexid};
                return Any unless $curlex;
            };
            self.deb("Found $lex okay") if $DEBUG::symtab;
        }
    }
    $name = shift(@components)//'';
    return $curlex if $name eq '';

    my $lex = $curlex;
    my $old;
    while $lex {
        return $old if $old = $lex.{$name};
        my $oid = $lex.<OUTER::>[0] || last;
        $lex = $ALL.{$oid};
    }
    return $old if $old = $curlex.{$name};
    return $old if $old = $*GLOBAL.{$name};
    return Any;
}
method do_import($m, $args) { #, perl6.vim stupidity
    my @imports;
    my $module = $m.Str;
    my $M;
    if $M = ($module ~~ /(class|module|role|package)\s+(\S+)/) {
        $module = $M[1];
    }

    my $pkg = self.find_stash($module);
    if $pkg<really> {
        $pkg = $pkg<really><UNIT>;
    }
    else {
        $pkg = self.find_stash($module ~ '::');
    }
    if $args {
        my $text = $args.Str;
        return self unless $text;
        while _subst($M, $text, /^\s*\:?(OUR|MY|STATE|HAS|AUGMENT|SUPERSEDE)?\<(.*?)\>\,?/, "") {
            my $scope = lc($M[0] // 'my');
            my $imports = $M[1].Str;
            my $*SCOPE = $scope;
            @imports = $imports.comb(/\S+/);
            for @imports -> $i {
                my $imp = $i;
                if $pkg {
                    if _subst($M, $imp, /^\:/, "") {
                        my @tagimports;
                        try { @tagimports = $pkg<EXPORT::>{$imp}.keys }
                        self.do_import_aliases($pkg, @tagimports);
                    }
                    elsif $pkg{$imp}<export> {
                        self.add_my_name($imp, $pkg{$imp});
                    }
                    elsif $pkg{'&'~$imp}<export> {
                        $imp = '&' ~ $imp;
                        self.add_my_name($imp, $pkg{$imp});
                    }
                    elsif $pkg{$imp} {
                        self.worry("Can't import $imp because it's not exported by $module");
                        next;
                    }
                }
                else {
                    self.add_my_name($imp);
                }
            }
        }
    }
    else {
        return self unless $pkg;
        try { @imports = $pkg<EXPORT::><DEFAULT::>.keys };
        my $*SCOPE = 'my';
        self.do_import_aliases($pkg, @imports);
    }

    self;
}
method do_import_aliases($pkg, *@names) {
#    say "attempting to import @names";
    for @names -> $n {
        next if $n ~~ /^\!/;
        next if $n ~~ /^PARENT\:\:/;
        next if $n ~~ /^OUTER\:\:/;
        self.add_my_name($n, $pkg{$n});
    }
    self;
}

}

augment class STD::P6 {
my %item_assignment = (:dba('item assignment') , :prec<i=>, :assoc<right>, :!pure);
my %term            = (:dba('term')            , :prec<z=>);
my %methodcall      = (:dba('methodcall')      , :prec<y=>, :assoc<unary>, :uassoc<left>, :fiddly, :!pure);
    token infixish ($in_meta = $*IN_META) {
        :my ($infix, $O, $sym);
        :my $*IN_META = $in_meta;
        <!stdstopper>
        <!infixstopper>
        :dba('infix or meta-infix')
        [
        | <colonpair> $<fake> = {1} { $sym = ':' }
            { $O = {:prec(%item_assignment<prec>), :assoc<unary>,
                :dba<adverb> } }
                # actual test is non-inclusive!
        |   [
            | :dba('bracketed infix') '[' ~ ']' <infix=.infixish('[]')> { $O = $<infix><O>; $sym = $<infix><sym> }
            | <infix=infix_circumfix_meta_operator> { $O = $<infix><O>; $sym = $<infix><sym>; }
            | <infix=infix_prefix_meta_operator>    { $O = $<infix><O>; $sym = $<infix><sym>; }
            | <infix>                               { $O = $<infix><O>; $sym = $<infix><sym>; }
            | {} <?dotty> <.panic: "Method call found where infix expected (omit whitespace?)">
            | {} <?postfix> <.panic: "Postfix found where infix expected (omit whitespace?)">
            ]
            [ <?before '='> <assign_meta_operator($<infix>)>
                   {$O = $<assign_meta_operator>[0]<O>}
                   {$sym = $<assign_meta_operator>[0]<sym>}
            ]?

        ]
        $<O> = { $O } $<sym> = { $sym }
    }
    token trait_mod:of {
        ['of'|'returns']:s <typename>
        [ <?{ $*DECLARAND<of> }> <.sorry("Extra 'of' type; already declared as type " ~ $*DECLARAND<of>.Str)> ]?
        { $*DECLARAND<of> = $<typename>.Str; }
    }
    token dotty:sym<.*> {
        ('.' [ <[+*?=]> | '^' '!'? ]) :: <.unspacey> <dottyop>
        $<sym> = {$0.Str}
        <O(|%methodcall)>
    }

    token dotty:sym<.> {
        <sym> <.unspacey> <dottyop>
        <O(|%methodcall)>
    }

    token privop {
        '!' <methodop>
        <O(|%methodcall)>
    }
    token term:name
    {
        :my $name;
        :my $pos;
        <longname>
        {
            $name = $<longname>.Str;
            $pos = $¢.pos;
        }
        [
        ||  <?{
                $¢.is_name($name) or substr($name,0,2) eq '::'
            }>
            { $¢.check_nodecl($name); }

            # parametric type?
            :dba('type parameter')
            <.unsp>? [ <?before '['> <postcircumfix> ]?

            :dba('namespace variable lookup')
            [
                <?after '::'>
                <?before [ '«' | '<' | '{' | '<<' ] > <postcircumfix>
                { $*VAR = Match.synthetic(:cursor($¢), :from(self.pos), :to($¢.pos), :captures(), :method<Str>) }
            ]?

        # unrecognized names are assumed to be post-declared listops.
        || <args> { self.add_mystery($<longname>,$pos,'termish') unless $<args><invocant>; }
            {{
                if $*BORG and $*BORG.<block> {
                    if not $*BORG.<name> {
                        $*BORG.<culprit> = $<longname>.cursor($pos);
                        $*BORG.<name> = $*BORG<name> // $name;
                    }
                }
            }}
        ]
        <O(|%term)>
    }
}

augment class Cursor {
    our $RED    = "\e[31m";
    our $GREEN  = "\e[32m";
    our $YELLOW = "\e[33m";
    our $CLEAR  = "\e[37m";
}

sub compiler(:$filename, :$text, :$settingname) {
    my $*SETTINGNAME = $settingname;
    my @*MEMOS;
    my $*FILE = { name => $filename };
    my @*ACTIVE;
    my $*HIGHWATER = 0;
    my $*HIGHEXPECT = {};
    my $*HIGHMESS = "";
    my $*LASTSTATE = 0;
    my $*IN_PANIC = 0;
    my $*IN_SUPPOSE = 0;
    my $*FATALS = 0;

    $STD::DEBUG::EXPR = False;
    $STD::DEBUG::symtab = False;

    my $*LAST_NIBBLE = 0;
    my $*LAST_NIBBLE_START = 0;
    my $*LAST_NIBBLE_MULTILINE = 0;
    my $*LAST_NIBBLE_MULTILINE_START = 0;
    my $*GOAL = "(eof)";
    my $*SETTING; my $*CORE; my $*GLOBAL; my $*UNIT; my $*YOU_WERE_HERE;
    my $*CCSTATE; my $*BORG; my %*RX; my $*XACT; my $*VAR; my $*IN_REDUCE;
    STD.parse($text);

    my $all;

    # setting?
    if $*YOU_WERE_HERE {
        $all = $STD::ALL;
        $all<SETTING> = $*YOU_WERE_HERE;
        $all<CORE> = $*YOU_WERE_HERE if $*UNIT<$?LONGNAME> eq 'CORE';
    }
    else {
        $all = {};
        for keys %( $STD::ALL ) -> $key {
            next if $key ~~ /^MY\:file\<\w+\.setting\>/ or $key eq 'CORE' or $key eq 'SETTING';
            $all{$key} = $STD::ALL{$key};
        }
    }

    $all
}

if !@*ARGS {
    note "Usage: tryfile.exe [--symbols]? [--setting NAME]? [-e TEXT | FILENAME | -]";
    exit 1;
}

my $symbols = False;
my $setting = 'CORE';
if @*ARGS[0] eq '--symbols' {
    $symbols = True;
    shift @*ARGS;
}
if @*ARGS[0] eq '--setting' {
    shift @*ARGS;
    $setting = shift @*ARGS;
}

my $out;
if @*ARGS[0] eq '-' {
    $out = compiler(filename => '(eval)', text => $*IN.slurp, settingname => $setting);
} elsif @*ARGS[0] eq '-e' {
    $out = compiler(filename => '(eval)', text => @*ARGS[1], settingname => $setting);
} else {
    $out = compiler(filename => @*ARGS[0], text => slurp(@*ARGS[0]), settingname => $setting);
}

if $symbols {
    say to-jsync($out);
} else {
    say "OK"
}
