# vim: ft=perl6

# XXX fakes out STD.pm6 into doing more or less the right thing
# need to understand this better
my class CORE { ... }

# We have to do this directly due to the circularity saw.  Same
# reason forces uncontainerized .NET values.
#
# ClassHOW instances are shared between lexical instantiations of a class.
#
# class ClassHOW {
#     has Array[Frame] $.outers;
#
#     # TODO
#     has Array[Sub] $.scoped-parents;
#     has Array[Sub] $.scoped-roles;
#
#     # used to stage for composition - not yet
#     has Dictionary[str,int] $.method-scopes;
#     has Dictionary[str,Sub] $.methods;
#
#     has DynProtoMetaObject $.meta-object;
# }
#
# Due to concerns of screwing up composition, adding new superclasses, roles,
# or attributes in an augment is not allowed at this time.  Methods only.
#
# to create a class:
#     BEGIN my $Foo_HOW ::= ClassHOW.new("Foo");
#     BEGIN {
#         $Foo_HOW.push-scope(callframe);
#         $Foo_HOW.add-super(...);
#         $Foo_HOW.add-role(...);
#         $Foo_HOW.add-scoped-method("bar", 0, sub { ... });
#         $Foo_HOW.compose;
#     }
#     my ::Foo will begin { $Foo_HOW.create-protoobject(callframe) }
#              will enter { $Foo_HOW.create-protoobject(callframe) };
#
# to augment:
#     BEGIN my $scopenum = $Foo_HOW.push-scope(callframe);
#     BEGIN { $Foo_HOW.add-scoped-method("baz", $scopenum, sub { ... }); }
#     Foo.^bind-outer($scopenum, callframe);
my class ClassHOW { ... }

PRE-INIT {
    # ClassHOW.new($name) --> meta class instance
    sub new { Q:CgOp {
        (prog
          (lextypes $pmo DynProtoMetaObject $self DynObject)
          (l $pmo  (rawnew DynProtoMetaObject))
          (l $self (rawnew DynObject))

          (setfield how  (l $pmo) (l $self))
          (setfield name (l $pmo) (unwrap String (@ (pos 1))))

          (setindex meta-object (getfield slots (l $self))
            (nsw (rawnew CLRImportObject (l $pmo))))
          (setfield klass (l $self) (getfield klass
            (cast DynObject (@ (pos 0)))))

          (ns (l $self)))
    } }

    # $how.push-scope($outer)
    sub push-scope { Q:CgOp {
        (prog (lextypes $df List<Frame>)
              (l $df (getfield def_outers (unwrap DynProtoMetaObject
                (getattr meta-object (@ (pos 0))))))
              (rawcall (l $df) Add (unwrap Frame (@ (pos 1))))
              (w (- (int 1) (getfield Count (l $df)))))
    } }

    # $how.add-super($how)
    sub add-super { Q:CgOp { (prog
        (rawcall
          (getfield superclasses (unwrap DynProtoMetaObject
            (getattr meta-object (@ (pos 0))))) Add
          (unwrap DynProtoMetaObject (getattr meta-object (@ (pos 1)))))
        (null Variable))
    } }

    # $how.add-scoped-method($name, $index, $sub)
    sub add-scoped-method { Q:NIL {
        LEXICALS: $name : String, $index : Int32, $sub : DynObject
        LEXICALS: $mo : DynProtoMetaObject
        =[0] @ @!meta-object unwrap:DynProtoMetaObject L!$mo
        =[1] @ unwrap:String L!$name
        =[2] @ unwrap:Int32 L!$index
        =[3] @ cast:DynObject L!$sub

        LEXICALS: $proto : Frame, $code : DynBlockDelegate
        L@$sub @.slots @[code]  cast:DynBlockDelegate L!$code
        L@$sub @.slots @[proto] cast:Frame L!$proto

        LEXICALS: $m : DynProtoMetaObject.Method
        L@$code L@$proto L@$index new/3:DynProtoMetaObject.Method L!$m

        L@$mo @.local  L@$name  L@$m ![]
        null:Variable
    } }

    # $how.create-protoobject($callframe, $superlist)
    sub create-protoobject { Q:NIL {
        LEXICALS: $p : DynObject, $pmo : DynProtoMetaObject, $mo : DynMetaObject
        new/0:DynObject L!$p
        =[0] @ @!meta-object unwrap:DynProtoMetaObject L!$pmo
        L@$pmo new/1:DynMetaObject L!$mo
        L@$mo @.outers  =[1] @ unwrap:Frame  .virtcall/1:Add
        L@$mo =[2] @ unwrap:List<DynMetaObject>  .virtcall/1:BuildC3MRO

        L@$p null:Dictionary<string,object> !.slots
        L@$p L@$mo !.klass
        L@$mo L@$p !.typeObject

        L@$p wrapobj
    } }

    sub compose { Q:CgOp { (null Variable) } }

    Q:CgOp {
        (prog
          (lextypes $chpmo DynProtoMetaObject $ch DynObject)
          (lexput 0 $chpmo (rawnew DynProtoMetaObject))
          (lexput 0 $ch (rawnew DynObject))

          (setfield how (lexget 0 $chpmo) (lexget 0 $ch))
          (setfield name (lexget 0 $chpmo) (clr_string "ClassHOW"))
          (setindex meta-object (getfield slots (lexget 0 '$ch'))
                                (wrap (lexget 0 '$chpmo')))

          (sink (subcall (fetch (lexget 0 &push-scope))
                         (newscalar (lexget 0 $ch)) (wrap (callframe))))
          (sink (subcall (fetch (lexget 0 &add-scoped-method))
                  (newscalar (lexget 0 $ch)) (wrap (clr_string "new")) (wrap (int 0))
                  (lexget 0 &new)))
          (sink (subcall (fetch (lexget 0 &add-scoped-method))
                  (newscalar (lexget 0 $ch)) (wrap (clr_string "push-scope")) (wrap (int 0))
                  (lexget 0 &push-scope)))
          (sink (subcall (fetch (lexget 0 &add-scoped-method))
                  (newscalar (lexget 0 $ch)) (wrap (clr_string "add-scoped-method")) (wrap (int 0))
                  (lexget 0 &add-scoped-method)))
          (sink (subcall (fetch (lexget 0 &add-scoped-method))
                  (newscalar (lexget 0 $ch)) (wrap (clr_string "add-super")) (wrap (int 0))
                  (lexget 0 &add-super)))
          (sink (subcall (fetch (lexget 0 &add-scoped-method))
                  (newscalar (lexget 0 $ch)) (wrap (clr_string "compose")) (wrap (int 0))
                  (lexget 0 &compose)))
          (sink (subcall (fetch (lexget 0 &add-scoped-method))
                  (newscalar (lexget 0 $ch)) (wrap (clr_string "create-protoobject")) (wrap (int 0))
                  (lexget 0 &create-protoobject)))

          (lexput 1 ClassHOW (subcall (fetch (lexget 0 &create-protoobject))
            (newscalar (lexget 0 $ch)) (wrap (callframe))
            (wrap (rawnew List<DynMetaObject>))))

          (setfield klass (lexget 0 $ch)
            (getfield klass (cast DynObject (fetch (lexget 1 ClassHOW)))))
          (lexput 1 ClassHOW!HOW (newscalar (lexget 0 $ch)))

          (null Variable))
    }
}

# cannot be a normal class - it has no parents (and must not be cloned)
my class Mu { ... }
my class Any { ... }
my class Cool { ... }
# these are really defined in the kernel
my class Scalar { ... }
my class Sub { ... }
PRE-INIT {
    # (DynProtoMetaObject $dpmo, ClassHOW $super --> ClassHOW)
    sub wrap-dpmo { Q:CgOp {
        (prog
          (lextypes $ch Variable $dp DynProtoMetaObject)
          (lexput 0 $ch (methodcall (l ClassHOW) new
            (wrap (clr_string ""))))
          (lexput 0 $dp (unwrap DynProtoMetaObject (fetch (pos 0))))

          (assign (varattr meta-object (fetch (lexget 0 $ch)))
                  (wrap (lexget 0 $dp)))
          (sink (methodcall (lexget 0 $ch) add-super (pos 1)))
          (lexget 0 $ch))
    } }
    # (ClassHOW $me, DynMetaObject $use, DynMetaObject $p --> Variable)
    sub wrapped-protoobj { Q:NIL {
        LEXICALS: $p : DynObject, $pmo : DynProtoMetaObject, $mo : DynMetaObject
        LEXICALS: $s : List<DynMetaObject>
        new/0:DynObject L!$p
        =[0] @ @!meta-object unwrap:DynProtoMetaObject L!$pmo
        =[1] @ unwrap:DynMetaObject L!$mo

        new/0:List<DynMetaObject> L!$s
        L@$s  =[2] @ unwrap:DynMetaObject  .virtcall/1:Add
        L@$mo  L@$s  .virtcall/1:BuildC3MRO

        L@$pmo  =[0] @ !.how

        L@$p null:Dictionary<string,object> !.slots
        L@$mo L@$p !.typeObject
        L@$p L@$mo !.klass

        L@$p wrapobj
    } }

Q:NIL {
    LEXICALS: $plist : List<DynMetaObject>
    L@^ClassHOW dup@  "Mu" wrap  .method/1:new  L!^'Mu!HOW'
    new/0:List<DynMetaObject> L!$plist
    L@^'Mu!HOW' dup@  callframe wrap  L@$plist wrap
        .method/2:create-protoobject  L!^Mu

    L@^ClassHOW dup@  "Any" wrap  .method/1:new  L!^'Any!HOW'
    L@^'Any!HOW' dup@  L@^'Mu!HOW'  .method/1:add-super:v
    new/0:List<DynMetaObject> L!$plist
    L@$plist  L@^Mu @ cast:DynObject @.klass  .virtcall/1:Add
    L@^'Any!HOW' dup@  callframe wrap  L@$plist wrap
        .method/2:create-protoobject  L!^Any

    L@^ClassHOW dup@  "Cool" wrap  .method/1:new  L!^'Cool!HOW'
    L@^'Cool!HOW' dup@  L@^'Any!HOW'  .method/1:add-super:v
    new/0:List<DynMetaObject> L!$plist
    L@$plist  L@^Any @ cast:DynObject @.klass  .virtcall/1:Add
    L@^'Cool!HOW' dup@  callframe wrap  L@$plist wrap
        .method/2:create-protoobject  L!^Cool

    new/0:List<DynMetaObject> L!$plist
    L@$plist  L@^Any @ cast:DynObject @.klass  .virtcall/1:Add
    L@^ClassHOW @ cast:DynObject @.klass  L@$plist  .virtcall/1:BuildC3MRO

    L@&wrap-dpmo @  F@Kernel.SubPMO wrap  L@^'Any!HOW'
        .call/2 L!^'Sub!HOW'
    L@&wrapped-protoobj @  L@^'Sub!HOW'  F@Kernel.SubMO wrap
        L@^Any @ cast:DynObject @.klass wrap  .call/3 L!^Sub

    L@&wrap-dpmo @  F@Kernel.ScalarPMO wrap  L@^'Any!HOW'
        .call/2 L!^'Scalar!HOW'
    L@&wrapped-protoobj @  L@^'Scalar!HOW'  F@Kernel.ScalarMO wrap
        L@^Any @ cast:DynObject @.klass wrap  .call/3 L!^Scalar

    null:Variable
} }

my class Junction is Mu { }
my class Num {
    method Str () { Q:CgOp {
        (box Str (rawcall (unbox Double (fetch (scopedlex self))) ToString))
    } }
    method Bool() { Q:CgOp {
        (box Bool (compare != (double 0)
                    (unbox Double (fetch (scopedlex self)))))
    } }
}
my class Str {
    method Str () { self }
}
my class Blob { }
my class Char { }
my class CharLingua { }
my class AnyChar { }
my class Codepoint { }
my class Grapheme { }
my class StrPos { }
my class StrLen { }
my class Rat { }
my class FatRat { }
my class Complex { }
my class Int { }
my class UInt { }
my class Bit { }
my class Instant { }
my class Duration { }
my class Enum { }
my class Bool is Enum {
    method Str() { if self { "Bool::True" } else { "Bool::False" } }
    method Bool() { self }
}

# ought to take a slurpy
sub infix:<~>($l,$r) { Q:CgOp {
    (box Str (rawscall String.Concat
        (unbox String (fetch (methodcall (scopedlex $l) Str)))
        (unbox String (fetch (methodcall (scopedlex $r) Str)))))
} }

sub infix:<+>($l,$r) { Q:CgOp {
    (box Num (arith + (unbox Double (fetch (scopedlex $l)))
                      (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<->($l,$r) { Q:CgOp {
    (box Num (arith - (unbox Double (fetch (scopedlex $l)))
                      (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<*>($l,$r) { Q:CgOp {
    (box Num (arith * (unbox Double (fetch (scopedlex $l)))
                      (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:</>($l,$r) { Q:CgOp {
    (box Num (arith / (unbox Double (fetch (scopedlex $l)))
                      (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< < >>($l,$r) { Q:CgOp {
    (box Bool (compare < (unbox Double (fetch (scopedlex $l)))
                         (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< > >>($l,$r) { Q:CgOp {
    (box Bool (compare > (unbox Double (fetch (scopedlex $l)))
                         (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< <= >>($l,$r) { Q:CgOp {
    (box Bool (compare <= (unbox Double (fetch (scopedlex $l)))
                          (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< >= >>($l,$r) { Q:CgOp {
    (box Bool (compare >= (unbox Double (fetch (scopedlex $l)))
                          (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< == >>($l,$r) { Q:CgOp {
    (box Bool (compare == (unbox Double (fetch (scopedlex $l)))
                          (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< != >>($l,$r) { Q:CgOp {
    (box Bool (compare != (unbox Double (fetch (scopedlex $l)))
                          (unbox Double (fetch (scopedlex $r)))))
} }

sub say($str) { Q:CgOp {
    (prog (rawscall Console.WriteLine
            (unbox String (fetch (methodcall (scopedlex $str) Str))))
          (null Variable))
} }

sub infix:<=> { Q:CgOp { (prog (assign (pos 0) (pos 1)) (pos 0)) } }

# Buglet in STD: standard infix operators look custom inside the setting, and
# forget their precedence.
sub prefix:<-->($v) { $v = ($v - 1); $v }
sub prefix:<++>($v) { $v = ($v + 1); $v }
sub postfix:<-->($v) { my $old = $v; $v = ($v - 1); $old }
sub postfix:<++>($v) { my $old = $v; $v = ($v + 1); $old }

# actually a macro
# sub infix:<:=>($l,$r) { ... }

sub prefix:<~>($v) { $v.Str } # should be Stringy
sub prefix:<?>($v) { $v.Bool }

sub prefix:<!>($v) { if $v { ?0 } else { ?1 } }

sub infix:<eq>($l,$r) { Q:CgOp {
    (box Bool (compare ==
        (unbox String (fetch (methodcall (scopedlex $l) Str)))
        (unbox String (fetch (methodcall (scopedlex $r) Str)))))
} }
sub infix:<ne>($l,$r) { Q:CgOp {
    (box Bool (compare !=
        (unbox String (fetch (methodcall (scopedlex $l) Str)))
        (unbox String (fetch (methodcall (scopedlex $r) Str)))))
} }
# this one is horribly wrong and only handles the ref eq case.
sub infix:<===>($l,$r) { Q:CgOp {
    (box Bool (compare == (fetch (scopedlex $l)) (fetch (scopedlex $r))))
} }

# XXX: We can't use augment syntax because we don't have use working, so
# no MONKEY_TYPING.

PRE-INIT {
    my $i := Mu.HOW.push-scope(Q:CgOp { (wrap (callframe)) });
    Mu.HOW.add-scoped-method(Q:CgOp { (wrap (clr_string "defined")) }, $i,
        anon method defined() {
            Q:CgOp { (box Bool (compare != (null Dictionary<string,object>)
                (getfield slots (cast DynObject (fetch (scopedlex self)))))) }
        });
    Mu.HOW.add-scoped-method(Q:CgOp { (wrap (clr_string "Bool")) }, $i,
        anon method Bool() { self.defined });
    Mu.HOW.add-scoped-method(Q:CgOp { (wrap (clr_string "Str")) }, $i,
        anon method Str() {
            my $tn := Q:CgOp {
                (box Str (getfield name (getfield proto (getfield klass
                    (cast DynObject (fetch (scopedlex self)))))))
            };
            if self.defined {
                $tn ~ "()<instance>"
            } else {
                $tn ~ "()"
            }
        });
}

YOU_ARE_HERE;
