use Metamodel;
use Op;
use RxOp;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaBackendHoopl;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;
use OptRxSimple;
use STD;
use Stash;
use Sig;

my package DEBUG {
    our constant symtab = 1;
}

augment class Operator::Method { #OK
    method with_args($/, *@args) {
        if ($.name eq 'HOW' || $.name eq 'WHAT' || $.name eq 'VAR')
                && !$.private && !$.meta {
            if $.args {
                $/.CURSOR.sorry("Interrogative operator $.name does not take arguments");
                return ::Op::StatementList.new;
            }
            ::Op::Interrogative.new(|node($/), receiver => @args[0],
                name => $.name);
        } else {
            if defined($.path) && !$.private {
                $/.CURSOR.sorry("Qualified references to non-private methods NYI");
            }
            $*CURLEX<!sub>.noninlinable if $.name eq 'eval';
            my $pclass;
            if $.private {
                if $.path {
                    $pclass = $*unit.get_item($*CURLEX<!sub>.find_pkg($.path));
                } elsif $*CURLEX<!sub>.in_class -> $c {
                    $pclass = $c;
                } else {
                    $/.CURSOR.sorry("Cannot resolve class for private method");
                }
            }
            ::Op::CallMethod.new(|node($/),
                receiver => @args[0],
                ismeta   => $.meta,
                name     => $.name,
                private  => $.private,
                pclass   => $pclass,
                args     => [ @$.args ]);
        }
    }
}

augment grammar STD {
our $ALL;
method getsig {
    my $pv = $*CURLEX.{'%?PLACEHOLDERS'};
    if $*CURLEX.<!NEEDSIG>:delete {
        my @parms;
        if $*CURLEX<!sub>.methodof {
            my $cl = $*unit.deref($*CURLEX<!sub>.methodof);
            # XXX type checking against roles NYI
            if $cl !~~ ::Metamodel::Role &&
                    $cl !~~ ::Metamodel::ParametricRole {
                push @parms, ::Sig::Parameter.new(name => 'self', :invocant,
                    tclass => $cl.xref);
            } else {
                push @parms, ::Sig::Parameter.new(name => 'self', :invocant);
            }
            $*CURLEX<!sub>.add_my_name('self', :noinit);
        }

        if $pv {
            my $h_ = $pv.<%_>:delete;
            my $a_ = $pv.<@_>:delete;
            for (keys %$pv).sort({ substr($^a,1) leg substr($^b,1) }) -> $pn is copy {
                my $positional = True;
                if substr($pn,0,1) eq ':' {
                    $pn = substr($pn,1);
                    $positional = False;
                }
                my $list = substr($pn,0,1) eq '@';
                my $hash = substr($pn,0,1) eq '%';
                push @parms, ::Sig::Parameter.new(slot => $pn, :$list, :$hash,
                    name => $pn, :$positional, names => [ substr($pn,1) ]);
                $*CURLEX<!sub>.add_my_name($pn, :noinit, :$list, :$hash);
            }
            if $a_ {
                push @parms, ::Sig::Parameter.new(slot => '@_', name => '*@_',
                    :slurpy, :list);
                $*CURLEX<!sub>.add_my_name('@_', :noinit, :list);
            }
            if $h_ {
                push @parms, ::Sig::Parameter.new(slot => '%_', name => '*%_',
                    :slurpy, :hash);
                $*CURLEX<!sub>.add_my_name('%_', :noinit, :hash);
            }
        }
        else {
            push @parms, ::Sig::Parameter.new(name => '$_', slot => '$_',
                :defouter, :rwtrans);
            $*CURLEX<!sub>.add_my_name('$_', :noinit);
        }
        $*CURLEX<!sub>.signature = Sig.new(params => @parms);
    }
    # NIECZA immutable cursors
    # self.<sig> = $sig;
    # self.<lex> = $*CURLEX.idref;
    if ($*DECLARAND<mult>//'') ne 'proto' {
        for keys %$*CURLEX {
            my $desc = $*CURLEX{$_};
            next if $_ eq '$_' or $_ eq '@_' or $_ eq '%_';
            next if $desc !~~ Hash;
            next if $desc<used>;
            next if $desc<rebind>;
            next if $desc<dynamic>;
            next if $desc<scope> eq 'our';
            next if $desc<scope> eq 'state';
            next if $desc<stub>;
            next unless $_ ~~ /<[\$\@\%\&]>\w/;
            my $pos = $desc<declaredat> // self.pos;
            self.cursor($pos).worry("$_ is declared but not used");
        }
    }
    self;
}

method newlex ($needsig = 0, $once = False) {
    my $oid = $*CURLEX.id;
    my $osub = $*CURLEX<!sub>;
    $ALL.{$oid} === $*CURLEX or die "internal error: current lex id is invalid";
    my $line = self.lineof(self.pos);
    my $id;
    if $*NEWLEX {
        $*NEWLEX.<OUTER::> = $*CURLEX.idref;
        $*CURLEX = $*NEWLEX;
        $*NEWLEX = 0;
        $id = $*CURLEX.id;
    }
    else {
        $id = 'MY:file<' ~ $*FILE<name> ~ '>:line(' ~ $line ~ '):pos(' ~ self.pos ~ ')';
        $*CURLEX = Stash.new(
            'OUTER::' => [$oid],
            '!file' => $*FILE, '!line' => $line,
            '!id' => [$id],
        );
    }
    $*CURLEX.<!NEEDSIG> = 1 if $needsig;
    $*CURLEX.<!IN_DECL> = $*IN_DECL if $*IN_DECL;
    $ALL.{$id} = $*CURLEX;
    $*CURLEX<!sub> = ::Metamodel::StaticSub.new(
        unit => $*unit,
        outerx => $osub.xref,
        in_class => $osub.in_class,
        cur_pkg => $osub.cur_pkg,
        run_once => $once && $osub.run_once
    );
    $osub.add_child($*CURLEX<!sub>);
    self;
}
}

augment grammar STD::P6 { #OK
    token routine_def_1($*cursor) { <?> }
    token routine_def_2($*cursor) { <?> }
    rule routine_def ($d) {
        :temp $*CURLEX;
        :my $*IN_DECL = $d;
        :my $*DECLARAND;
        [
            [ $<sigil>=['&''*'?] <deflongname>? | <deflongname> ]?
            <.newlex(1)>
            <.routine_def_1($/)>
            [ <multisig> | <trait> ]*
            <.routine_def_2($/)>
            [ <!before '{'> <.panic: "Malformed block"> ]?
            <!{
                $*IN_DECL = '';
            }>
            <blockoid>:!s
            <.checkyada>
            <.getsig>
            <.getdecl>
        ] || <.panic: "Malformed routine">
    }
    token method_def_1($*cursor) { <?> }
    token method_def_2($*cursor) { <?> }
    rule method_def ($d) {
        :temp $*CURLEX;
        :my $*IN_DECL = $d;
        :my $*DECLARAND;
        :my $*HAS_SELF = $d eq 'submethod' ?? 'partial' !! 'complete';
        <.newlex(1)>
        [
            [
            | $<type>=[<[ ! ^ ]>?]<longname>
              <.method_def_1($/)> [ <multisig> | <trait> ]*
            | <.method_def_1($/)> <multisig> <trait>*
            | <sigil> '.'
                :dba('subscript signature')
                [
                | '(' ~ ')' [ <.method_def_1($/)> <signature> ]
                | '[' ~ ']' [ <.method_def_1($/)> <signature> ]
                | '{' ~ '}' [ <.method_def_1($/)> <signature> ]
                  # don't need curlycheck here
                ]
                <trait>*
            | <?>
            ]
            <.method_def_2($/)>
            {
                given $*PKGDECL {
                    when 'class'   {} # XXX to be replaced by MOP queries
                    when 'grammar' {}
                    when 'role'    {}
                    default { $¢.worry("'$d' declaration outside of class") if ($*SCOPE || 'has') eq 'has' && $<longname> }
                }
            }
            { $*IN_DECL = ''; }
            <blockoid>:!s
            <.checkyada>
            <.getsig>
            <.getdecl>
        ] || <.panic: "Malformed method">
    }
    token open_package_def($*cursor) { <?> }
    rule package_def {
        :my $longname;
        :my $*IN_DECL = 'package';
        :my $*HAS_SELF = '';
        :my $*DECLARAND;
        :my $*NEWPKG;
        :my $*NEWLEX;
        :temp $*CURPKG;
        :temp $*CURLEX;
        :temp $*SCOPE;
        :my $outer = $*CURLEX;
        { $*SCOPE ||= 'our'; }
        [
            [ <longname> { $longname = $<longname>[0]; $¢.add_name($longname<name>.Str); } ]?
            <.newlex(0, ($*PKGDECL//'') ne 'role')>
            [ :dba('generic role')
                <?{ ($*PKGDECL//'') eq 'role' }>
                '[' ~ ']' <signature(1)>
                { $*IN_DECL = ''; }
            ]?
            <trait>*
            <.open_package_def($/)>
            <.getdecl>
            [
            || <?before '{'>
                [
                {
                    # figure out the actual full package name (nested in outer package)
                    if $longname and $*NEWPKG {
                        my $shortname = $longname.<name>.Str;
                        if $*SCOPE eq 'our' {
                            $*CURPKG = $*NEWPKG // $*CURPKG.{$shortname ~ '::'};
                            self.deb("added our " ~ $*CURPKG.id) if $*DEBUG +& DEBUG::symtab;
                        }
                        else {
                            $*CURPKG = $*NEWPKG // $*CURPKG.{$shortname ~ '::'};
                            self.deb("added my " ~ $*CURPKG.id) if $*DEBUG +& DEBUG::symtab;
                        }
                    }
                    $*begin_compunit = 0;
                    $*UNIT<$?LONGNAME> ||= $longname ?? $longname<name>.Str !! '';
                }
                { $*IN_DECL = ''; }
                <blockoid>
                <.checkyada>
                ]
            || <?before ';'>
                [
                || <?{ $*begin_compunit }>
                    {
                        $longname orelse $¢.panic("Compilation unit cannot be anonymous");
                        $outer === $*UNIT or $¢.panic("Semicolon form of " ~ $*PKGDECL ~ " definition not allowed in subscope;\n  please use block form");
                        $*PKGDECL eq 'package' and $¢.panic("Semicolon form of package definition indicates a Perl 5 module; unfortunately,\n  STD doesn't know how to parse Perl 5 code yet");
                        my $shortname = $longname.<name>.Str;
                        $*CURPKG = $*NEWPKG // $*CURPKG.{$shortname ~ '::'};
                        $*begin_compunit = 0;

                        # XXX throws away any role sig above
                        # worse - breaks CURLEX<!sub> handling
                        # $*CURLEX = $outer;

                        $*UNIT<$?LONGNAME> = $longname<name>.Str;
                    }
                    { $*IN_DECL = ''; }
                    <statementlist>     # whole rest of file, presumably
                || <.panic: "Too late for semicolon form of " ~ $*PKGDECL ~ " definition">
                ]
            || <.panic: "Unable to parse " ~ $*PKGDECL ~ " definition">
            ]
        ] || <.panic: "Malformed $*PKGDECL">
    }

}

augment class Metamodel::StaticSub { #OK
    method noninlinable() {
        loop (my $c = self; $c.unit === $*unit; $c = $c.outer) {
            $c.strong_used = True;
        }
    }
}

# $*YOU_ARE_HERE: set is_setting, bottom_ref instead!

augment class NieczaGrammar::P6 { #OK
    method unitstart() {
        my $top = $*unit.setting_ref;
        my $rtop = $top && $*unit.deref($top);
        $*CURLEX{'!sub'} = ::Metamodel::StaticSub.new(
            unit => $*unit,
            outerx => $top,
            cur_pkg => ['GLOBAL'],
            name => "mainline",
            run_once => !$rtop || $rtop.run_once);
        $*CURLEX{'!sub'}.add_my_name('$_') if !$top;
        $*CURLEX{'!sub'}.add_hint('$?FILE');
        $*CURLEX{'!sub'}.signature = Sig.simple();
        $*unit.mainline = $*CURLEX<!sub>;

        %*LANG<Q> = ::NieczaGrammar::Q ;
        %*LANG<MAIN> = ::NieczaGrammar::P6 ;
        self;
    }
}

augment class NieczaActions {
method get_placeholder_sig(|$) { die }
# this is intended to be called after parsing the longname for a sub,
# but before the signature.  export, etc are handled by the sub/package
# trait handler
method install_sub($/, $sub, :$multiness is copy, :$scope is copy, :$class,
        :$path, :$name is copy, :$method_type is copy, :$contextual is copy) {

    $multiness ||= 'only';

    if !$scope {
        if !defined($name) {
            $scope = 'anon';
        } elsif defined($path) {
            $scope = 'our';
        } elsif defined($method_type) {
            $scope = 'has';
        } else {
            $scope = 'my';
        }
    }

    if $scope ne 'my' && $scope ne 'our' && $scope ne 'anon' && $scope ne 'has' {
        $/.CURSOR.sorry("Illegal scope $scope for subroutine");
        $scope = 'anon';
    }

    if $scope eq 'has' && !defined($method_type) {
        $/.CURSOR.sorry('has scope-type is only valid for methods');
        $scope = 'anon';
    }

    if $scope ne 'anon' && !defined($name) {
        $/.CURSOR.sorry("Scope $scope requires a name");
        $scope = 'anon';
    }

    if $scope ne 'our' && defined($path) {
        $/.CURSOR.sorry("Double-colon-qualified subs must be our");
        $scope = 'our';
    }

    if $scope eq 'anon' && $multiness ne 'only' {
        $/.CURSOR.sorry("Multi routines must have a name");
        $multiness = 'only';
    }

    if $contextual && (defined($method_type) || $scope ne 'my') {
        $/.CURSOR.sorry("Context-named routines must by purely my-scoped");
        $contextual = False;
    }

    my $method_targ = $method_type && $sub.outer.body_of;
    if $method_targ {
        $method_targ = $*unit.deref($method_targ);
    } elsif defined($method_type) {
        $/.CURSOR.sorry("Methods must be used in some kind of package");
        $method_type = 'Str';
    }

    if $name ~~ Op && (!defined($method_type) || $scope ne 'has' ||
            $method_targ !~~ ::Metamodel::ParametricRole) {
        $/.CURSOR.sorry("Computed names are only implemented for parametric roles");
        $name = "placeholder";
    }

    my $bindlex = $scope eq 'my' || ($scope eq 'our' && !$path);

    $sub.set_name(($name ~~ Op) ?? '::($name)' !!
        defined($method_type) ?? $method_targ.name ~ "." ~ $name !!
        ($name // 'ANON'));
    $sub.class = $class;
    $sub.returnable = True;

    my Str $symbol;
    if $bindlex && $class eq 'Regex' {
        $symbol = '&' ~ $name;
        my $proto = $symbol;
        $proto ~~ s/\:.*//;
        $sub.outer.add_dispatcher($proto) if $multiness ne 'only'
            && !$sub.outer.lexicals.{$proto};
        $symbol ~= ":(!proto)" if $multiness eq 'proto';
    } elsif $bindlex {
        $symbol = '&' ~ $name;
        $sub.outer.add_dispatcher($symbol) if $multiness ne 'only'
            && !$sub.outer.lexicals.{$symbol};

        given $multiness {
            when 'multi' { $symbol ~= ":({ self.gensym })"; }
            when 'proto' { $symbol ~= ":(!proto)"; }
        }
    } else {
        $symbol = self.gensym;
    }

    $sub.outervar = $symbol;
    $sub.methodof = defined($method_type) ?? $method_targ.xref !! Any;
    $sub.outer.add_my_sub_child($symbol, $sub);

    if defined($method_type) || $scope eq 'our' {
        $sub.strong_used = True;
        $sub.outer.create_static_pad;
    }

    if defined($method_type) {
        if $sub.outer.augment_hack {
            push $sub.outer.augment_hack,
                [ $multiness, $method_type, $name, $symbol, $sub.xref ];
        } else {
            $method_targ.add_method($multiness, $method_type, $name,
                $symbol, $sub.xref);
        }
    }

    if $scope eq 'our' {
        $sub.exports = [ @($sub.outer.find_pkg($path // ['OUR'])), '&'~$name ];
    }
}

method routine_def_1 ($, $/ = $*cursor) {
    my $cx = $<sigil> && $<sigil>[0] eq '&*';

    my ($m,$p) = $<deflongname>[0] ??
        self.mangle_longname($<deflongname>[0]).<name path> !! ();

    self.install_sub($/, $*CURLEX<!sub>, scope => $*SCOPE, name => $m,
        path => $p, contextual => $cx, multiness => $*MULTINESS, :class<Sub>);
}

method routine_def_2 ($, $/ = $*cursor) {
    if $<multisig> > 1 {
        $/.CURSOR.sorry("You may only use *one* signature");
    }
    $*CURLEX<!sub>.signature = $<multisig> ?? $<multisig>[0].ast !! Any;
    self.process_block_traits($/, $<trait>);
}

method routine_def ($/) {
    $*CURLEX<!sub>.code = $<blockoid>.ast;
    make mklex($/, $*CURLEX<!sub>.outervar);
}

method method_def_1 ($, $/ = $*cursor) {
    my $type = $<type> ?? ~$<type> !! '';
    if $type ne '' && $*HAS_SELF eq 'partial' {
        $type = '';
        $/.CURSOR.sorry("Type symbols cannot be used with submethod");
    }

    my ($m,$p) = $<longname> ??
        self.mangle_longname($<longname>).<name path> !! ();

    self.install_sub($/, $*CURLEX<!sub>, scope => $*SCOPE, name => $m,
        method_type => ($type eq '^' ?? 'meta' !! $type eq '!' ?? 'private' !!
            $*HAS_SELF eq 'partial' ?? 'sub' !! 'normal'),
        path => $p, multiness => $*MULTINESS,
        :class($*HAS_SELF eq 'partial' ?? 'Submethod' !! 'Method'));
}

method method_def_2 ($, $/ = $*cursor) {
    if $<multisig> > 1 {
        $/.CURSOR.sorry("You may only use *one* signature");
    }
    $*CURLEX<!sub>.signature = $<multisig> ?? $<multisig>[0].ast !! Any;
    self.process_block_traits($/, $<trait>);
}

method method_def ($/) {
    $*CURLEX<!sub>.code = $<blockoid>.ast;
    make mklex($/, $*CURLEX<!sub>.outervar);
}

my %_decl2class = (
    package => ::Op::PackageDef,
    class   => ::Op::ClassDef,
    module  => ::Op::ModuleDef,
    grammar => ::Op::GrammarDef,
    role    => ::Op::RoleDef,
);

method package_def ($/) {
    my $sub = $*CURLEX<!sub>;

    my $bodyvar = self.gensym;
    $sub.outer.add_my_sub_child($bodyvar, $sub);
    $sub.code = ($<blockoid> // $<statementlist>).ast;

    if $sub.augmenting {
        my $ah = $sub.augment_hack;
        $sub.augment_hack = Any;

        my $ph = ::Metamodel::StaticSub.new(
            unit       => $*unit,
            outerx     => $sub.xref,
            cur_pkg    => [ 'GLOBAL' ],
            name       => 'ANON',
            is_phaser  => 0,
            augment_hack => $ah,
            class      => 'Code',
            code       => ::Op::StatementList.new(children => []),
            run_once   => $sub.run_once);
        $sub.create_static_pad;
        $sub.add_child($ph);

        make ::Op::CallSub.new(|node($/), invocant => mklex($/, $bodyvar));
    }
    else {
        my $obj = $*unit.deref($sub.body_of);
        $obj.close;

        if $obj ~~ ::Metamodel::ParametricRole {
            $sub.parametric_role_hack = $obj.xref;
            $sub.add_my_name('*params', :noinit);
            $sub.create_static_pad;
        }

        make ::Op::StatementList.new(|node($/), children => [
            ::Op::CallSub.new(invocant => mklex($/, $bodyvar)),
            ::Op::Lexical.new(name => $*CURLEX<!outervar>) ]);
    }
}

method package_declarator:sym<also> ($/) {
    self.process_block_traits($/, $<trait>);
    make ::Op::StatementList.new;
}

method process_block_traits($/, @tr) {
    my $sub = $*CURLEX<!sub>;
    my $pack = $sub.body_of;
    for map *.ast, @tr -> $tr {
        if $pack && ($tr<name>:exists) {
            my ($name, $path) = $tr<name path>;

            $/.CURSOR.sorry("superclass $name declared outside of any class"),
                next unless $sub.body_of;
            $/.CURSOR.sorry("superclass $name declared in an augment"),
                next if $sub.augmenting;

            $*unit.deref($pack).add_super($*unit.get_item($sub.find_pkg(
                [ @($path // ['MY']), $name ])));
        } elsif $pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_pkg_exports($*unit, $*unit.deref($pack).name,
                $sub.cur_pkg, @exports);
        } elsif !$pack && $tr<export> {
            my @exports = @( $tr<export> );
            $sub.outer.add_exports($*unit, '&' ~ $sub.name, @exports);
            $sub.exports //= [];
            push $sub.exports, [ @($sub.outer.find_pkg(
                ['OUR','EXPORT',$_])), '&' ~ $sub.name ] for @exports;
        } elsif !$pack && $tr<nobinder> {
            $sub.signature = Any;
        } elsif !$pack && $tr<return_pass> {
            $sub.returnable = False;
        } elsif !$pack && $tr<of> {
        } elsif !$pack && $tr<rw> {
        } elsif !$pack && $tr<unsafe> {
            $sub.unsafe = True;
        } else {
            $/.CURSOR.sorry("Unhandled trait $tr.keys[0] for this context");
        }
    }
}


method open_package_def($, $/ = $*cursor) {
    my %_decl2mclass = (
        package => ::Metamodel::Package,
        class   => ::Metamodel::Class,
        module  => ::Metamodel::Module,
        grammar => ::Metamodel::Grammar,
        role    => ::Metamodel::Role,
    );
    my $sub = $*CURLEX<!sub>;

    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }

    my $scope = $*SCOPE;
    if !$<longname> {
        $scope = 'anon';
    }

    if $scope eq 'supersede' {
        $/.CURSOR.sorry('Supercede is not yet supported');
        $scope = 'our';
    }
    if $scope eq 'has' || $scope eq 'state' {
        $/.CURSOR.sorry("Illogical scope $scope for package block");
        $scope = 'our';
    }

    if $scope eq 'augment' {
        my $r = self.mangle_longname($<longname>[0], True);
        my $name = $r<name>;
        my @augpkg = @( $r<path> // ['MY'] );

        my $pkg = $sub.outer.find_pkg([ @augpkg, $name ]);
        my $so  = $*unit.get_item($pkg);
        my $dso = $*unit.deref($so);

        if $dso.^isa(::Metamodel::Role) {
            $/.CURSOR.panic("Illegal augment of a role");
        }

        my @ah = $so;
        $sub.augment_hack = @ah;
        $sub.body_of = $sub.in_class = $so;
        $sub.augmenting = True;
        $sub.set_name("augment-$dso.name()");
    } else {
        my ($name, $ourpkg);
        my $type = %_decl2mclass{$*PKGDECL};
        if ($*PKGDECL//'role') eq 'role' && $<signature> {
            $sub.signature = $<signature>.ast;
            $type = ::Metamodel::ParametricRole;
        }
        if $<longname> {
            my $r = self.mangle_longname($<longname>[0], True);
            $name = $r<name>;
            if ($r<path>:exists) && $scope ne 'our' {
                $/.CURSOR.sorry("Block name $<longname> requires our scope");
                $scope = 'our';
            }
            if $scope eq 'our' {
                $ourpkg = ($r<path>:exists) ?? $r<path> !! ['OUR'];
            }
            # just a convenient place to stash it for now.
            $*CURLEX<!outervar> = ($scope eq 'anon' || ($r<path>:exists))
                ?? self.gensym !! $name;
        } else {
            $*CURLEX<!outervar> = self.gensym;
            $name = 'ANON';
        }

        my @ns = $ourpkg ?? (@( $sub.outer.find_pkg($ourpkg) ), $name) !!
            $*unit.anon_stash;

        $*unit.create_stash([@ns]);
        $sub.outer.add_my_stash($*CURLEX<!outervar>, [@ns]);
        my $obj  = $type.new(:$name);
        $*unit.bind_item([@ns], $obj.xref);

        $sub.body_of = $sub.in_class = $obj.xref;
        $sub.cur_pkg = [@ns];

        self.process_block_traits($/, $<trait>);
        $sub.set_name($*PKGDECL ~ "-" ~ $obj.name);
        $obj.exports = [ [@ns] ];
    }
}

method signature($/) {
    if $<type_constraint> {
        # ignore for now
    }

    if $<param_var> {
        my $sig = Sig.new(params => [ ::Sig::Parameter.new(
                name => ~$<param_var>, |$<param_var>.ast,
                full_parcel => True) ]);
        $*CURLEX<!sub>.signature = $sig if $*SIGNUM;
        make $sig;
        return;
    }

    my @p = map *.ast, @( $<parameter> );
    my @ps = @( $<param_sep> );
    my $ign = False;
    loop (my $i = 0; $i < @p; $i++) {
        @p[$i].multi_ignored = $ign;
        if $i >= @ps {
        } elsif defined @ps[$i].index(':') {
            $/.CURSOR.sorry('Only the first parameter may be invocant') if $i;
            $*CURLEX<!sub>.add_my_name('self', :noinit);
            @p[$i].invocant = True;
        } elsif defined @ps[$i].index(';;') {
            $ign = True;
        } elsif !defined @ps[$i].index(',') {
            $/.CURSOR.sorry("Parameter separator @ps[$i] NYI");
        }
    }

    if $*SIGNUM && $*CURLEX<!sub>.methodof && (!@p || !@p[0].invocant) {
        $*CURLEX<!sub>.add_my_name('self', :noinit);
        unshift @p, ::Sig::Parameter.new(name => 'self', :invocant);
    }

    for @p {
        if !defined(.tclass) && $*SIGNUM {
            if .invocant && $*CURLEX<!sub>.methodof {
                my $cl = $*unit.deref($*CURLEX<!sub>.methodof);
                # XXX type checking against roles NYI
                if $cl !~~ ::Metamodel::Role &&
                        $cl !~~ ::Metamodel::ParametricRole {
                    .tclass = $cl.xref;
                }
            } elsif !$*CURLEX<!sub>.returnable {
                .tclass = $*unit.get_item($*CURLEX<!sub>.find_pkg(['MY','Mu']));
            }
        }
    }

    my $sig = Sig.new(params => @p);
    $*CURLEX<!sub>.signature = $sig if $*SIGNUM;
    make $sig;
}


method comp_unit($/) {
    $*CURLEX{'!sub'}.code = $<statementlist>.ast;
    $*CURLEX{'!sub'}.close;

    make $*unit;
}

method declarator($/) {
    if $<signature> {
        my @p = @( $<signature>.ast.params );
        # TODO: keep the original signature around somewhere := can find it
        for @p {
            # TODO: fanciness checks
            $_ = mklex($/, .slot, list => .list, hash => .hash);
        }
        make ::Op::SimpleParcel.new(|node($/), items => @p);
        return;
    }
    make $<variable_declarator> ?? $<variable_declarator>.ast !!
         $<routine_declarator>  ?? $<routine_declarator>.ast !!
         $<regex_declarator>    ?? $<regex_declarator>.ast !!
         $<type_declarator>.ast;
}

method do_variable_reference($M, $v) {
    if $v<term> {
        return $v<term>;
    }

    my $tw = $v<twigil>;
    my $sl = $v<sigil> ~ $tw ~ $v<name>;
    my $list = $v<sigil> eq '@';
    my $hash = $v<sigil> eq '%';

    if defined($v<rest>) && $tw ~~ /<[*=~?^:]>/ {
        $M.CURSOR.sorry("Twigil $tw cannot be used with qualified names");
        return ::Op::StatementList.new;
    }

    if $tw eq '!' {
        my $pclass;
        if $v<rest> {
            $pclass = $*unit.get_item($*CURLEX<!sub>.find_pkg($v<rest>));
        } elsif $*CURLEX<!sub>.in_class -> $c {
            $pclass = $c;
        } else {
            $/.CURSOR.sorry("Cannot resolve class for private method");
        }
        self.docontext($M, $v<sigil>, ::Op::CallMethod.new(|node($M),
            name => $v<name>, private => True, receiver => mklex($M, 'self'),
            ppath => $v<rest>));
    }
    elsif $tw eq '.' {
        if defined $v<rest> {
            $M.CURSOR.sorry('$.Foo::bar syntax NYI');
            return ::Op::StatementList.new;
        }

        self.docontext($M, $v<sigil>, ::Op::CallMethod.new(|node($M),
            name => $v<name>, receiver => mklex($M, 'self')));
    }
    # no twigil in lex name for these
    elsif $tw eq '^' || $tw eq ':' {
        mklex($M, $v<sigil> ~ $v<name>, :$hash, :$list);
    }
    elsif $tw eq '*' {
        ::Op::ContextVar.new(|node($M), name => $sl);
    }
    elsif $tw eq '' || $tw eq '?' {
        if defined($v<rest>) {
            ::Op::PackageVar.new(path => $v<rest>, name => $sl,
                hash => ($v<sigil> eq '%'), list => ($v<sigil> eq '@'),
                slot => self.gensym, |node($M));
        } elsif $tw eq '?' && $sl eq '$?POSITION' {
            mkcall($M, '&infix:<..^>',
                ::Op::Num.new(|node($M), value => [10, ~$M.from]),
                ::Op::Num.new(|node($M), value => [10, ~$M.to]));
        } elsif $tw eq '?' && $sl eq '$?LINE' {
            ::Op::Num.new(|node($M), value => [10, ~$M.cursor.lineof($M.from)]);
        } elsif $tw eq '?' && $sl eq '&?BLOCK' {
            ::Op::GetBlock.new(|node($M))
        } elsif $tw eq '?' && $sl eq '&?ROUTINE' {
            ::Op::GetBlock.new(|node($M), :routine)
        } else {
            mklex($M, $sl, :$hash, :$list);
        }
    }
    else {
        $M.CURSOR.sorry("Unhandled reference twigil $tw");
    }
}
method infix:sym<...> ($/) {
    # STD parses ...^ in the ... rule
    make Operator.funop('&infix:<' ~ $/ ~ '>', 2);
}

method sibble($/) {
    my $regex = self.op_for_regex($/, $<left>.ast);
    my $repl;
    if $<infixish> {
        if $<infixish> eq '=' {
            $repl = $<right>.ast;
        } elsif $<infixish>.ast ~~ ::Operator::CompoundAssign {
            $repl = $<infixish>.ast.base.with_args($/,
                mkcall($/, '&prefix:<~>', ::Op::ContextVar.new(name => '$*/')),
                $<right>.ast);
        } else {
            $/.CURSOR.sorry("Unhandled operator in substitution");
            $repl = mklex($/, 'Any');
        }
    } else {
        $repl = $<right>.ast;
    }
    $repl = self.transparent($/, $repl, class => 'Regex');
    make ::Op::CallMethod.new(|node($/), receiver => mklex($/, '$_'),
        name => 'subst',
        args => [ $regex, $repl, self.extract_rx_adverbs(True, True, $/),
            ::Op::SimplePair.new(key => 'inplace', value => mklex($/,'True'))]);
}

method quotepair_term($/) {
    my $v;
    if $<v> ~~ Match {
        $v = $<v>.ast
    } elsif $<v> ~~ Str {
        $v = ::Op::Num.new(value => [10, $<v>]);
    } else {
        $v = mklex($/, $<v> ?? "True" !! "False");
    }
    ::Op::SimplePair.new(|node($/), key => $<k>, value => $v);
}

method extract_rx_adverbs($ismatch, $issubst, $match) {
    my $qps = ($match ~~ List) ?? $match !! $match<babble><quotepair>;
    return () if !$qps;

    my @ok;
    my @nyi;
    my @args;
    my @internal = < sigspace s ratchet r ignorecase i >;

    push @nyi, < ignoreaccent a bytes codes graphs chars Perl5 P5 >;

    if $issubst {
        push @nyi, < sameaccent aa samecase ii th st nd rd nth x >;
        push @ok,  < g global >;
    }

    if $ismatch {
        push @nyi, < overlap ov exhaustive ex continue c pos p global g rw >;
    }

    for @$qps -> $qp {
        if @internal.grep($qp<k>) {
            # handled by rx compiler
        } elsif @ok.grep($qp<k>) {
            push @args, self.quotepair_term($qp);
        } elsif @nyi.grep($qp<k>) {
            $qp.CURSOR.sorry("Regex modifier $qp<k> not yet implemented");
        } else {
            $qp.CURSOR.sorry("Regex modifier $qp<k> not valid on { $issubst ?? "substitution" !! $ismatch ?? "match" !! "regex literal" }");
        }
    }

    @args
}

method INFIX($/) {
    my $fn = $<infix>.ast;
    my ($st,$lhs,$rhs) = self.whatever_precheck($fn, $<left>.ast, $<right>.ast);

    make $fn.with_args($/, $lhs, $rhs);

    if $fn.assignish {
        # Assignments to has and state declarators are rewritten into
        # an appropriate phaser
        if $lhs.^isa(::Op::Lexical) && $lhs.state_decl {
            my $cv = self.gensym;
            make ::Op::StatementList.new(|node($/), children => [
                ::Op::Start.new(condvar => $cv, body => $/.ast),
                ::Op::Lexical.new(name => $lhs.name)]);
        }
        elsif $lhs.^isa(::Op::Attribute) && !defined($lhs.initializer.ivar) {
            my $init = self.thunk_sub($rhs,
                :name($lhs.initializer.name ~ " init"));
            $lhs.initializer.ivar = self.gensym;
            $*CURLEX<!sub>.add_my_sub_child($lhs.initializer.ivar, $init);
            $lhs.initializer.ibody = $init.xref;
            make $lhs;
        }
        elsif $lhs.^isa(::Op::ConstantDecl) && !$lhs.init {
            my $sig = substr($lhs.name, 0, 1);
            if defined '$@&%'.index($sig) {
                self.init_constant($lhs, self.docontext($/, $sig, $rhs));
            } else {
                self.init_constant($lhs, $rhs);
            }
            make $lhs;
        }
    }
    make self.whatever_postcheck($/, $st, $/.ast);
}

method add_attribute($/, $name, $sigil, $accessor, $type) {
    my $ns = $*CURLEX<!sub>.body_of;
    $/.CURSOR.sorry("Attribute $name declared outside of any class"),
        return ::Op::StatementList.new unless $ns;
    $/.CURSOR.sorry("Attribute $name declared in an augment"),
        return ::Op::StatementList.new if $*CURLEX<!sub>.augmenting;

    $ns = $*unit.deref($ns);
    my $at = $ns.add_attribute($name, $sigil, +$accessor, Any, Any, $type);

    my $nb = ::Metamodel::StaticSub.new(
        transparent=> True,
        unit       => $*unit,
        outerx     => $*CURLEX<!sub>.xref,
        name       => $name,
        cur_pkg    => $*CURLEX<!sub>.cur_pkg,
        class      => 'Method',
        signature  => Sig.simple('self'),
        code       => ::Op::GetSlot.new(name => $name,
            object => ::Op::Lexical.new(name => 'self')));
    $nb.add_my_name('self', noinit => True);
    $*CURLEX<!sub>.create_static_pad; # for protosub instance
    $nb.strong_used = True;
    $*CURLEX<!sub>.add_my_sub($name ~ '!a', $nb);
    $ns.add_method('only', 'private', $name, $name ~ '!a', $nb.xref);
    if $accessor {
        $ns.add_method('only', 'normal', $name, $name ~ '!a', $nb.xref);
    }

    ::Op::Attribute.new(name => $name, initializer => $at);
}

method variable_declarator($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    for @$<trait> -> $t {
        if $t.ast<rw> {
        } else {
            $/.CURSOR.sorry("Trait $t.ast.keys.[0] not available on variables");
        }
    }
    if $<post_constraint> || $<postcircumfix> || $<semilist> {
        $/.CURSOR.sorry("Postconstraints, and shapes on variable declarators NYI");
    }

    my $scope = $*SCOPE // 'my';

    if $scope eq 'augment' || $scope eq 'supersede' {
        $/.CURSOR.sorry("Illogical scope $scope for simple variable");
    }

    my $typeconstraint;
    if $*OFTYPE {
        $typeconstraint = self.simple_longname($*OFTYPE<longname>);
        $/.CURSOR.sorry("Common variables are not unique definitions and may not have types") if $scope eq 'our';
    }

    my $v = $<variable>.ast;
    my $t = $v<twigil>;
    my $list = $v<sigil> eq '@';
    my $hash = $v<sigil> eq '%';
    if ($t && defined "?=~^:".index($t)) {
        $/.CURSOR.sorry("Variables with the $t twigil cannot be declared " ~
            "using $scope; they are created " ~
            ($t eq '?' ?? "using 'constant'." !!
             $t eq '=' ?? "by parsing POD blocks." !!
             $t eq '~' ?? "by 'slang' definitions." !!
             "automatically as parameters to the current block."));
    }

    if $scope ne 'has' && ($t eq '.' || $t eq '!') {
        $/.CURSOR.sorry("Twigil $t is only valid on attribute definitions ('has').");
    }

    if defined $v<rest> {
        $/.CURSOR.sorry(":: syntax is only valid when referencing variables, not when defining them.");
    }

    my $name = $v<sigil> ~ $v<twigil> ~ $v<name>;
    # otherwise identical to my
    my $slot = ($scope eq 'anon') ?? self.gensym !! $name;
    my $res_tc = $typeconstraint ??
        $*unit.get_item($*CURLEX<!sub>.find_pkg($typeconstraint)) !! Any;

    if $scope eq 'has' {
        make self.add_attribute($/, $v<name>, $v<sigil>, $t eq '.', $res_tc);
    } elsif $scope eq 'state' {
        $*CURLEX<!sub>.add_state_name($slot, self.gensym, :$list,
            :$hash, typeconstraint => $res_tc);
        make mklex($/, $slot, :$list, :$hash, :state_decl);
    } elsif $scope eq 'our' {
        make ::Op::PackageVar.new(|node($/), name => $slot, slot => $slot,
            path => [ 'OUR' ]);
    } else {
        $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash,
            typeconstraint => $res_tc);
        make mklex($/, $slot, :$list, :$hash);
    }
}

method parameter($/) {
    my $rw = False;
    my $copy = False;
    my $sorry;
    my $slurpy = False;
    my $slurpycap = False;
    my $optional = False;
    my $rwt = False;
    my $type;

    if $<type_constraint> {
        my $t = self.simple_longname($<type_constraint>[0]<typename><longname>);
        $type = $*unit.get_item($*CURLEX<!sub>.find_pkg($t));
    }

    for @( $<trait> ) -> $trait {
        if $trait.ast<rw> { $rw = True }
        elsif $trait.ast<copy> { $copy = True }
        elsif $trait.ast<parcel> { $rwt = True }
        elsif $trait.ast<readonly> { $rw = False }
        else {
            $trait.CURSOR.sorry('Unhandled trait ' ~ $trait.ast.keys.[0]);
        }
    }

    if $<post_constraint> > 0 {
        $/.sorry('Parameter post constraints NYI');
        make ::Sig::Parameter.new;
        return Nil;
    }

    my $default = $<default_value> ?? $<default_value>[0].ast !! Any;
    $*unit.deref($default).set_name("$/ init") if $default;

    my $tag = $<quant> ~ ':' ~ $<kind>;
    if    $tag eq '**:*' { $sorry = "Slice parameters NYI" }
    elsif $tag eq '*:*'  { $slurpy = True }
    elsif $tag eq '|:*'  { $slurpycap = True }
    elsif $tag eq '\\:!' { $rwt = True }
    elsif $tag eq '\\:?' { $rwt = True; $optional = True }
    elsif $tag eq ':!'   { }
    elsif $tag eq ':*'   { $optional = True }
    elsif $tag eq ':?'   { $optional = True }
    elsif $tag eq '?:?'  { $optional = True }
    elsif $tag eq '!:!'  { }
    elsif $tag eq '!:?'  { $optional = True }
    elsif $tag eq '!:*'  { }
    else                 { $sorry = "Confusing parameters ($tag)" }
    if $sorry { $/.CURSOR.sorry($sorry); }
    my $p = $<param_var> // $<named_param>;

    if defined $p.ast<slot> {
        # TODO: type constraint here
    }

    make ::Sig::Parameter.new(name => ~$/, mdefault => $default,
        :$optional, :$slurpy, :$rw, tclass => $type,
        :$slurpycap, rwtrans => $rwt, is_copy => $copy, |$p.ast);
}

method default_value($/) { make self.thunk_sub($<EXPR>.ast).xref }
method thunk_sub($code, :$name) {
    my $n = ::Metamodel::StaticSub.new(
        outerx => $*CURLEX<!sub>.xref,
        class => 'Code',
        unit => $*unit,
        name => $name // 'ANON',
        transparent => True,
        code => $code,
        in_class => $*CURLEX<!sub>.in_class,
        cur_pkg => $*CURLEX<!sub>.cur_pkg);
    $*CURLEX<!sub>.add_child($n);
    $n;
}

method block($/) {
    make $*CURLEX<!sub>
}

# :: Body
method pblock($/) {
    #my $rw = $<lambda> && $<lambda> eq '<->'; TODO
    $*CURLEX<!sub>.code = $<blockoid>.ast;
    make $*CURLEX<!sub>;
}

# returns Body of 0 args
method blast($/) {
    if $<block> {
        make $<block>.ast;
    } else {
        make self.thunk_sub($<statement>.ast);
    }
}

method inliney_call($/, $block, *@parms) {
    my $sym = self.gensym;
    $*CURLEX<!sub>.add_my_sub_child($sym, $block);
    ::Op::CallSub.new(|node($/),
        invocant => ::Op::SubDef.new(body => Any, symbol => $sym, :once),
        positionals => @parms);
}

method if_block($/, $cond, $pb) {
    if defined $pb<lambda> {
        make self.inliney_call($/, $pb.ast, $cond);
    } else {
        make self.inliney_call($/, $pb.ast);
    }
}

method make_constant($/, $scope, $name, $path) {
    $scope := $scope || 'our';

    my $slot = ($scope eq 'my' || $scope eq 'our' && !$path) ?? $name !!
        self.gensym;

    if $path {
        $*CURLEX<!sub>.add_common_name($slot,
            $*CURLEX<!sub>.find_pkg($path), $name);
    } else {
        $*CURLEX<!sub>.add_hint($slot);
    }

    ::Op::ConstantDecl.new(|node($/), name => $slot, init => False);
}

method init_constant($con, $rhs) {
    my $body = self.thunk_sub($rhs, name => "$con.name() init");
    $body.is_phaser = 2;
    $body.hint_hack = [ $*CURLEX<!sub>.xref, $con.name ];
    $body.outer.create_static_pad;
    $con.init = True;
    $con;
}

method type_declarator:constant ($/) {
    if $*MULTINESS {
        $/.CURSOR.sorry("Multi variables NYI");
    }
    my $name  = ~($<identifier> // $<variable> // self.gensym);

    make self.make_constant($/, $*SCOPE || 'our', $name, Array);
}

method param_var($/) {
    if $<signature> {
        $/.CURSOR.sorry('Sub-signatures NYI');
        make { };
        return Nil;
    }
    my $twigil = $<twigil> ?? ~$<twigil>[0] !! '';
    my $sigil =  ~$<sigil>;
    my $list = $sigil eq '@';
    my $hash = $sigil eq '%';
    my $name =   $<name> ?? ~$<name>[0] !! Any;
    $twigil = '*' if $name && ($name eq '/' || $name eq '!');

    my $slot;
    if $twigil eq '' {
        $slot = defined($name) ?? ($sigil ~ $name) !! Any;
    } elsif $twigil eq '*' {
        $slot = "$sigil*" ~ "$name";
    } else {
        $/.CURSOR.sorry("Unhandled parameter twigil $twigil");
        make { };
        return Nil;
    }

    if ($sigil ne '$' && $sigil ne '@' && $sigil ne '%' && $sigil ne '&') {
        $/.CURSOR.sorry('Non bare scalar targets NYI');
        make { }
        return Nil;
    }

    $*CURLEX<!sub>.add_my_name($slot, :$list, :$hash, :noinit)
        if defined($slot);

    make { :$list, :$hash, :$slot,
        names => defined($name) ?? [ $name ] !! [] }
}
}

class Op::MakeJunction is Op {
    has Int $.typecode = die "MakeJunction.typecode required";
    has @.zyg;

    method code($body) {
        CgOp.makejunction($!typecode, map *.cgop($body), @!zyg)
    }
}

CgOp._register_ops: < makejunction
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (nam, dotnet, clisp, hoopl)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
elsif $bcnd eq 'hoopl' {
    $backend = NieczaBackendHoopl.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $stages;
if $bcnd eq 'clisp' {
    $stages = [
        NieczaPassSimplifier.new,
    ];
} elsif $bcnd eq 'hoopl' {
    $stages = [
        NieczaPassSimplifier.new,
    ];
} else {
    $stages = [
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ];
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => $stages,
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    my $*repl_outer;
    $c.compile_string('', !$comp, $stop);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, $stop, :repl, :evalmode,
                :outer($*repl_outer));
            $ok = True;
        }
        say $! unless $ok;
    }
}
