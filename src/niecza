use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

$GLOBAL::DEBUG_STD = (%*ENV<NIECZA_STD_DEBUG> ?? -1 !! 0);

augment class Any {
    submethod new(|) { die "Attempted to instantiate undefined class." }
}

our ($Operator, $Operator_Method, $Operator_Replicate, $Operator_FlipFlop,
     $Operator_SmartMatch, $Operator_Comma, $Operator_Binding,
     $Operator_ShortCircuit, $Operator_Ternary, $Operator_Temp,
     $Operator_DotEq, $Operator_Mixin, $Operator_Let, $Operator_PostCall,
     $Operator_Function, $Operator_CompoundAssign); #OK
our ($Op, $OpAttribute, $OpBareBlock, $OpBuiltin, $OpCallLike, $OpCallMethod,
     $OpCallSub, $OpCatchyWrapper, $OpCgOp, $OpConditional, $OpConstantDecl,
     $OpContextVar, $OpDoOnceLoop, $OpForLoop, $OpGather, $OpGeneralConst,
     $OpGeneralLoop, $OpGetBlock, $OpGetSlot, $OpHereStub, $OpImmedForLoop,
     $OpIndirectVar, $OpLabelled, $OpLetVar, $OpLexical, $OpMakeCursor, $OpNum,
     $OpParen, $OpRegexBody, $OpRequire, $OpShortCircuit, $OpSimplePair,
     $OpSimpleParcel, $OpStart, $OpStateDecl, $OpStatementList,
     $OpStringLiteral, $OpTemporize, $OpTry, $OpWhatever, $OpWhateverCode,
     $OpWhen, $OpWhileLoop, $OpYada, $OpYouAreHere, $OpLexicalBind); #OK
our ($RxOp, $RxOpAlt, $RxOpAny, $RxOpBefore, $RxOpCut, $RxOpConj, $RxOpCutLTM,
     $RxOpCutBrack, $RxOpCutRule, $RxOpConfineLang, $RxOpCapturing,
     $RxOpCClassElem, $RxOpCheckBlock, $RxOpEndpoint, $RxOpListPrim,
     $RxOpNone, $RxOpNotBefore, $RxOpNewline, $RxOpProtoRedis, $RxOpQuantifier,
     $RxOpSubrule, $RxOpString, $RxOpSequence, $RxOpSigspace, $RxOpSeqAlt,
     $RxOpSaveValue, $RxOpStringCap, $RxOpSym, $RxOpStatement, $RxOpSetLang,
     $RxOpTilde, $RxOpVoidBlock, $RxOpVarString, $RxOpZeroWidth,
     $RxOpZeroWidthCCs); #OK

our ($Sig, $SigParameter, $PassSimplifier, $CClass, $OptBeta, $Backend,
     $CgOp, $OptRxSimple); #OK

our $Actions; $Actions = $Actions but role {
method variable($/) {
    my $sigil =  $<sigil>  ?? ~$<sigil> !! substr(~$/, 0, 1);
    my $twigil = $<twigil> ?? $<twigil><sym> !! '';

    my ($name, $pkg);
    my ($dsosl) = $<desigilname> ?? $<desigilname>.ast !!
        $<sublongname> ?? $<sublongname>.ast !!
        $<longname> ?? self.process_name($<longname>, :defer) !!
        Any;
    if defined($dsosl<ind>) {
        make { term => self.docontext($/, $sigil, $dsosl<ind>) };
        return;
    } elsif defined($dsosl<iname>) {
        make { term => $OpIndirectVar.new(pos=>$/,
            name => mkstringycat($/, $sigil ~ $twigil, $dsosl<iname>)) };
        return;
    } elsif $twigil eq '.' && $<postcircumfix>[0] {
        if defined $dsosl<pkg> {
            $/.CURSOR.sorry('$.Foo::bar syntax NYI');
        }

        make { term => self.docontext($/, $sigil, $OpCallMethod.new(pos=>$/,
            name => $dsosl<name>, receiver => mklex($/, 'self'),
            args => [ @($<postcircumfix>[0].ast.args) ])) };
        return;
    } elsif defined $dsosl {
        ($name, $pkg) = $dsosl<name pkg>;
    } elsif $<infixish> {
        make { term => $<infixish>.ast.as_function($/) };
        return;
    } elsif $<special_variable> {
        $name = substr(~$<special_variable>, 1);
    } elsif $<index> {
        make { capid => $<index>.ast, term =>
            self.docontextif($/, $sigil,
                mkcall($/, '&postcircumfix:<[ ]>',
                    $OpLexical.new(name => '$/'),
                    $OpNum.new(value => $<index>.ast)))
        };
        return Nil;
    } elsif $<postcircumfix>[0] && $twigil ne '.' {
        if $<postcircumfix>[0].reduced eq 'postcircumfix:sym<< >>' { #XXX fiddly
            make { capid => self.eval_ast_str($/, $<postcircumfix>[0].ast.args[0]) // '', term =>
                self.docontextif($/, $sigil,
                    mkcall($/, '&postcircumfix:<{ }>',
                        $OpLexical.new(name => '$/'),
                        @( $<postcircumfix>[0].ast.args)))
            };
            return;
        } else {
            if $<postcircumfix>[0].ast.args[0] -> $arg {
                make { term => self.docontext($/, $sigil, $arg) };
            } elsif $sigil eq '$' {
                make { term => $OpShortCircuit.new(pos=>$/, kind => '//',
                    args => [ $OpCallMethod.new(name => 'ast',
                                receiver => mklex($/, '$/')),
                              $OpCallMethod.new(name => 'Str',
                                receiver => mklex($/, '$/')) ] ) };
            } elsif $sigil eq any < @ % > {
                make { term => self.docontext($/, $sigil, mklex($/, '$/')) };
            } else {
                make { term => mklex($/, 'Mu') };
                $/.CURSOR.sorry("Missing argument for contextualizer");
            }
            return;
        }
    } else {
        $name = '';
    }

    make {
        sigil => $sigil, twigil => $twigil, name => $name, pkg => $pkg
    };
}
method circumfix:sym<{ }> ($/) {
    my $var = self.gensym;
    $*CURLEX<!sub>.add_my_sub($var, $<pblock>.ast);
    make $OpBareBlock.new(pos=>$/, :$var);

    if $<pblock>.ast.get_extend('hashy') {
        make mkcall($/, '&_hash_constructor',
            $OptBeta.make_call($/, $var));
    }
}
method check_hash($sub, $do is copy) {
    return False if $sub.arity;

    return False unless $do.^isa($OpStatementList);
    return True if $do.children == 0;
    return False if $do.children > 1;

    $do = $do.children[0];
    my @bits = $do.^isa($OpSimpleParcel) ?? @( $do.items ) !! $do;

    return True if @bits[0].^isa($OpSimplePair);

    if @bits[0].^isa($OpCallSub) &&
            @bits[0].invocant.^isa($OpLexical) &&
            @bits[0].invocant.name eq '&infix:<=>>' {
        return True;
    }

    if @bits[0].^isa($OpGeneralConst) && @bits[0].value.starts_with_pair {
        return True;
    }

    if @bits[0].^isa($OpLexical) && substr(@bits[0].name,0,1) eq '%' {
        return True;
    }

    return False;
}
method pblock($/) {
    #my $rw = $<lambda> && $<lambda> eq '<->'; TODO
    # snatch away some information here
    if self.check_hash($*CURLEX<!sub>, $<blockoid>.ast) {
        $*CURLEX<!sub>.set_extend('hashy', True);
    }

    $*CURLEX<!sub>.finish($<blockoid>.ast);
    $Backend.prune_match($<blockoid>);
    make $*CURLEX<!sub>;
}
method regex_def($/) {
    my $ast = $<regex_block>.ast;

    if $<regex_block><onlystar> {
        $ast = $RxOpProtoRedis.new(name => $*CURLEX<!name>);
    }

    my @lift = $ast.oplift;
    my $ltm = $OptRxSimple.run_lad($ast.lad);
    $*CURLEX<!sub>.set_ltm($ltm);
    ($ast, my $mb) = $OptRxSimple.run($ast);
    if $<regex_block><onlystar> {
        $*CURLEX<!sub>.finish_dispatcher('regex');
    } else {
        $*CURLEX<!sub>.finish($OpRegexBody.new(pos=>$/, pre => @lift,
            name => ($*CURLEX<!name> // ''), rxop => $ast, canback => $mb));
    }
    $Backend.prune_match($<regex_block>);
    make $OpLexical.new(pos=>$/, name => $*CURLEX<!sub>.outervar);
}
method embeddedblock($/) {
    $*CURLEX<!sub>.finish($<statementlist>.ast);
    $*CURLEX<!sub>.set_signature($Sig.simple());
    $Backend.prune_match($<statementlist>);
    make $*CURLEX<!sub>;
}
method package_def ($/) {
    my $sub = $*CURLEX<!sub>;
    my $obj = $sub.body_of;

    my $bodyvar = self.gensym;
    $sub.outer.add_my_sub($bodyvar, $sub);
    my $ast = ($<blockoid> // $<statementlist>).ast;

    if defined $*AUGMENT_BUFFER {
        # generate an INIT block to do the augment
        my $ph = $*unit.create_sub(
            outer      => $sub,
            cur_pkg    => $sub.cur_pkg,
            name       => "phaser-$sub.name()",
            class      => 'Code',
            run_once   => $sub.run_once);

        my @ops;
        for @( $*AUGMENT_BUFFER ) -> $mode, $name, $sym {
            push @ops, $CgOp._addmethod($CgOp.letvar('!mo'), $mode,
                $CgOp.str($name), $CgOp.fetch($CgOp.scopedlex($sym)));
        }
        my $fin = $CgOp.letn('!mo', $CgOp.class_ref('mo', $obj),
            @ops, $CgOp._invalidate($CgOp.letvar('!mo')), $CgOp.corelex('Nil'));

        $ph.finish($OpCgOp.new(op => $fin));
        $sub.create_static_pad;
        $ph.set_phaser($*backend.phaser('INIT'));

        make $OpCallSub.new(pos=>$/, invocant => mklex($/, $bodyvar));
    }
    else {
        if $<stub> {
            $*unit.stub_stash($/.from, $obj);

            make mklex($/, $*CURLEX<!sub>.outervar);
        }
        else {
            $/.CURSOR.trymop({ $obj.close; });

            if $obj.kind eq 'prole' {
                # return the frame object so that role instantiation can
                # find the cloned methods
                $ast = $OpStatementList.new(pos=>$/, children => [
                    $ast, mkcall($/, '&callframe') ]);
                $sub.create_static_pad;
                $obj.set_instantiation_block($sub);

                make mklex($/, $*CURLEX<!sub>.outervar);
            } else {
                make $OpStatementList.new(pos=>$/, children => [
                    $OpCallSub.new(pos=>$/, invocant => mklex($/, $bodyvar)),
                    $OpLexical.new(name => $*CURLEX<!sub>.outervar) ]);
            }
        }
    }

    $Backend.prune_match($<blockoid> // $<statementlist>);
    $sub.finish($ast);
}
method finish_method_routine ($/) {
    if self.is_dispatcher($<blockoid>) {
        $*CURLEX<!sub>.finish_dispatcher('multi');
    } else {
        $*CURLEX<!sub>.finish($<blockoid>.ast);
    }
    $Backend.prune_match($<blockoid>);
    make $OpLexical.new(pos=>$/, name => $*CURLEX<!sub>.outervar);
}
method block($/) {
    my $code = $<blockoid>.ast;
    $code = $OpCatchyWrapper.new(inner => $code) if $*catchy;
    $*CURLEX<!sub>.finish($code);
    $Backend.prune_match($<blockoid>);
    make $*CURLEX<!sub>
}
sub phaser($/, $ph, :$unique, :$topic, :$csp) {
    my $sub = ($<blast> // $<block>).ast;

    if $unique {
        $/.CURSOR.sorry("Limit one $ph phaser per block, please.")
            if $sub.outer.contains_phaser($*backend.phaser($ph));
    }

    $sub.outer.noninlinable;

    if $topic {
        $sub.has_lexical('$_') || $sub.add_my_name('$_');
        $sub.parameterize_topic;
        $sub.set_signature($Sig.simple('$_'));
    }
    $*CURLEX<!sub>.create_static_pad if $csp;
    $sub.set_phaser($*backend.phaser($ph));
    make $OpStatementList.new;
}
method comp_unit($/) {
    my $ast = $<statementlist>.ast;

    if $*CURLEX<!sub>.has_lexical('&MAIN') && $*UNITNAME eq 'MAIN' {
        $ast = $OpStatementList.new(children =>
            [ $ast, mkcall($/, '&MAIN_HELPER') ]);
    }

    $*CURLEX{'!sub'}.finish($ast);
    $Backend.prune_match($<statementlist>);

    make $*unit;
}
method statement_control:CATCH ($/) { phaser($/, 'CATCH', :unique, :topic) }
method statement_control:CONTROL ($/) { phaser($/, 'CONTROL', :unique, :topic) }
method statement_prefix:PRE ($/) { phaser($/, 'PRE') }
method statement_prefix:POST ($/) { phaser($/, 'POST', :topic) }
method statement_prefix:KEEP ($/) { phaser($/, 'KEEP', :topic) }
method statement_prefix:UNDO ($/) { phaser($/, 'UNDO', :topic) }
method statement_prefix:ENTER ($/) { phaser($/, 'ENTER') }
method statement_prefix:LEAVE ($/) { phaser($/, 'LEAVE', :topic) }

method statement_prefix:CHECK ($/) { phaser($/, 'CHECK', :csp) }
method statement_prefix:END ($/) { phaser($/, 'END', :csp) }
method statement_prefix:INIT ($/) { phaser($/, 'INIT', :csp) }
method statement_prefix:BEGIN ($/) {
    $*CURLEX<!sub>.create_static_pad;
    my $con = self.make_constant($/, 'anon', 'BEGIN');
    $<blast>.ast.run_BEGIN($con.name);
    $con.init = True;
    make $con;
}
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (dotnet)
   -L --language=NAME        # select your setting
   -I --include=DIR          # add a directory to search for modules
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $version = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose" => sub { $verb++ },
    "version|v" => sub { $version = True },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
our $Backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $Backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    backend => $Backend,
    verbose => $verb,
);

if $version {
    $c.compile_string('say "This is Niecza Perl 6 {$?PERL<version>}"', True);
    exit 0;
}

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp);
}
else {
    my $*repl_outer;
    my $*repl_outer_frame;
    $c.compile_string('$PROCESS::OUTPUT_USED ::= True', !$comp, :repl,
        :evalmode);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, :repl, :evalmode,
                :outer($*repl_outer), :outer_frame($*repl_outer_frame));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
