# vim: ft=perl6

my module SAFE;

# We have to do this directly due to the circularity saw.  Same
# reason forces uncontainerized .NET values.
#
# class ClassHOW {
#     has DynMetaObject $!value;
# }
#
# Due to concerns of screwing up composition, adding new superclasses, roles,
# or attributes in an augment is not allowed at this time.  Methods only.
#
# to create a class:
#     BEGIN my $Foo_HOW ::= ClassHOW.new("Foo");
#     BEGIN my $Foo;
#     BEGIN {
#         $Foo_HOW.add-super(...);
#         $Foo_HOW.add-role(...);
#         $Foo_HOW.add-method("bar", anon method bar { ... });
#         $Foo ::= $Foo_HOW.create-typeobject;
#     }
#
# to augment:
#     BEGIN { Foo.HOW.add-method("baz", anon method baz { ... }); }
my class ClassHOW { ... }

PRE-INIT {
    # ClassHOW.new($name) --> meta class instance
    sub new is rawcall { Q:CgOp {
        (withtypes $mo DynMetaObject $self DynObject
          [l $mo   (rawnew DynMetaObject (unbox String (@ (pos 1))))]
          [l $self (rawnew DynObject (rawcall (@ (pos 0)) GetMO))]

          [setfield how (l $mo) (l $self)]
          [rawcall (l $self) SetSlot (s value) (l $mo)]

          [ns (l $self)])
    } }

    # $how.add-super($p)
    sub add-super is rawcall { Q:CgOp {
        (rnull (rawcall (unbox DynMetaObject (@ (pos 0)))
                 AddSuperclass (unbox DynMetaObject (how (@ (pos 1))))))
    } }

    # $how.add-method($name, $sub)
    sub add-method is rawcall { Q:CgOp {
        (rnull (rawcall (unbox DynMetaObject (@ (pos 0))) AddMethod
                 (unbox String (@ (pos 1))) (@ (pos 2))))
    } }

    # $how.add-attribute($name)
    sub add-attribute is rawcall { Q:CgOp {
        (rnull (rawcall (unbox DynMetaObject (@ (pos 0))) AddAttribute
                 (unbox String (@ (pos 1)))))
    } }

    # $how.create-typeobject()
    sub create-typeobject is rawcall { Q:CgOp {
        (withtypes $p DynObject $mo DynMetaObject
          [l $mo (unbox DynMetaObject (@ (pos 0)))]
          [l $p (rawnew DynObject (l $mo))]

          [rawcall (l $mo) Complete]

          [setfield slots (l $p) (null 'object[]')]
          [setfield typeObject (l $mo) (l $p)]

          [ns (l $p)])
    } }

    Q:CgOp {
        (letn  chdmo  [rawnew DynMetaObject (s ClassHOW)]
               chhow  [null DynObject]
               chhvar [null Variable]
          [rawcall  (l chdmo) AddAttribute (s value)]
          [rawcall  (l chdmo) Complete]

          [l chhow  (rawnew DynObject (l chdmo))]
          [l chhvar (ns (l chhow))]

          [setfield how (l chdmo) (l chhow)]
          [rawcall (l chhow) SetSlot (s value) (l chdmo)]

          [rawcall (l chdmo) AddMethod (s new) (@ {&new})]
          [rawcall (l chdmo) AddMethod (s add-method) (@ {&add-method})]
          [rawcall (l chdmo) AddMethod (s add-attribute) (@ {&add-attribute})]
          [rawcall (l chdmo) AddMethod (s add-super) (@ {&add-super})]
          [rawcall (l chdmo) AddMethod (s create-typeobject)
            (@ {&create-typeobject})]

          [l ClassHOW (subcall (@ {&create-typeobject}) (l chhvar))]

          [null Variable])
    }
}

# cannot be a normal class - it has no parents
my class Mu { ... }
my class Any { ... }
my class Cool { ... }
# these are really defined in the kernel
my class Scalar { ... }
my class Sub { ... }
PRE-INIT {
    # (ClassHOW $boxed, ClassHOW $super --> ClassHOW)
    sub wrap-dpmo is rawcall { Q:CgOp {
        (withtypes $ch Variable $dm DynMetaObject
          [l $ch (pos 0)]
          [l $dm (unbox DynMetaObject (@ (pos 0)))]

          [setfield how (l $dm) (@ (l $ch))]
          [sink (methodcall (l $ch) add-super (pos 1))]
          [l $ch])
    } }

Q:CgOp {
    (withtypes !plist List<DynMetaObject> Mu!HOW Variable Any!HOW Variable
        Cool!HOW Variable Scalar!HOW Variable Sub!HOW Variable

      [l Mu!HOW (methodcall {ClassHOW} new (string_var Mu))]
      [l Mu (methodcall (l Mu!HOW) create-typeobject)]

      [l Any!HOW (methodcall {ClassHOW} new (string_var Any))]
      [sink (methodcall (l Any!HOW) add-super (l Mu))]
      [l Any (methodcall (l Any!HOW) create-typeobject)]

      [rawsset Kernel.AnyP (@ (l Any))]

      [l Cool!HOW (methodcall (l ClassHOW) new (string_var Cool))]
      [sink (methodcall (l Cool!HOW) add-super (l Any))]
      [l Cool (methodcall (l Cool!HOW) create-typeobject)]

      [sink (methodcall (ns (how (@ {ClassHOW}))) add-super (l Any))]
      [rawcall (rawcall (@ {ClassHOW}) GetMO) Complete]

      [l Sub!HOW (subcall (@ (l &wrap-dpmo))
        (box ClassHOW (rawsget Kernel.SubMO)) (l Any))]
      [l Sub (methodcall (l Sub!HOW) create-typeobject)]

      [l Scalar!HOW (subcall (@ (l &wrap-dpmo))
        (box ClassHOW (rawsget Kernel.ScalarMO)) (l Any))]
      [l Scalar (methodcall (l Scalar!HOW) create-typeobject)]

      [null Variable])
} }

my class Junction is Mu { }
my class Num is Cool {
    has $!value;
    method Str () { Q:CgOp {
        (box Str (rawcall (unbox Double (fetch (scopedlex self))) ToString))
    } }
    method Bool() { Q:CgOp {
        (box Bool (compare != (double 0)
                    (unbox Double (fetch (scopedlex self)))))
    } }
    method Numeric() { self }
    method ACCEPTS($t) { self == $t }
}
my class Str is Cool {
    has $!value;
    method Str () { self }
    method ACCEPTS($t) { self eq $t }
    method chars() { Q:CgOp {
        (box Num (cast Double (getfield Length (unbox String (@ (l self))))))
    } }
    method say() { Q:CgOp {
        (prog [rawscall Console.WriteLine
                (unbox String (fetch (l self)))]
              [box Bool (bool 1)]
        )
    } }
    method substr($from, $len) { Q:CgOp {
        (box Str (rawcall [unbox String (@ (l self))] Substring
                    [cast Int32 (unbox Double (@ (l $from)))]
                    [cast Int32 (unbox Double (@ (l $len)))]))
    } }
}
PRE-INIT { Q:CgOp { (prog [rawsset Kernel.StrP (@ (l Str))] [null Variable]) } }
my class Blob { }
my class Char { }
my class CharLingua { }
my class AnyChar { }
my class Codepoint { }
my class Grapheme { }
my class StrPos { }
my class StrLen { }
my class Rat { }
my class FatRat { }
my class Complex { }
my class Int { }
my class UInt { }
my class Bit { }
my class Instant { }
my class Duration { }
my class EnumType is Cool { }
my class Bool is EnumType {
    has $!value;
    method Str() { self ?? "Bool::True" !! "Bool::False" }
    method Bool() { self }
    method ACCEPTS($) { self }
    method Numeric() { self ?? 1 !! 0 }
    our constant True  = Q:CgOp { (box Bool (bool 1)) };
    our constant False = Q:CgOp { (box Bool (bool 0)) };
}
# TODO: import
constant True  = Q:CgOp { (box Bool (bool 1)) };
constant False = Q:CgOp { (box Bool (bool 0)) };

# taking a slurpy is wrong for this due to flattening.  I'm not sure what is
# right, maybe **@foo
sub infix:<~> is rawcall { Q:CgOp {
    (letn buf (rawnew System.Text.StringBuilder)
          i   (int 0)
          max (getfield Length (getfield pos (callframe)))
      [whileloop 0 0 (< (l i) (l max)) (prog
          [rawcall (l buf) Append
            (unbox String (@ (methodcall (pos (l i)) Str)))]
          [l i (+ (l i) (int 1))])]
      [box Str (rawcall (l buf) ToString)])
} }

sub infix:<+>($l,$r) { Q:CgOp {
    (box Num (arith + (unbox Double (fetch (scopedlex $l)))
                      (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<->($l,$r) { Q:CgOp {
    (box Num (arith - (unbox Double (fetch (scopedlex $l)))
                      (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<*>($l,$r) { Q:CgOp {
    (box Num (arith * (unbox Double (fetch (scopedlex $l)))
                      (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:</>($l,$r) { Q:CgOp {
    (box Num (arith / (unbox Double (fetch (scopedlex $l)))
                      (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< < >>($l,$r) { Q:CgOp {
    (box Bool (compare < (unbox Double (fetch (scopedlex $l)))
                         (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< > >>($l,$r) { Q:CgOp {
    (box Bool (compare > (unbox Double (fetch (scopedlex $l)))
                         (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< <= >>($l,$r) { Q:CgOp {
    (box Bool (compare <= (unbox Double (fetch (scopedlex $l)))
                          (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< >= >>($l,$r) { Q:CgOp {
    (box Bool (compare >= (unbox Double (fetch (scopedlex $l)))
                          (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< == >>($l,$r) { Q:CgOp {
    (box Bool (compare == (unbox Double (fetch (scopedlex $l)))
                          (unbox Double (fetch (scopedlex $r)))))
} }

sub infix:<< != >>($l,$r) { Q:CgOp {
    (box Bool (compare != (unbox Double (fetch (scopedlex $l)))
                          (unbox Double (fetch (scopedlex $r)))))
} }

sub warn($str) { Q:CgOp {
    (prog [rawscall Console.Error.WriteLine
            (unbox String (fetch (methodcall (scopedlex $str) Str))])
          [box Bool (bool 1)]
    )
} }

sub say($obj) { ($obj ~~ Cool) ?? $obj.say !! $obj.Str.say }

sub exit() { Q:CgOp {
    (prog [rawscall System.Environment.Exit (int 0) ]
          [null Variable]
    )
} }

sub infix:<=> is rawcall { Q:CgOp { (prog [assign (pos 0) (pos 1)] (pos 0)) } }

# Buglet in STD: standard infix operators look custom inside the setting, and
# forget their precedence.
sub prefix:<-->($v) { $v = ($v - 1); $v }
sub prefix:<++>($v) { $v = ($v + 1); $v }
sub postfix:<-->($v) { my $old = $v; $v = ($v - 1); $old }
sub postfix:<++>($v) { my $old = $v; $v = ($v + 1); $old }

sub prefix:<~>($v) { $v.Str } # should be Stringy
sub prefix:<?>($v) { $v.Bool }
sub prefix:<->($v) { 0 - $v }
sub prefix:<+>($x) { $x.Numeric }


sub prefix:<!>($v) { $v ?? False !! True }

sub infix:<eq>($l,$r) { Q:CgOp {
    (box Bool (compare ==
        (unbox String (fetch (methodcall (scopedlex $l) Str)))
        (unbox String (fetch (methodcall (scopedlex $r) Str)))))
} }
sub infix:<ne>($l,$r) { Q:CgOp {
    (box Bool (compare !=
        (unbox String (fetch (methodcall (scopedlex $l) Str)))
        (unbox String (fetch (methodcall (scopedlex $r) Str)))))
} }
# this one is horribly wrong and only handles the ref eq case.
sub infix:<===>($l,$r) { Q:CgOp {
    (box Bool (compare == (fetch (scopedlex $l)) (fetch (scopedlex $r))))
} }

sub infix:<~~>($t,$m) { ($m.defined) ?? ($m.ACCEPTS($t)) !! ($t.^does($m)) }

# TODO: Implement 'augment'

PRE-INIT {
    # rawcall to avoid putting a rw binding on self... TODO
    Mu.HOW.add-method("defined", anon method defined is rawcall {
            Q:CgOp { (box Bool (rawcall (@ (pos 0)) IsDefined)) }
        });
    Mu.HOW.add-method("head", anon method head { @(self).head });
    Mu.HOW.add-method("Bool", anon method Bool() { self.defined });
    Mu.HOW.add-method("Str", anon method Str() {
            my $tn := Q:CgOp { (box Str (rawcall (@ (l self)) GetTypeName)) };
            if self.defined {
                $tn ~ "()<instance>"
            } else {
                $tn ~ "()"
            }
        });
    Mu.HOW.add-method("so", anon method so() { self.Bool });
    Mu.HOW.add-method("not", anon method not() { ! self.Bool });
    Mu.HOW.add-method("RAWCREATE", anon method RAWCREATE is rawcall { Q:CgOp {
            (withtypes i Int32 max Int32 obj DynObject
              [l max (getfield Length (getfield pos (callframe)))]
              [l i (int 1)]
              [l obj (rawnew DynObject (getfield klass (cast DynObject
                      (@ (pos 0)))))]
              [whileloop 0 0 (< (l i) (l max)) (prog
                  [rawcall (l obj) SetSlot
                    (unbox String (@ (pos (l i))))
                    (nsw (@ (pos (+ (l i) (int 1)))))]
                  [l i (+ (l i) (int 2))])]
              [ns (l obj)])
        } });
    Mu.HOW.add-method("bless", anon method bless($obj) { Q:CgOp {
            (prog
              [setfield klass (cast DynObject (@ (l $obj)))
                (getfield klass (cast DynObject (@ (l self))))]
              [l $obj])
        } });
    Mu.HOW.add-method("CREATE", anon method CREATE() { Q:CgOp {
            (rawscall Kernel.DefaultNew (@ (l self))) } });
    Mu.HOW.add-method("new", anon method new() { Q:CgOp {
            (rawscall Kernel.DefaultNew (@ (l self))) } });

    Any.HOW.add-method("flat", anon method flat() { (self,).flat });

    Any.HOW.add-method("ACCEPTS", anon method ACCEPTS($t) { self === $t });
    Any.HOW.add-method('!butWHENCE', anon method !butWHENCE($cr) {
        Q:CgOp { (rawnew SimpleVariable (bool 1) (bool 0) (@ (l $cr)) (@ (l self))) }
    });

    # Should be for Block, not Sub
    Sub.HOW.add-method("ACCEPTS", anon method ACCEPTS($t) { (self)($t) });

    ClassHOW.HOW.add-method("isa", anon method isa($obj, $type) { Q:CgOp {
            (box Bool (rawcall (@ (l $obj)) Isa
              (getfield klass (cast DynObject (@ (l $type))))))
        } });
    ClassHOW.HOW.add-method("does",
        anon method does($obj, $role) { self.isa($obj, $role) }); #no roles yet
}

# Parcel: immutable list of boxes which have no context - may flatten, may
# autovivify, don't rebind or push/shift/etc
# List: mutable list of boxes without much context.  accessing off end returns
# undefined.  lazy.
# Seq: mutable list of boxes which are taken to be read-only scalars. The .Seq
# coercion makes the elements of a List read-only and maybe fetches them too.
# Array: mutable list of read-write scalar boxes

my class Iterator {
    # subclasses must provide .reify, return parcel
}

my class EMPTY { }

my class List { ... }
my class Seq { ... }
my class Array { ... }

sub flat(*@x) { @x }

my class Whatever { }

my class Parcel is Cool {
    has $!value;
    # $!value -> Variable[]

    method flat() { List.SETUP(True, self) }
    method list() { List.SETUP(False, self) }

    method elems() { Q:CgOp {
        (box Num (cast Double (getfield Length
              (unbox 'Variable[]' (@ {self})))))
    } }

    method iterator() {
        my class ParcelIterator is Iterator {
            has $.reify;
        }
        ParcelIterator.RAWCREATE("reify", self);
    }
}

sub infix:<,> is rawcall {
    Q:CgOp { (newrwlistvar (@ (box Parcel (getfield pos (callframe))))) };
}

sub unitem is rawcall {
    Q:CgOp { (newrwlistvar (@ (pos 0))) }
}

# Maybe this should be a constant, but constants are currently forced to
# scalar-nature (TODO)
sub Nil is rawcall { Q:CgOp { (newrwlistvar (@ (box Parcel (rawnewarr 'Variable')))) } }

my class List is Cool {
    has @!items;
    has @!rest;
    has $!flat;
    method flat() {
        unitem(Q:CgOp { (box Bool (getslot (s flat) (@ {self}))) }
            ?? self !! self.SETUP(True, (&infix:<,>(self.iterator))));
    }
    method list() { unitem(self) }

    method clone() { Q:CgOp {
        (letn dys (cast DynObject (@ {self}))
              new (rawnew DynObject (getfield klass (l dys)))
          (rawcall (l new) SetSlot (s flat)
            (rawcall (l dys) GetSlot (s flat)))
          (rawcall (l new) SetSlot (s items) (rawnew VarDeque
              (cast VarDeque (rawcall (l dys) GetSlot (s items)))))
          (rawcall (l new) SetSlot (s rest) (rawnew VarDeque
              (cast VarDeque (rawcall (l dys) GetSlot (s rest)))))
          (newrwlistvar (l new)))
    } }

    method SETUP($flat, $parcel) { Q:CgOp {
        (letn new (rawnew DynObject (rawcall (@ {self}) GetMO))
          (rawcall (l new) SetSlot (s flat) (unbox Boolean (@ {$flat.Bool})))
          (rawcall (l new) SetSlot (s rest) (rawnew VarDeque
              (unbox 'Variable[]' (@ {$parcel}))))
          (rawcall (l new) SetSlot (s items) (rawnew VarDeque))
          (newrwlistvar (l new)))
    } }

    method Seq() {
        Seq.SETUP(True, (&infix:<,>(self.iterator)));
    }

    #| Takes an object and applies whatever semantics the List subclass
    #| needs to apply on stuff out of the iterator stack
    method !elem is rawcall { Q:CgOp { (pos 1) } }

    sub has-iterators($self) { Q:CgOp {
        (box Bool (!= (i 0) (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s rest))) Count)))
    } }

    sub count-items($self) { Q:CgOp {
        (box Num (cast Double (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s items))) Count)))
    } }

    sub shift-iterator($self) { Q:CgOp {
        (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s rest))) Shift)
    } }

    sub shift-item($self) { Q:CgOp {
        (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s items))) Shift)
    } }

    method !item-at-pos($ix) { Q:CgOp {
        (getindex (cast Int32 (unbox Double (@ {$ix}))) (cast VarDeque (rawcall (cast DynObject (@ {self})) GetSlot (s items))))
    } }

    sub pop-item($self) { Q:CgOp {
        (rawcall (cast VarDeque (rawcall (cast DynObject (@ {$self})) GetSlot (s items))) Pop)
    } }

    sub push-iterator is rawcall { Q:CgOp {
        (prog (rawcall (cast VarDeque (rawcall (cast DynObject (@ (pos 0))) GetSlot (s rest))) Push (pos 1)) (null Variable))
    } }

    sub push-item is rawcall { Q:CgOp {
        (prog (rawcall (cast VarDeque (rawcall (cast DynObject (@ (pos 0))) GetSlot (s items))) Push (pos 1)) (null Variable))
    } }

    method !fill($nr) { Q:CgOp {
        (letn  nr    (cast Int32 (unbox Double (@ {$nr})))
               items (cast VarDeque (getslot (s items) (@ {self})))
               rest  (cast VarDeque (getslot (s rest) (@ {self})))
               flat  (cast Boolean  (getslot (s flat) (@ {self})))
               v     (null Variable)
               ItMo  (rawcall (@ {Iterator}) GetMO)
          (whileloop 0 0
            (ternary (< (rawcall (l items) Count) (l nr))
              (!= (rawcall (l rest) Count) (i 0)) (b 0))
            (prog
              (l v (rawcall (l rest) Shift))
              (ternary (ternary (l flat) (getfield islist (l v)) (b 0))
                (rawcall (l rest) Unshift (methodcall (l v) iterator))
                (ternary (rawcall (@ (l v)) Isa (l ItMo))
                  (rawcall (l rest) UnshiftN (unbox 'Variable[]'
                      (@ (methodcall (l v) reify))))
                  (rawcall (l items) Push (methodcall {self} !elem (l v)))))))
          (box Bool (>= (rawcall (l items) Count) (l nr))))
    } }

    method Bool() { self!fill(1) }
    method shift() {
        self!fill(1);
        shift-item(self);
    }

    method eager() {
        self!fill(1_000_000_000);
        self;
    }

    method head { self!fill(1) ?? self!item-at-pos(0) !! Any }

    method elems() { self!fill(1000_000_000); count-items(self); }
    method Numeric () { self.elems }

    method at-pos($i) {
        self!fill($i + 1);
        self!item-at-pos($i);
    }

    method iterator() {
        my class ListIterator is Iterator {
            has $!list;
            has $!reify;
            method reify() {
                $!reify // ($!reify = (
                    $!list ??
                        ($!list.shift, ListIterator.RAWCREATE("list", $!list,
                            "reify", Any)) !!
                        &infix:<,>()));
            }
        }
        my $itp = self.clone;
        ListIterator.RAWCREATE("list", $itp, "reify", Any);
    }

    method join($sep) {
        my $t;
        for self.flat -> $x {
            $t = ($t.defined ?? ($t ~ ($sep ~ $x)) !! $x);
        }
        $t // '';
    }

    method Str() { self.join(" ") }

    method push(*@items) {
        push-iterator(self, @items.Seq.eager.iterator)
    }
    method pop() {
        self.eager;
        pop-item(self);
    }
}

PRE-INIT { Q:CgOp {
    (prog
      (rawsset Kernel.ListMO
        (getfield klass (cast DynObject (@ {List}))))
      (null Variable))
} }

sub take($p) { # should be \|$p
    Q:CgOp { (rawsccall Kernel.Take (l $p)) }
}

PRE-INIT {
    Cool.HOW.add-method("grep", anon method grep($sm) {
            my $itp = @(self).clone;
            gather while $itp {
                my $r = $itp.shift;
                take $r if $r ~~ $sm;
            }
        });
    Cool.HOW.add-method("map",
        anon method map($func) {
            my $itp = @(self).clone;
            gather while $itp {
                my $r = $itp.shift;
                take $func($r);
            }
        });
    Cool.HOW.add-method("for",
        anon method for($func) {
            my $itp = @(self).clone;
            while $itp {
                my $r = $itp.shift;
                $func($r);
            }
        });
    Cool.HOW.add-method("say", anon method say() { self.Str.say });
    Cool.HOW.add-method("chars", anon method chars() { self.Str.chars });
    Cool.HOW.add-method("substr",
        anon method substr($x,$y) { self.Str.substr($x,$y) });

    Cool.HOW.add-method("at-pos",
        anon method at-pos($i) { self.flat.at-pos($i) });
    Cool.HOW.add-method("elems", anon method elems() { self.flat.elems });
    Cool.HOW.add-method("iterator",
        anon method iterator() { self.flat.iterator });
    Cool.HOW.add-method("join",
        anon method join($sep) { self.flat.join($sep) });
}

my class CallFrame {
    method caller() { Q:CgOp {
        (letn c (getfield caller (cast Frame (@ (l self))))
          (ternary
            (!= (letvar c) (null Frame))
            (ns (letvar c))
            (l Any)))
    } }
    method outer() { Q:CgOp {
        (letn c (getfield outer (cast Frame (@ (l self))))
          (ternary
            (!= (letvar c) (null Frame))
            (ns (letvar c))
            (l Any)))
    } }

    method file() { Q:CgOp { (box Str (rawcall
        (cast Frame (@ (l self))) ExecutingFile)) } }
    method line() { Q:CgOp { (box Num (cast Double (rawcall
        (cast Frame (@ (l self))) ExecutingLine))) } }

    method hints($var) { Q:CgOp { (rawcall (cast Frame (@ (l self)))
        LexicalFind (unbox String (@ (l $var)))) } }
}

PRE-INIT { Q:CgOp { (prog
    [rawsset Kernel.CallFrameMO (getfield klass
        (cast DynObject (@ (l CallFrame))))]
    [null Variable])
} }

sub caller { Q:CgOp { (ns (getfield caller (getfield caller (callframe)))) } }
sub callframe { Q:CgOp { (ns (getfield caller (callframe))) } }

sub die($msg) { Q:CgOp { (prog (die (@ (l $msg))) (null Variable)) } }
# exactly like List, but flattens, and with "is copy" semantics on stuff
my class Seq is List {
    method !elem($x) { my $y = $x; $y }
    method Seq { self }
}

my class Array is List {
    method new() {
        Array.SETUP(True, &infix:<,>())
    }

    method LISTSTORE(*@in) {
        # fetch everything NOW in case self is mentioned
        my $inn := @in.Seq.eager;

        Q:CgOp { (prog
            (rawcall (cast DynObject (@ {self})) SetSlot (s items)
              (rawcall (cast DynObject (@ {$inn})) GetSlot (s items)))
            (null Variable))
        };
        unitem(self);
    }

    method !extend is rawcall {
        Q:CgOp {
            (letn i (cast VarDeque (getslot (s items) (@ (pos 0))))
                  ct (- (cast Int32 (unbox Double (@ (pos 1))))
                        (rawcall (l i) Count))
              (ternary (>= (l ct) (int 0)) [prog]
                [die "Autovivification collision"])
              (whileloop 0 0 (!= (l ct) (int 0))
                (prog
                  (l ct (- (l ct) (int 1)))
                  (rawcall (l i) Push (newrwscalar (@ {Any})))))
              (rawcall (l i) Push (pos 2))
              (null Variable))
        };
    }

    method at-pos($ix) {
        self!fill($ix+1)
            ?? self!item-at-pos($ix)
            !! Any!butWHENCE(sub () is rawcall {
                self!extend($ix, Q:CgOp { (pos 0) });
            });
    }
}

sub postcircumfix:<[ ]> is rawcall {
    my $index ::= Q:CgOp { (pos 1) };

    (Q:CgOp { (pos 0) }).defined
        ?? (Q:CgOp { (pos 0) }).at-pos($index)
        !! Any!butWHENCE(sub () is rawcall {
            my $ar := Q:CgOp { (getindex (int 0) (getfield pos
                                 (getfield outer (callframe)))) };
            $ar.defined && die("Autovivification collision");
            $ar = Array.new;
            $ar!extend($index, Q:CgOp { (pos 0) });
        });
}

my class Hash {
    has $!value;
    method new() { Q:CgOp { (box Hash (rawnew Dictionary<string,Variable>)) } }
    method !extend is rawcall {
        Q:CgOp {
            (letn d [unbox Dictionary<string,Variable> (@ (pos 0))]
                  k [unbox String (@ (methodcall (pos 1) Str))]
              [ternary (rawcall (l d) ContainsKey (l k))
                (die "Autovivification collision")
                (prog)]
              [setindex (l k) (l d) (pos 2)]
              [null Variable])
        };
    }

    # TODO: We need something like pir:: notation for this to not suck
    method at-key($key) {
        Q:CgOp {
            (box Bool (rawcall [unbox Dictionary<string,Variable> (@ (l self))]
                ContainsKey [unbox String (@ (methodcall (l $key) Str))]))
        }
            ?? Q:CgOp {
                (getindex [unbox String (@ (methodcall (l $key) Str))]
                  [unbox Dictionary<string,Variable> (@ (l self))])
            } !! Any!butWHENCE({ self!extend($key, Q:CgOp { (pos 0) }) });
    }
}

PRE-INIT {
    Q:CgOp { (prog (rawsset Kernel.ArrayP (@ (l Array)))
                (rawsset Kernel.HashP (@ (l Hash)))
                (null Variable)) };

    Any.HOW.add-method("at-pos", anon method at-pos($ix) {
        ($ix == 0) ?? self !! die("Invalid index on non-list")
    });
}

sub postcircumfix:<{ }> is rawcall {
    my $key ::= Q:CgOp { (pos 1) };

    (Q:CgOp { (pos 0) }).defined
        ?? (Q:CgOp { (pos 0) }).at-key($key)
        !! Any!butWHENCE(sub () is rawcall {
            my $ar := Q:CgOp { (getindex (int 0) (getfield pos
                                 (getfield outer (callframe)))) };
            $ar.defined && die("Autovivification collision");
            $ar = Hash.new;
            $ar!extend($key, Q:CgOp { (pos 0) });
        });
}

my class GatherIterator is Iterator {
    has $!frame;
    has $!reify;

    method reify() {
        my $*nextframe;
        $!reify // ($!reify = (
            Q:CgOp {
                (letn getv (rawsccall Kernel.CoTake (cast Frame
                    (@ {$!frame})))
                  (box Parcel (ternary (== (@ {EMPTY}) (@ (l getv)))
                    (rawnewarr Variable)
                    (rawnewarr Variable
                      (l getv)
                      {GatherIterator.RAWCREATE("frame", $*nextframe, "reify", Any)}))))
            }));
    }
}

sub _gather($fr) {
    List.SETUP(True, (&infix:<,>(GatherIterator.RAWCREATE("frame", $fr,
        "reify", Any))));
}

my class Cursor {
    method new($str) { Q:CgOp { (ns (rawnew Cursor
        (@ {self}) (unbox System.String (@ {$str})))) } }
    method pos { Q:CgOp { (box Num (cast Double (getfield pos
        (cast Cursor (@ {self}))))) } }
    method cursor($np) { Q:CgOp { (ns (rawcall
        (cast Cursor (@ {self})) At
          (cast Int32 (unbox Double (@ {$np}))))) } }
    method orig { Q:CgOp {
        (box Str (getfield backing (cast Cursor (@ {self})))) } }
    method ws() { Q:CgOp { (rawcall (cast Cursor (@ {self})) SimpleWS) } }
    method at-key($k) { Q:CgOp {
        (rawcall (cast Cursor (@ {self})) GetKey (unbox String (@ {$k.Str})))
    } }
    method at-pos($i) { self.at-key($i) }
}

my class Match {
    method at-key($k) { Q:CgOp {
        (rawcall (cast Cursor (@ {self})) GetKey (unbox String (@ {$k.Str})))
    } }
    method at-pos($i) { self.at-key($i) }
    method new($) { die "Match.new NYI" }
    method from { Q:CgOp { (box Num (cast Double (getfield from
        (cast Cursor (@ {self}))))) } }
    method to { Q:CgOp { (box Num (cast Double (getfield pos
        (cast Cursor (@ {self}))))) } }
    method orig { Q:CgOp {
        (box Str (getfield backing (cast Cursor (@ {self})))) } }
    method chars { $.defined ?? $.to - $.from !! 0 }
    method Str { $.defined ?? $.orig.substr($.from, $.chars) !! "" }
}

PRE-INIT {
    Q:CgOp { (rnull (rawsset RxFrame.MatchMO (rawcall (@ {Match}) GetMO))) };
    ClassHOW.HOW.add-method("add-multiregex",
        anon method add-multiregex($name, $rx) {
            Q:CgOp { (prog
                [rawcall (unbox DynMetaObject (@ (pos 0)))
                  AddMultiRegex (unbox String (@ (l $name))) (@ (l $rx))]
                [l True])
            }
        });
}

my class Regex is Sub {
    method ACCEPTS($str) {
        my $i = 0;
        my $mat;
        my $C = Cursor.new($str);
        while !$mat && ($i <= $str.chars) {
            $mat = (self)($C.cursor($i++));
        }
        $mat.head;
    }
}

my class Grammar is Cursor {
    method parse($text) {
        my @results := self.new($text).TOP\
            .grep({ $_.to == $text.chars });
        @results ?? @results.shift !! Any; # TODO List.at-pos
    }
}

my class Enum is Cool {
    has $.key;
    has $.value;

    method kv() {
        ($.key, $.value);
    }

    method pairs() {
        self.flat;
    }
}

PRE-INIT {
    Q:CgOp {
        (prog
          (rawsset RxFrame.EMPTYP (@ {EMPTY}))
          (rawsset RxFrame.ListMO (getfield klass (cast DynObject (@ {List}))))
          (rawsset RxFrame.GatherIteratorMO (getfield klass
              (cast DynObject (@ {GatherIterator}))))
          (null Variable))
    }
}

my class Pair is Enum {
}

sub infix:<< => >>($k, $v) { Pair.RAWCREATE("key", $k, "value", $v) }

sub assignop($fn) {
    anon sub ANON is rawcall {
        Q:CgOp { (pos 0) } = $fn(Q:CgOp { (pos 0) }, Q:CgOp { (pos 1) })
    }
}

{YOU_ARE_HERE}
