#! /usr/bin/env perl
use warnings;
use strict;
use 5.010;

use lib 'src';
use CompilerDriver ':all';
use Getopt::Long;
use autodie ':all';

my @evaluate;
my $module;
my $stagestats;
my $stopafter;
my $aot;
my $lang = 'CORE';
my $safe;

sub usage {
    my ($fh, $ex) = @_;
    print $fh <<EOM;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl        # run a program
   OR: niecza -c File.pm     # precompile a module
   OR: niecza                # interactive shell

general options:
   --language=NAME           # select your setting
   --stage-stats             # detailed timing info
   --stop-after=STAGE        # stop after STAGE and dump AST
   --aot                     # run ahead-of-time compiler
   --safe                    # disable system interaction, implies -L SAFE
EOM
    exit $ex;
}

GetOptions('evaluate|e=s' => \@evaluate, 'aot' => \$aot,
        'compile|c' => \$module, 'language|L=s' => \$lang,
        'stage-stats|v' => \$stagestats, 'stop-after=s' => \$stopafter,
        'safe' => \$safe)
    or usage(\*STDERR, 1);

my $excl = 0;
$excl++ if @evaluate;
$excl++ if @ARGV;
if ($excl > 1 || $module && !@ARGV || $safe && ($lang ne 'CORE')) {
    usage(\*STDERR, 1);
}

$lang = 'SAFE' if $safe;

sub run {
    compile(main => !$module, stopafter => $stopafter, aot => $aot,
        stagetime => $stagestats, lang => $lang, safe => $safe, @_);
    system 'mono', CompilerDriver->build_file('MAIN.exe')
        if !$module && !$stopafter;
}

if (@ARGV) {
    require File::Slurp;
    for (@ARGV) {
        run(file => $_);
    }
} elsif (@evaluate) {
    for (@evaluate) {
        run(code => $_);
    }
} else {
    require Term::ReadLine;
    my $term = Term::ReadLine->new('niecza');
    while (defined ($_ = $term->readline("> ")) ) {
        /^\s*[^\s#]/ or next;
        eval {
            run(code => "say do $_");
        };
        say $@ if $@;
        $term->addhistory($_) if /\S/;
    }
}
