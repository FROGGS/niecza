use MONKEY_TYPING;
use CClass;
use CgOp;
use GetOptLong;
use NieczaActions;
use NieczaBackendDotnet;
use NieczaCompiler;
use NieczaFrontendSTD;
use NieczaPassSimplifier;
use NieczaPathSearch;
use Op;
use Operator;
use OpHelpers;
use OptBeta;
use OptRxSimple;
use RxOp;
use Sig;
use STD;

$GLOBAL::DEBUG_STD = (%*ENV<NIECZA_STD_DEBUG> ?? -1 !! 0);

augment class Any {
    submethod new(|$) { die "Attempted to instantiate undefined class." }
}

our ($Op, $OpAttribute, $OpBareBlock, $OpBuiltin, $OpCallLike, $OpCallMethod,
     $OpCallSub, $OpCatchyWrapper, $OpCgOp, $OpConditional, $OpConstantDecl,
     $OpContextVar, $OpDoOnceLoop, $OpForLoop, $OpGather, $OpGeneralConst,
     $OpGeneralLoop, $OpGetBlock, $OpGetSlot, $OpHereStub, $OpImmedForLoop,
     $OpIndirectVar, $OpLabelled, $OpLetVar, $OpLexical, $OpMakeCursor, $OpNum,
     $OpParen, $OpRegexBody, $OpRequire, $OpShortCircuit, $OpSimplePair,
     $OpSimpleParcel, $OpStart, $OpStateDecl, $OpStatementList,
     $OpStringLiteral, $OpTemporize, $OpTry, $OpWhatever, $OpWhateverCode,
     $OpWhen, $OpWhileLoop, $OpYada, $OpYouAreHere); #OK

our ($Sig, $SigParameter, $PassSimplifier); #OK

our $Actions; $Actions = $Actions but role {
# may throw!
method eval_ast($/, $ast) {
    # XXX simplification _should_ be idempotent but I don't how how true
    $ast := $PassSimplifier.invoke_incr($*CURLEX<!sub>, $ast);
    if $ast.const_value -> $cv { return $cv }
    my $sub = self.thunk_sub($ast);
    $*CURLEX<!sub>.create_static_pad;
    $sub.run_BEGIN_raw;
}
# DELETE qpvalue
method subshortname($/) {
    if $<colonpair> {
        my $n = ~$<category>;
        for @( $<colonpair> ) {
            $n ~= self.get_cp_ext($_);
        }
        make { name => $n };
    } else {
        make $<desigilname>.ast;
    }
}

method process_name($/, :$declaring, :$defer, :$clean) {
    return () unless defined $/;

    my @ns = @( $<name>.ast<names> );
    my $ext = '';
    my $trail = @ns && !defined @ns[*-1];
    pop @ns if $trail;

    if !$clean {
        for @( $<colonpair> ) {
            $ext ~= self.get_cp_ext($_);
        }
    }

    for $defer ?? () !! @ns.grep($Op) {
        $_ = ~self.trivial_eval($/, $_);
        # XXX should this always stringify?
        if $_ ~~ Cool {
            $_ = ~$_;
        } else {
            $_ = "XXX";
            $/.CURSOR.sorry("Name components must evaluate to strings");
        }
    }

    if $declaring {
        # class :: is ... { } is a placeholder for a lack of name
        return () if $trail && !@ns;
        $/.CURSOR.sorry("Illegal explicit declaration of a symbol table")
            if $trail;
        die "Unimplemented" if $defer;
        return () unless @ns;
        my $head = pop(@ns) ~ $ext;
        return Any, $head unless @ns;

        # the remainder is assumed to name an existing or new package
        my $pkg;
        $/.CURSOR.trymop({
            $pkg = $*CURLEX<!sub>.compile_get_pkg(@ns, :auto);
        });
        return $pkg, $head;
    }
    else {
        if $defer {
            # The stuff returned here is processed by the variable rule,
            # and also by method call generation

            goto "dyn" if $trail;
            goto "dyn" if $_.^isa($Op) for @ns;
            my $pkg;
            my @tail = @ns;
            my $head = pop(@tail) ~ $ext;
            unless @tail {
                return { name => $head } unless @tail;
            }
            try { $pkg = $*CURLEX<!sub>.compile_get_pkg(@tail, :auto) };
            goto "dyn" unless $pkg;

            return { name => $head, pkg => $pkg };
dyn:
            my @bits = map { $_, '::' }, @ns;
            pop @bits if @bits;
            push @bits, '::' if $trail;
            push @bits, $ext;
            return { iname => mkstringycat($/, @bits) };
        }

        $/.CURSOR.sorry("Class required, but symbol table name used instead")
            if $trail;
        return () unless @ns;
        my $head = pop(@ns) ~ $ext;
        my $pkg;
        $/.CURSOR.trymop({
            $pkg = $*CURLEX<!sub>.compile_get_pkg(@ns, $head);
        });
        return $pkg;
    }
}
method get_cp_ext($/) {
    if $/ eq any <:_ :U :D :T> {
        return "";
    } elsif !$<v>.^isa(Match) {
        return ":" ~ ($<v> ?? '' !! '!') ~ $<k>;
    } else {
        my $suf = ~$<v>;
        $/.CURSOR.trymop({
            $suf = self.eval_ast($/, $<v>.ast).to_string if $<v>.ast;
        });
        return ":" ~ $<k> ~ "<" ~ $suf ~ ">";
    }
}
method colonpair($/) {
    my $tv = $<v>.^isa(Match) ?? ($<v>.ast // ~$<v>) !!
        $OpLexical.new(name => $<v> ?? 'True' !! 'False');

    if $tv ~~ Str {
        if substr($<v>,1,1) eq '<' {
            $tv = mkcall($/, '&postcircumfix:<{ }>',
                $OpLexical.new(name => '$/'),
                $OpStringLiteral.new(text => ~$<k>));
        } else {
            $tv = self.do_variable_reference($/,
                { sigil => ~$<v><sigil>,
                    twigil => ($<v><twigil> ?? ~$<v><twigil> !! ''),
                    name => $<k> });
        }
    }

    make { term => $OpSimplePair.new(key => $<k>, value => $tv) };
}
}

# remove run_dispatch
CgOp._register_ops: < who sc_root sc_indir temporize _addmethod _invalidate
    rxlprim
>;

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -n                        # short for -L CORN
   -p                        # short for -L CORP
   -B --backend=NAME         # select backend (dotnet)
   -L --language=NAME        # select your setting
   -I --include=DIR          # add a directory to search for modules
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $version = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "p" => sub { $lang = "CORP" },
    "n" => sub { $lang = "CORN" },
    "verbose" => sub { $verb++ },
    "version|v" => sub { $version = True },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my @*INC;
my $backend;
if $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    backend => $backend,
    verbose => $verb,
);

if $version {
    $c.compile_string('say "This is Niecza Perl 6 {$?PERL<version>}"', True);
    exit 0;
}

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp);
}
else {
    my $*repl_outer;
    my $*repl_outer_frame;
    $c.compile_string('$PROCESS::OUTPUT_USED ::= True', !$comp, :repl,
        :evalmode);
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        my $ok;
        try {
            $c.compile_string($l, !$comp, :repl, :evalmode,
                :outer($*repl_outer), :outer_frame($*repl_outer_frame));
            $ok = True;
        }
        say $! unless $ok;
    }
    say "";
}
