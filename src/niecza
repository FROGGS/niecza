use Metamodel;
use Op;
use RxOp;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;
use OptRxSimple;
use Sig;

augment class NieczaActions {
method FALLBACK($meth, $/) {
    if $meth eq '::($name)' { # XXX STD miscompilation
        my $p = $<O><prec>;
        if $p eq 't=' { # additive
            make Operator.funop('&infix:<' ~ $<sym> ~ '>', 2);
        } elsif $p eq 'y=' && $<semilist> {
            make Operator.funop('&postcircumfix:<' ~ $<sym> ~ '>', 1, @( $<semilist>.ast ));
        } elsif $p eq 'y=' {
            make Operator.funop('&postfix:<' ~ $<sym> ~ '>', 1);
        } elsif $p eq 'v=' || $p eq 'o=' {
            make Operator.funop('&prefix:<' ~ $<sym> ~ '>', 1);
        } elsif $p eq 'z=' && !$<semilist> {
            make mkcall($/, '&term:<' ~ $<sym> ~ '>');
        }
    } elsif substr($meth,0,7) eq 'prefix:' {
        make Operator.funop('&prefix:<' ~ $<sym> ~ '>', 1);
    } elsif substr($meth,0,8) eq 'postfix:' {
        make Operator.funop('&postfix:<' ~ $<sym> ~ '>', 1);
    } elsif substr($meth,0,6) eq 'infix:' {
        make Operator.funop('&infix:<' ~ $<sym> ~ '>', 2);
    } elsif substr($meth,0,5) eq 'term:' {
        make mkcall($/, '&term:<' ~ $<sym> ~ '>');
    } else {
        $/.CURSOR.sorry("Action method $meth not yet implemented");
    }
}
method method_def ($/) {
    make ::Op::StatementList.new;
    my $scope = $*SCOPE // 'has';
    my $type = $<type> ?? ~$<type> !! '';
    $type = ($type eq ''  ?? 'normal' !!
             $type eq '^' ?? 'meta' !!
             $type eq '!' ?? 'private' !!
             (
                 $/.CURSOR.sorry("Unhandled method decoration $type");
                 return Nil;
             ));
    $scope = 'anon' if !$<longname>;
    my $name = $<longname> ?? self.unqual_longname($<longname>,
        "Qualified method definitions not understood") !! Any; #XXX

    if $<sigil> {
        $/.CURSOR.sorry("Method sgils NYI");
        return Nil;
    }
    if $type eq 'meta' {
        $/.CURSOR.sorry("Metamethod mixins NYI");
        return Nil;
    }
    if $<multisig> > 1 {
        $/.CURSOR.sorry("Multiple multisigs (what?) NYI");
        return Nil;
    }

    if ($scope eq 'augment' || $scope eq 'supersede' || $scope eq 'state') {
        $/.CURSOR.sorry("Illogical scope $scope for method");
        return Nil;
    }

    if ($scope eq 'our') {
        $/.CURSOR.sorry("Packages NYI");
        return Nil;
    }
    my $sig = $<multisig> ?? $<multisig>[0].ast !!
        self.get_placeholder_sig($/);

    my $unsafe = False;
    for @( $<trait> ) -> $t {
        if $t.ast<nobinder> {
            $sig = Any;
        } elsif $t.ast<unsafe> {
            $unsafe = True;
        } else {
            $/.CURSOR.sorry("NYI method trait $t");
        }
    }

    my $bl = self.sl_to_block('sub', $<blockoid>.ast,
        subname => $name, :$unsafe,
        signature => $sig ?? $sig.for_method !! Any);

    make self.block_to_closure($/, $bl, bindlex => ($scope eq 'my'),
        multiness => ($*MULTINESS || Any),
        bindmethod => ($scope ne 'anon' ?? [ $type, $name ] !! Any));
}

method block_to_closure($/, $body, :$bindlex, :$bindmethod, :$once,
        :$bindpackages = [], :$multiness) {
    ::Op::SubDef.new(|node($/), :$bindlex, :$bindmethod, :$body, :$once,
        :$bindpackages, :$multiness);
}

method regex_def($/) {
    sub _symtext($name) {
        ($name ~~ /\:sym\<(.*)\>/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name ~~ /\:(\w+)/) ?? ($name.substr(0, $/.from), ~$0) !!
            ($name, Str);
    }
    my ($name, $path) = $<deflongname> ??
        self.mangle_longname($<deflongname>[0]).<name path> !! Nil;
    my $cname;
    if defined($path) && $path == 0 && $name.^isa(Op) {
        $cname = $name;
        $name = ~$<deflongname>[0];
        $path = Any;
    }

    my $multiness = $*MULTINESS || Any;

    my $scope = (!defined($name)) ?? "anon" !! ($*SCOPE || "has");

    if $<signature> > 1 {
        $/.CURSOR.sorry("Multiple signatures on a regex NYI");
        return Nil;
    }

    if $cname && $scope ne 'has' {
        $/.CURSOR.sorry("Only has regexes may have computed names");
        make ::Op::StatementList.new;
        return Nil;
    }

    my $isproto;
    my ($basename, $symtext) = ($cname || !defined($name))
        ?? (Str, Str) !! _symtext($name);

    my $endsym;
    for map *.ast, @$<trait> -> $t {
        if $t<unary> || $t<binary> || $t<defequiv> {
            # Ignored for now
        }
        elsif defined $t<endsym> {
            $endsym = $t<endsym>;
        }
        else {
            $/.CURSOR.sorry("Unhandled regex trait $t.keys.[0]");
        }
    }

    if $multiness && $multiness eq 'proto' {
        if $<signature> || !$<regex_block><onlystar> || $scope ne 'has' ||
                !defined($basename) {
            $/.CURSOR.sorry("Only simple {*} protoregexes with no parameters are supported");
            return Nil;
        }
        @*MEMOS[0]<proto_endsym>{$basename} = $endsym;
    } else {
        my $m2 = defined($symtext) ?? 'multi' !! 'only';
        if $multiness && $multiness ne $m2 {
            $/.CURSOR.sorry("Inferred multiness disagrees with explicit");
        }
        $multiness = $m2;
        $endsym //= @*MEMOS[0]<proto_endsym>{$basename} if defined $basename;
    }

    if defined($path) && $scope ne 'our' {
        $/.CURSOR.sorry("Putting a regex in a package requires using the our scope.");
        return Nil;
    }

    my $sig = $<signature> ?? $<signature>[0].ast !! Sig.simple;

    if $scope eq 'state' || $scope eq 'supercede' || $scope eq 'augment' {
        $/.CURSOR.sorry("Nonsensical scope $scope for regex");
        return Nil;
    }

    if $scope eq 'our' {
        $/.CURSOR.sorry("our regexes NYI");
        return Nil;
    }

    my $ast = $<regex_block>.ast;
    if $multiness eq 'proto' {
        $ast = ::RxOp::ProtoRedis.new(name => $name);
    }

    {
        my $*paren = 0;
        my $*symtext = $symtext;
        my $*endsym = $endsym;
        my $*dba = $name // 'anonymous regex';
        $ast.check;
    }
    my $lad = OptRxSimple.run_lad($ast.lad);
    my @lift = $ast.oplift;
    ($ast, my $mb) = OptRxSimple.run($ast);
    make ::Op::SubDef.new(|node($/),
        :$multiness,
        bindlex => ($scope ne 'anon' && $scope ne 'has'),
        bindmethod => ($scope eq 'has' ?? ['normal', $cname // $name] !! Any),
        body => Body.new(
            ltm   => $lad,
            returnable => True,
            class => 'Regex',
            type  => 'regex',
            name  => $name // 'ANONrx',
            signature => $sig.for_method,
            do => ::Op::RegexBody.new(|node($/), pre => @lift,
                name => ($name // ''), rxop => $ast, canback => $mb)));
}

method routine_def ($/) {
    make ::Op::StatementList.new;
    if $<sigil> && $<sigil>[0] eq '&*' {
        $/.CURSOR.sorry("Contextual sub definitions NYI");
        return Nil;
    }
    my $dln = $<deflongname>[0];
    if $<multisig> > 1 {
        $/.CURSOR.sorry("Multiple multisigs (what?) NYI");
        return Nil;
    }
    my @export;
    my $return_pass = 0;
    my $signature = $<multisig> ?? $<multisig>[0].ast !!
        self.get_placeholder_sig($/);
    my $unsafe = False;
    for @( $<trait> ) -> $t {
        if $t.ast.<export> {
            push @export, @( $t.ast<export> );
        } elsif $t.ast<nobinder> {
            $signature = Any;
        } elsif $t.ast<return_pass> {
            $return_pass = 1;
        } elsif $t.ast<unsafe> {
            $unsafe = True;
        } else {
            $/.CURSOR.sorry("Sub trait $t.ast.keys.[0] not available");
        }
    }
    my $scope = !$dln ?? 'anon' !! ($*SCOPE || 'my');
    my ($m,$p) = $dln ?? self.mangle_longname($dln).<name path> !! ();

    if $scope ne 'my' && $scope ne 'our' && $scope ne 'anon' {
        $/.CURSOR.sorry("Illegal scope $scope for subroutine");
        return Nil;
    }
    if $scope eq 'our' {
        $/.CURSOR.sorry('Package subs NYI');
        return Nil;
    } elsif $p {
        $/.CURSOR.sorry('Defining a non-our sub with a package-qualified name makes no sense');
        return Nil;
    }

    make self.block_to_closure($/,
        bindlex => ($scope eq 'my'),
        multiness => ($*MULTINESS || Any),
        self.sl_to_block('sub',
            $<blockoid>.ast,
            returnable => !$return_pass,
            subname => $m, :$unsafe,
            signature => $signature),
        bindpackages => @export);
}

}

augment class CgOp {
#method run_protoregex (*@_) { self._cgop("run_protoregex", @_) }
method run_dispatch (*@_) { self._cgop("run_dispatch", @_) }
method var_get_var ($v) { self._cgop("var_get_var", $v) }
method var_new_tied ($t,$b,$f,$s) { self._cgop("var_new_tied", $t,$b,$f,$s) }
}

augment class Operator::Method { #OK exist
    method with_args($/, *@args) {
        if ($.name eq 'HOW' || $.name eq 'WHAT' || $.name eq 'VAR')
                && !$.private && !$.meta {
            if $.args {
                $/.CURSOR.sorry("Interrogative operator $.name does not take arguments");
                return ::Op::StatementList.new;
            }
            ::Op::Interrogative.new(|node($/), receiver => @args[0],
                name => $.name);
        } else {
            if defined($.path) && !$.private {
                $/.CURSOR.sorry("Qualified references to non-private methods NYI");
            }
            ::Op::CallMethod.new(|node($/),
                receiver => @args[0],
                ismeta   => $.meta,
                name     => $.name,
                private  => $.private,
                ppath    => $.path,
                args     => [ @$.args ]);
        }
    }
}

augment class Op::Interrogative { #OK exist
    method code($body) {
        if $.name eq "VAR" {
            return CgOp.var_get_var($.receiver.cgop($body));
        }
        my $c = CgOp.fetch($.receiver.cgop($body));
        if $.name eq "HOW" {
            $c = CgOp.how($c);
        }
        elsif $.name eq "WHAT" {
            $c = CgOp.obj_what($c);
        }
        else {
            die "Invalid interrogative $.name";
        }
        CgOp.newscalar($c);
    }
}

augment class RxOp::ProtoRedis { #OK exist
    method code($) {
        CgOp.letn(
          "fns", CgOp.run_dispatch(CgOp.callframe,
            CgOp.fetch(CgOp.scopedlex('self'))),
          "i",   CgOp.int(0),
          "ks",  CgOp.null('vvarlist'),
          CgOp.pushcut('LTM'),
          CgOp.label('nextfn'),
          CgOp.cgoto('backtrack',
            CgOp.compare('>=', CgOp.letvar("i"),
              CgOp.mrl_count(CgOp.letvar("fns")))),
          CgOp.rxpushb('LTM', 'nextfn'),
          CgOp.letvar("ks", CgOp.vvarlist_new_singleton(
            CgOp.subcall(CgOp.mrl_index(CgOp.letvar("i"),
                CgOp.letvar("fns")), CgOp.newscalar(CgOp.rxcall(
                    'MakeCursor'))))),
          CgOp.letvar("i", CgOp.arith('+', CgOp.letvar("i"), CgOp.int(1))),
          CgOp.label('nextcsr'),
          CgOp.ncgoto('backtrack', CgOp.iter_hasflat(CgOp.letvar('ks'))),
          CgOp.rxpushb('SUBRULE', 'nextcsr'),
          CgOp.rxcall('EndWith', CgOp.cast('cursor',
              CgOp.fetch(CgOp.vvarlist_shift(CgOp.letvar('ks'))))),
          CgOp.goto('backtrack'));
    }

    method lad() {
        $.cutltm ?? [ 'Imp' ] !! [ 'Dispatcher' ];
    }
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -B --backend=NAME         # select backend (nam, dotnet, clisp)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir, safemode => $safe);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $stages;
if $bcnd eq 'clisp' {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassSimplifier.new,
    ];
} else {
    $stages = [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ];
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $lang,
        safemode => $safe,
    ),
    stages => $stages,
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        $c.compile_string("say (" ~ $l ~ ").perl", !$comp, $stop);
    }
}
