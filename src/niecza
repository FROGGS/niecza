use Metamodel;
use Op;
use CClass;
use CgOp;
use Body;
use Unit;
use JSYNC;
use NAMOutput;
use NieczaFrontendSTD;
use NieczaPassBegin;
use NieczaPassBeta;
use NieczaPassSimplifier;
use NieczaBackendNAM;
use NieczaBackendDotnet;
use NieczaBackendClisp;
use NieczaPathSearch;
use NieczaCompiler;

use MONKEY_TYPING;

use GetOptLong;
use NieczaActions;
use OpHelpers;
use Operator;

sub mkstringycat($/, *@strings) {
    my @a;
    for @strings -> $s {
        my $i = ($s !~~ Op) ?? ::Op::StringLiteral.new(|node($/),
            text => $s) !! $s;

        # this *might* belong in an optimization pass
        if @a && @a[*-1] ~~ ::Op::StringLiteral &&
                $i ~~ ::Op::StringLiteral {
            @a[*-1] = ::Op::StringLiteral.new(|node($/),
                text => (@a[*-1].text ~ $i.text));
        } else {
            push @a, $i;
        }
    }
    if @a == 0 {
        return ::Op::StringLiteral.new(|node($/), text => "");
    } elsif  @a == 1 {
        return (@a[0] ~~ ::Op::StringLiteral) ?? @a[0] !!
            mkcall($/, '&prefix:<~>', @a[0]);
    } else {
        return mkcall($/, '&infix:<~>', @a);
    }
}

augment class NieczaActions {
method trait_mod:is ($/) {
    my $trait = ~$<longname>;
    my $noparm;

    if $/.CURSOR.is_name($trait) {
        make self.mangle_longname($<longname>);
        $noparm = 'Superclasses cannot have parameters';
    } elsif $trait eq 'export' {
        make { export => [ 'DEFAULT', 'ALL' ] };
        $noparm = 'Export tags NYI';
    } elsif ($trait eq 'rawcall') {
        make { nobinder => True };
    } elsif $trait eq 'return-pass' { # &return special
        make { return_pass => 1 };
    } elsif $trait eq 'rw' {
        make { rw => 1 };
    } elsif $trait eq 'parcel' {
        make { rwt => 1 };
    } elsif $trait eq 'readonly' {
        make { readonly => 1 };
    } else {
        $/.CURSOR.sorry("Unhandled trait $trait");
        make { };
    }

    if $noparm && $<circumfix> {
        $/.CURSOR.sorry($noparm);
    }
}
method parameter($/) {
    my $rw = False;
    my $sorry;
    my $slurpy;
    my $slurpycap;
    my $optional;
    my $rwt;

    for @( $<trait> ) -> $trait {
        if $trait.ast<rw> { $rw = True }
        elsif $trait.ast<parcel> { $rwt = True }
        elsif $trait.ast<readonly> { $rw = False }
        else {
            $trait.CURSOR.sorry('Unhandled trait ' ~ $trait.ast.keys.[0]);
        }
    }

    if $<post_constraint> > 0 {
        $/.sorry('Parameter post constraints NYI');
        make ::Sig::Parameter.new;
        return Nil;
    }

    my $default = $<default_value> ?? $<default_value>[0].ast !! Any;

    my $tag = $<quant> ~ ':' ~ $<kind>;
    if    $tag eq '**:*' { $sorry = "Slice parameters NYI" }
    elsif $tag eq '*:*'  { $slurpy = True }
    elsif $tag eq '|:*'  { $slurpycap = True }
    elsif $tag eq '\\:!' { $rwt = True }
    elsif $tag eq '\\:?' { $rwt = True; $optional = True }
    elsif $tag eq ':!'   { }
    elsif $tag eq ':*'   { $optional = True }
    elsif $tag eq ':?'   { $optional = True }
    elsif $tag eq '?:?'  { $optional = True }
    elsif $tag eq '!:!'  { }
    elsif $tag eq '!:?'  { $optional = True }
    elsif $tag eq '!:*'  { }
    else                 { $sorry = "Confusing parameters ($tag)" }
    if $sorry { $/.CURSOR.sorry($sorry); }
    my $p = $<param_var> // $<named_param>;

    make ::Sig::Parameter.new(name => ~$/, :$default,
        :$optional, :$slurpy, readonly => !$rw,
        :$slurpycap, rwtrans => $rwt, |$p.ast);
}

method capture($ ) {}
method capterm($/) {
    my @args;
    if $<capture> {
        my $x = $<capture>[0]<EXPR>.ast;
        if $x.^isa(::Op::SimpleParcel) {
            @args = @($x.items);
        } else {
            @args = $x;
        }
    } elsif $<termish> {
        @args = ::Op::Paren.new(|node($/), inside => $<termish>.ast);
    }
    make ::Op::CallSub.new(|node($/), invocant => mklex($/, '&_make_capture'),
        args => @args);
}
method process_nibble($/, @bits, $prefix?) {
    my @acc;
    for @bits -> $n {
        my $ast = $n.ast;

        if $ast ~~ CClass {
            $n.CURSOR.sorry("Cannot use a character class in a string");
            $ast = "";
        }

        if $ast !~~ Op && defined $prefix {
            $ast = $ast.split(/^^<before \s>[ $prefix || \s* ]/).join("");
        }

        push @acc, $ast;
    }

    my $post = $/.CURSOR.postprocessor;
    make mkstringycat($/, @acc);

    if $post eq 'null' {
        # already OK
    }
    # actually quotewords is a bit trickier than this...
    elsif $post eq 'words' || $post eq 'quotewords' {
        my $sl = $/.ast;
        if !$sl.^isa(::Op::StringLiteral) {
            make ::Op::CallMethod.new(|node($/), :name<words>, receiver => $sl);
        }
        else {
            my @tok = $sl.text.words;
            @tok = map { ::Op::StringLiteral.new(|node($/), text => $_) }, @tok;

            make ((@tok == 1) ?? @tok[0] !!
                ::Op::SimpleParcel.new(|node($/), items => @tok));
        }
    }
    elsif $post eq 'path' {
        # TODO could stand to be a lot fancier.
        make ::Op::CallMethod(|node($/), receiver => $/.ast, :name<IO>);
    }
    elsif $post eq 'run' {
        make mkcall($/, 'rungather', $/.ast);
    }
    else {
        $/.CURSOR.sorry("Unhandled postprocessor $post");
    }

    $/.ast;
}

method circumfix:sym«< >» ($/)   { make $<nibble>.ast }
method circumfix:sym«<< >>» ($/) { make $<nibble>.ast }
method circumfix:sym<« »> ($/)   { make $<nibble>.ast }

method postcircumfix:sym«< >» ($/) {
    make Operator.funop('&postcircumfix:<{ }>', 1, $<nibble>.ast);
}

method quote_mod:w  ($) { }
method quote_mod:ww ($) { }
method quote_mod:p  ($) { }
method quote_mod:x  ($) { }
method quote_mod:to ($) { }
method quote_mod:s  ($) { }
method quote_mod:a  ($) { }
method quote_mod:h  ($) { }
method quote_mod:f  ($) { }
method quote_mod:c  ($) { }
method quote_mod:b  ($) { }
my %opshortcut = (
    '@'   => [ 'fetch' ],
    'l'   => [ 'letvar' ],
    'ns'  => [ 'newscalar' ],
    'nsw' => [ 'newrwscalar' ],
    's'   => [ 'str' ],
    'i'   => [ 'int' ],
    'b'   => [ 'bool' ],
    'd'   => [ 'double' ],
    '=='  => [ 'compare', '==' ], '!=' => [ 'compare', '!=' ],
    '>='  => [ 'compare', '>=' ], '<=' => [ 'compare', '<=' ],
    '<'   => [ 'compare', '<' ],  '>'  => [ 'compare', '>' ],
    '+'   => [ 'arith', '+' ],    '-'  => [ 'arith', '-' ],
    '*'   => [ 'arith', '*' ],    '/'  => [ 'arith', '/' ],
);

method cgexp:op ($/) {
    my $l = ~$<cgopname>;
    my @p = @( %opshortcut{$l} // [ $l ] );
    make [@p, map *.ast, @( $<cgexp> )];
}

method statement_control:unless ($/) {
    make ::Op::Conditional.new(|node($/), check => $<xblock>.ast[0],
        false => self.block_to_immediate($/, 'cond', $<xblock>.ast[1]));
}

method statement_control:loop ($/) {
    my $body = self.block_to_immediate($/, 'loop', $<block>.ast);
    # XXX wrong interpretation
    my $init = $0 && $0[0]<e1>[0] ?? $0[0]<e1>[0].ast !! Any;
    my $cond = $0 && $0[0]<e2>[0] ?? $0[0]<e2>[0].ast !! Any;
    my $step = $0 && $0[0]<e3>[0] ?? $0[0]<e3>[0].ast !! Any;

    make ::Op::GeneralLoop.new(|node($/), :$body, :$init, :$cond, :$step);
}

method statement_control:repeat ($/) {
    my $until = $<wu> eq 'until';
    my $check = $<xblock> ?? $<xblock>.ast[0] !! $<EXPR>.ast;
    my $body  = self.block_to_immediate($/, 'loop',
        $<xblock> ?? $<xblock>.ast[1] !! $<pblock>.ast);
    make ::Op::WhileLoop.new(|node($/), :$check, :$until, :$body, :once);
}
}

augment class CgOp {
method letscope(*@items) { self._cgop('letscope', @items) }
method xspan(*@items) { self._cgop('xspan', @items) }
method bif_mod($x,$y) { self._cgop('bif_mod', $x, $y) }
}

augment class Op {
class LetScope is Op {
    has $.transparent;
    has $.names;
    has $.inner;

    method zyg() { $.inner }

    method code($body) {
        CgOp.letscope(+$.transparent, @($.names), $.inner.cgop($body));
    }
}

class Control is Op {
    has $.payload = die "Control.payload required"; # Op
    has $.name = "";
    has $.number = die "Control.number required"; # Num

    method zyg() { $.payload }

    method code($body) {
        CgOp.control($.number, CgOp.null('frame'), CgOp.int(-1),
            ($.name eq '' ?? CgOp.null('str') !! CgOp.str($.name)),
            $.payload.cgop($body));
    }
}

class GeneralLoop is Op {
    has $.init; # Op
    has $.cond; # Op
    has $.step; # Op
    has $.body; # Op

    method zyg() { grep &defined, $.init, $.cond, $.step, $.body }
    method ctxzyg($) {
        ($.init ?? ($.init, 0) !! ()),
        ($.cond ?? ($.cond, 1) !! ()),
        ($.step ?? ($.step, 0) !! ()),
        $.body, 0
    }

    method code($body) { self.code_labelled($body,'') }
    method code_labelled($body, $l) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.prog(
            ($.init ?? CgOp.sink($.init.cgop($body)) !! ()),
            CgOp.whileloop(0, 0,
                ($.cond ?? CgOp.obj_getbool($.cond.cgop($body)) !!
                    CgOp.bool(1)),
                CgOp.prog(
                    CgOp.sink(CgOp.xspan("redo$id", "next$id", 0,
                            $.body.cgop($body), 1, $l, "next$id",
                            2, $l, "last$id", 3, $l, "redo$id")),
                    ($.step ?? CgOp.sink($.step.cgop($body)) !! ()))),
            CgOp.label("last$id"),
            CgOp.corelex('Nil'));
    }
}

}

augment class Op::WhileLoop { #OK exist
    method code_labelled($body, $l) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.prog(
            CgOp.whileloop(+$.until, +$.once,
                CgOp.obj_getbool($.check.cgop($body)),
                CgOp.sink(CgOp.xspan("redo$id", "next$id", 0, $.body.cgop($body),
                    1, $l, "next$id", 2, $l, "last$id", 3, $l, "redo$id"))),
            CgOp.label("last$id"),
            CgOp.corelex('Nil'));
    }
}

augment class Op::ImmedForLoop { #OK exist
    method code_labelled($body, $l) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.rnull(CgOp.letn(
            "!iter$id", CgOp.vvarlist_new_empty,
            $.var, CgOp.null('var'),
            CgOp.vvarlist_push(CgOp.letvar("!iter$id"),
                $.source.cgop($body)),
            CgOp.whileloop(0, 0,
                CgOp.iter_hasflat(CgOp.letvar("!iter$id")),
                CgOp.prog(
                    CgOp.letvar($.var,
                        CgOp.vvarlist_shift(CgOp.letvar("!iter$id"))),
                    CgOp.sink(CgOp.xspan("redo$id", "next$id", 0,
                        $.sink.cgop($body),
                        1, $l, "next$id",
                        2, $l, "last$id",
                        3, $l, "redo$id")))),
            CgOp.label("last$id")));
    }
}

augment class Op::When { #OK exist
    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.ternary(CgOp.obj_getbool(CgOp.methodcall(
                $.match.cgop($body), 'ACCEPTS', CgOp.scopedlex('$_'))),
            CgOp.xspan("start$id", "end$id", 0, CgOp.prog(
                    CgOp.sink($.body.cgop($body)),
                    CgOp.control(6, CgOp.null('frame'), CgOp.int(-1),
                        CgOp.null('str'), CgOp.corelex('Nil'))),
                7, '', "end$id"),
            CgOp.corelex('Nil'));
    }
}

augment class Op::Try { #OK exist
    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.xspan("start$id", "end$id", 1, $.body.cgop($body),
            5, '', "end$id");
    }
}

augment class Op::TopicalHook { #OK exist
    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.xspan("start$id", "end$id", 0, $.inner.cgop($body),
            6, '', "end$id");
    }
}

augment class Op::LabelHook { #OK exist
    method code($body) {
        my $id = ::GLOBAL::NieczaActions.genid;

        CgOp.xspan("start$id", "end$id", 0, $.inner.cgop($body),
            map({ 8, $_, "goto_$_" }, @$.labels));
    }
}

my $usage = q:to/EOM/;
niecza -- a command line wrapper for Niecza

usage: niecza -e 'code'      # run a one-liner
   OR: niecza file.pl [args] # run a program
   OR: niecza -C MyModule    # precompile a module
   OR: niecza                # interactive shell

general options:
   -B --backend=NAME         # select backend (nam, dotnet, clisp)
   -L --language=NAME        # select your setting
   -v --verbose              # detailed timing info
   -c --compile              # don't run (implied with -C)
      --stop-after=STAGE     # stop after STAGE and dump AST
      --safe                 # disable system interaction, implies -L SAFE
      --help                 # display this message

backend options:
      --obj-dir=DIR          # select output location (all)
EOM

my $runobj = Q:CgOp { (box Str (rawcall get_BaseDirectory (rawscall System.AppDomain.get_CurrentDomain))) };
my $basedir = $runobj.IO.append("..").realpath;

my @lib  = $basedir.append("lib"), ".".IO.realpath;
my $lang = "CORE";
my $safe = False;
my $bcnd = "dotnet";
my $odir = $basedir.append("obj");
my $verb = 0;
my @eval;
my $cmod = False;
my $comp = False;
my $stop = "";
my $aotc = False;

GetOptions(:!permute,
    "evaluate|e=s" => sub { push @eval, $_ },
    "compile-module|C" => sub { $cmod = True },
    "backend|B=s" => sub { $bcnd = $_ },
    "language|L=s" => sub { $lang = $_ },
    "verbose|v" => sub { $verb++ },
    "compile|c" => sub { $comp = True },
    "safe" => sub { $safe = True },
    "stop=s" => sub { $stop = $_ },
    "aot" => sub { $aotc = True },
    "include|I=s" => sub { unshift @lib, $_.IO.realpath },
    "obj-dir=s" => sub { $odir = $_ },
    "help|h" => sub { say $usage; exit 0 },
);

my $backend;
if $bcnd eq 'nam' {
    $backend = NieczaBackendNAM.new(obj_dir => $odir);
}
elsif $bcnd eq 'dotnet' || $bcnd eq 'mono' {
    $backend = NieczaBackendDotnet.new(obj_dir => $odir);
}
elsif $bcnd eq 'clisp' {
    $backend = NieczaBackendClisp.new(obj_dir => $odir);
}
else {
    note "Backend '$bcnd' not supported";
    exit 1;
}

my $c = NieczaCompiler.new(
    module_finder => NieczaPathSearch.new(
        path => @lib,
    ),
    frontend => NieczaFrontendSTD.new(
        lang => $safe ?? 'SAFE' !! $lang,
        safemode => $safe,
    ),
    stages => [
        NieczaPassBegin.new,
        NieczaPassBeta.new,
        NieczaPassSimplifier.new,
    ],
    backend => $backend,
    verbose => $verb,
);

if $cmod {
    if @eval {
        note "Module compilation cannot be used with strings to evaluate";
        exit 1;
    }
    if !@*ARGS {
        say "No modules named to compile!";
        exit 0;
    }
    for @*ARGS {
        $c.compile_module($_, $stop);
    }
}
elsif @eval {
    $c.backend.run_args = @*ARGS;
    for @eval {
        $c.compile_string($_, !$comp, $stop);
    }
}
elsif @*ARGS {
    my $file = shift @*ARGS;
    $c.backend.run_args = @*ARGS;
    $c.compile_file($file, !$comp, $stop);
}
else {
    while True {
        print "niecza> ";
        my $l = $*IN.get // last;
        $c.compile_string("say (" ~ $l ~ ").perl", !$comp, $stop);
    }
}
